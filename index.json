[{"categories":["C#","ASP.NET Core","Tools"],"content":"MeiliSearch 常用Cli 設定 ","date":"2023-03-17","objectID":"https://loulazynote.github.io/posts/meilisearchcliusage/:1:0","tags":["MeiliSearch","MeiliSearch 1.0.0",".Net Core 6","C#","ASP.NET Core","Tools"],"title":"MeiliSearch 常用Cli 設定","uri":"https://loulazynote.github.io/posts/meilisearchcliusage/"},{"categories":["C#","ASP.NET Core","Tools"],"content":"前言 關於MeiliSearch有一些在使用前可以做的設定, 官方也提供多種方式都與安裝方式有關, 這篇就記錄一下這些設定要怎麼使用(主要以Cli方式) ","date":"2023-03-17","objectID":"https://loulazynote.github.io/posts/meilisearchcliusage/:1:1","tags":["MeiliSearch","MeiliSearch 1.0.0",".Net Core 6","C#","ASP.NET Core","Tools"],"title":"MeiliSearch 常用Cli 設定","uri":"https://loulazynote.github.io/posts/meilisearchcliusage/"},{"categories":["C#","ASP.NET Core","Tools"],"content":"有哪些指令? 基本Cli --db-path : 指定DB建立的位置 環境變數: MEILI_DB_PATH ./meilisearch-windows-amd64.exe --db-path='D:/MeiliSearchDemo/Database' --http-addr : 指定Http位址及Port號 環境變數: MEILI_HTTP_ADDR ./meilisearch-windows-amd64.exe --http-addr='127.0.0.1:7700' --env : 指定開發環境或是正式環境 環境變數: MEILI_ENV ./meilisearch-windows-amd64.exe --env=development production : 設定為正式環境會有一些限制, 必須要設定 master key, 且套件提供的簡易預覽畫面會關閉 development : master key是可選項目不一定要設定, 套件提供的簡易預覽畫面開啟 --master-key : 設定密鑰, 至少要設定16個UTF-8的字元, 預設是沒有設定的, 如果啟動時沒有設定密鑰, 或低於16字元, 那Meilisearch會自動產生一個\"建議\"的密鑰, 可以在重新啟動時將它寫入 環境變數: MEILI_MASTER_KEY 密鑰保護除了 GET /health 的API以外都包含在內 ./meilisearch-windows-amd64.exe --master-key=\"MASTER_KEY\" --no-analytics : 關閉分析, Meilisearch會自動收集實例的資料, 所有收集的資料只用於改進Meilisearch, 可以使用此指令關閉 環境變數: MEILI_NO_ANALYTICS ./meilisearch-windows-amd64.exe --no-analytics --dump-dir : 設定位置以產生DB的轉移dump文件, 可用於恢復Meilisearch資料或在不同版本之間轉移 環境變數: MEILI_DUMP_DIR --import-dump : 匯入指定路徑的轉移dump文件, 如果Database已經存在, Meilisearch將拋出一個錯誤並中止啟動 環境變數: MEILI_IMPORT_DUMP --ignore-missing-dump : 防止 Meil​​isearch 在 --import-dump 未指向有效轉移dump文件時跳出錯誤, 如果Database已經存在, 將正常啟動而不導入任何轉移dump文件 環境變數: MEILI_IGNORE_MISSING_DUMP --ignore-dump-if-db-exists : 使用 --import-dump 時防止Database已經存在 而Meil​​isearch 執行時跳出錯誤, 如果Database已經存在, 轉移dump文件將被忽略，Meilisearch 將使用現有Database啟動 環境變數: MEILI_IGNORE_DUMP_IF_DB_EXISTS 此指令不需要填寫任何值, 加上指令即可, 有加上值則會跳出錯誤 如果未定義 --import-dump此選項則跳錯誤 --log-level : 設定MeiliSearch的Log等級, 顯示在Dos畫面上 (聽說有被正名叫命令提示字元, 那powershell/bash/docker這些畫面不就也要另外名詞?我就懶) 環境變數: MEILI_LOG_LEVEL INFO : 預設值, 記錄所有事件 ERROR : 只記錄Meilisearch的意外事件及錯誤 WARN : 記錄所有意外事件,無論嚴重程度 DEBUG : 記錄所有事件, 包括Meilisearch內部程式流的詳細訊息 TRACE : 記錄所有事件，包括Meilisearch內部程式流的更多詳細信息, 官方不建議使用, 因為它顯示的內容太多太冗長, 官方更建議使用 DEBUG OFF : 關閉記錄 比較重要的Cli(請慎用) --max-indexing-memory : 設定MeiliSearch在建立索引時可以使用的記憶體大小, 預設是使用該機器(PC/VM/Server一樣)不超過2/3的可用記憶體 環境變數: MEILI_MAX_INDEXING_MEMORY 此設定必須以字元為單位, 或明確的一個基本單位, 如: 107374182400 或 '107.7Gb' 或 '107374Mb'等 如果設定大於或等於機器的總記憶體的值, 非常有可能導致實作崩潰 在索引過程中, Meilisearch有可能超過設定的RAM限制, 但在大多數情況下, 這應該是可以忽略的量, 對穩定及性能幾乎沒有影響(官方是這樣說啦~但我感受是還是有影響) ./meilisearch-windows-amd64.exe --max-indexing-memory='4Gb' --max-indexing-threads : 設定 Meil​​isearch 在建立索引時可使用的最大核心數, 預設是避免使用機器總處理單元的一半以上 環境變數: MEILI_MAX_INDEXING_THREADS 預設是 使用機器1/2可用內核數 如果 --max-indexing-threads 大於機器實際可用內核數, MeiliSearch將使用最大可用內核數 在單核機器上, MeiliSearch只能使用唯一可用的內核來進行索引, 這可能會導致建立索引時的搜索體驗下降 (親體驗用2 Cores也很慢) 請避免將 --max-indexing-threads 設定為機器處理器內核的總數, 雖然這樣可能加快建立索引速度, 但可能會嚴重影響搜索體驗 ./meilisearch-windows-amd64.exe --max-indexing-threads=4 --http-payload-size-limit : 限制Http Request的大小, 預設是100Mb, 如果超過設定值會拒絕Request並給予錯誤訊息 環境變數: MEILI_HTTP_PAYLOAD_SIZE_LIMIT 此設定必須以字元為單位, 或明確的一個基本單位, 如: 107374182400 或 '107.7Gb' 或 '107374Mb'等 ./meilisearch-windows-amd64.exe --http-payload-size-limit='200Mb' 關於備份Cli(1.0.0版本後才有的功能) --schedule-snapshot : 自動備份Database及index, 預設是關閉的, 而啟用的方式則是加上此指令即可 環境變數: MEILI_SCHEDULE_SNAPSHOT 可以直接使用, 並不指定數值, 這樣的話每24HR就會自動備份一次(--schedule-snapshot=86400) 提供的數值以秒計算 # 這樣表示每一小時都備份一次 ./meilisearch-windows-amd64.exe --schedule-snapshot=3600 經測試, 備份是做差異備份, 如果資料都沒有變動, 則會有一個暫存檔案會變更 --snapshot-dir : 備份檔案指定位置, 預設是套件所在根目錄下的snapshots/ 環境變數: MEILI_SNAPSHOT_DIR --import-snapshot : 匯入備份 環境變數: MEILI_IMPORT_SNAPSHOT ./meilisearch-windows-amd64.exe --import-snapshot='D:/MeiliSearchDemo/snapshots/' 如果Database已存在則會失敗 找不到有效的備份檔案(snapshot)則會失敗 --ignore-missing-snapshot : 防止 Meil​​isearch 在 --import-snapshot 未指向有效快照文件時跳出錯誤, 如果未定義 --import-snapshot，此指令將跳出錯誤 環境變數: MEILI_IGNORE_MISSING_SNAPSHOT 不需要給值, 給的話會跳錯 --ignore-snapshot-if-db-exists : 使用 --import-snapshot 時防止已有資料庫的 Meil​​isearch 跳出錯誤，且snapshot將被忽略, MeiliSearch將使用現有資料庫啟動 環境變數: MEILI_IGNORE_SNAPSHOT_IF_DB_EXISTS 如果未定義 --import-snapshot, 此指令會跳錯誤 不需要給值, 給的話會跳錯 SSL選項Cli設定(預設值都是none) --ssl-auth-path : 啟用客戶端身份驗證, 需要提供一個文件夾的路徑, MeiliSearch 會從該文件夾中讀取客戶端證書, 而該文件夾應包含一個或多個 PEM 格式的客戶端證書, 通常用於安全性要求較高的應用程序, 例如企業內部系統 環境變數: MEILI_SSL_AUTH_PATH # 需要將 --ssl-cert-path 及 --ssl-key-path 和 --http-addr 選項的值更改為自己的值 ./meilisearch --http-addr '127.0.0.1:7700' --ssl-cert-path 'D:/Meilisearch/ssl/cert.pem' --ssl-ke","date":"2023-03-17","objectID":"https://loulazynote.github.io/posts/meilisearchcliusage/:1:2","tags":["MeiliSearch","MeiliSearch 1.0.0",".Net Core 6","C#","ASP.NET Core","Tools"],"title":"MeiliSearch 常用Cli 設定","uri":"https://loulazynote.github.io/posts/meilisearchcliusage/"},{"categories":["C#","ASP.NET Core","Tools"],"content":"參考資料 MeiliSearch - Configure Meilisearch at launch ","date":"2023-03-17","objectID":"https://loulazynote.github.io/posts/meilisearchcliusage/:1:3","tags":["MeiliSearch","MeiliSearch 1.0.0",".Net Core 6","C#","ASP.NET Core","Tools"],"title":"MeiliSearch 常用Cli 設定","uri":"https://loulazynote.github.io/posts/meilisearchcliusage/"},{"categories":["C#","ASP.NET Core","Tools"],"content":"MeiliSearch(網稱 美麗搜尋) ","date":"2023-03-08","objectID":"https://loulazynote.github.io/posts/meilisearchbasicusage/:1:0","tags":["MeiliSearch","MeiliSearch 1.0.0",".Net Core 6","C#","ASP.NET Core","Tools"],"title":"MeiliSearch基本用法","uri":"https://loulazynote.github.io/posts/meilisearchbasicusage/"},{"categories":["C#","ASP.NET Core","Tools"],"content":"前言 讓我玩了接近4個月的套件, 讓我踩雷滿滿的套件, 還要應付User腦洞大開的奇幻冒險, 怎麼可以不留下記錄呢? 但相比其他幾套知名的開源全文檢索套件來說, 這套真的比較輕量也比較簡單 ","date":"2023-03-08","objectID":"https://loulazynote.github.io/posts/meilisearchbasicusage/:1:1","tags":["MeiliSearch","MeiliSearch 1.0.0",".Net Core 6","C#","ASP.NET Core","Tools"],"title":"MeiliSearch基本用法","uri":"https://loulazynote.github.io/posts/meilisearchbasicusage/"},{"categories":["C#","ASP.NET Core","Tools"],"content":"何為MeiliSearch MeiliSearch 是一個輕量級的現成全文檢索套件, 使用RESTful搜尋API即可使用, 並支援各大系統(Windows、MacOS、Linux), 且是 Open Source所以不必擔心商業授權問題 而官方也有提供 MeiliSearch Cloud 的付費方案, 讓其使用者可以不用架設自己的Server環境也能享有全文檢索的功能 至於為何檔案這麼小, 卻又很快速呢? 據官方文件說明, MeiliSearch在第一次啟動的時候就會自動建立Database, 其檔案在根目錄的data.ms的檔案夾內, 而這類Database引擎則是 Lightning Memory-Mapped Database(LMDB), 官方認為LMDB是性能、穩定性和特性的最佳組合 可以在建立時使用Cli指令去更改DB的存放路徑 -db-path, 或使用Docker建立 LMDB是用C語言撰寫的事物型鍵值儲存，是為OpenLDAP開發的，具有ACID屬性 ","date":"2023-03-08","objectID":"https://loulazynote.github.io/posts/meilisearchbasicusage/:1:2","tags":["MeiliSearch","MeiliSearch 1.0.0",".Net Core 6","C#","ASP.NET Core","Tools"],"title":"MeiliSearch基本用法","uri":"https://loulazynote.github.io/posts/meilisearchbasicusage/"},{"categories":["C#","ASP.NET Core","Tools"],"content":"有那些功能? Typo tolerance 錯字容錯率 Custom ranking 自定義搜尋時關聯性及先後順序 Stop words 停用字 Highlighting 搜尋結果中凸顯的搜索關鍵字 Synonyms 同義詞 Filtering 篩選器 Sorting 將搜尋結果排序 Search preview 簡單的預覽頁面 還有更細部的功能, 之後我只會講到我用過的功能 ","date":"2023-03-08","objectID":"https://loulazynote.github.io/posts/meilisearchbasicusage/:1:3","tags":["MeiliSearch","MeiliSearch 1.0.0",".Net Core 6","C#","ASP.NET Core","Tools"],"title":"MeiliSearch基本用法","uri":"https://loulazynote.github.io/posts/meilisearchbasicusage/"},{"categories":["C#","ASP.NET Core","Tools"],"content":"基本使用方式 安裝方式(以Windows為例) 透過cURL安裝 # Install Meilisearch curl -L \u003chttps://install.meilisearch.com\u003e | sh # Launch Meilisearch ./meilisearch 使用 Docker 安裝(我個人是比較推薦這種方式,因為比較方便) # Fetch the latest version of Meilisearch image from DockerHub docker pull getmeili/meilisearch:v1.0 # Launch Meilisearch in development mode with a master key docker run -it --rm \\ -p 7700:7700 \\ -e MEILI_ENV='development' \\ -v $(pwd)/meili_data:/meili_data \\ getmeili/meilisearch:v1.0 將Source Code Clone下來自行編譯(可能需要額外安裝 Rust , cargo 等語言或套件) git clone https://github.com/meilisearch/meilisearch cd meilisearch git checkout latest # Update the rust toolchain to the latest version rustup update # Compile the project cargo build --release # Execute the server binary ./target/release/meilisearch 下載官方已打包好的執行檔 選擇好想要放的路徑及位置即可 建議要建立的硬體設備或是虛擬環境 至少要 2 cores/Ram 16G 以上 會較順暢 因為如果沒有額外設定的話, 預設Ram的使用率是該設備的2/3可用的RAM 及 1/2 可用的線程 曾經我就是用了Azure VM 最低配置去跑, 結果每1.2天就要重開執行檔, 3~5天要重開機一次 也支援各種雲端服務 AWS Azure DigitalOcean GCP Koyeb Qovery Railway 注意!! 如果曾經用過此套件 版本為 0.X.XX 版的, 這裡 1.0.0 版本沒辦法直接用喔, 因為他們有說大版更會 Breaking changes, 而下一次則是在2.0.0版本的時候 解決方法則是匯出所有Database內的資料再匯入新版本的 使用方法(以執行檔為例) 到放執行檔的File內後直接執行 cd D:/MeiliSearchDemo .\\meilisearch-windows-amd64.exe 首次執行會自動產生Database相關檔案 而1.0.0版本開始 如果沒有加 Master Key 它則會提醒, 並提供一組雜湊值 建議都使用 Master Key 來保護自行設定的MeiliSearch cd D:/MeiliSearchDemo # `--master-key`是設定密鑰的CLI .\\meilisearch-windows-amd64.exe --master-key=\"MASTER_KEY\" 執行完成後, MeiliSearch就開始Run起來了,預設的Port都是7700,且MeiliSearch有提供簡易預覽可以到localhost:7700查看 想要更改port及Http位址的話, 需要使用到 --http-addr 的CLI .\\meilisearch-windows-amd64.exe --master-key=\"MASTER_KEY\" --http-addr=\"127.0.0.1:2023\" 增加索引內容 在需要使用的專案上, 開啟nuget搜尋Meilisearch或打開Terminal鍵入 dotnet add package Meilisearch 先建立想要索引的欄位Model(這些欄位是可以自定義的) public class Movie { // 如果有設定Id這個欄位,則MeiliSearch會自動判斷為PKey,有多個的話則不會,可以自行指定要那個欄位為PKey public int Id { get; set; } public string Title { get; set; } public string Poster { get; set; } public string Overview { get; set; } public IEnumerable\u003cstring\u003e Genres { get; set; } } 增加索引的方法 public async Task CreateDocumentAsync() { var options = new JsonSerializerOptions { PropertyNameCaseInsensitive = true }; string jsonString = await File.ReadAllTextAsync(\"Models/Database/movies.json\"); var movies = JsonSerializer.Deserialize\u003cIEnumerable\u003cMovie\u003e\u003e(jsonString, options); // 如果index沒有建立過,在此會自動建立起來,如果已有此index,則會讀取相關內容 var index = client.Index(\"movies\"); // 此方法即是增加Document,也就是增加要被索引的內容 await index.AddDocumentsAsync(movies); } 如何搜索 public async Task QueryAsync(string? keyword) { // 獲取要搜尋的Index索引 var index = client.Index(\"movies\"); // 使用SearchAsync方法來搜尋鍵入的關鍵字 var movies = await index.SearchAsync\u003cMovie\u003e(keyword); // 搜尋與索引內容相關的都在Hits內, 而上一層有其他欄位(EX: query =\u003e 輸入的關鍵字, limit =\u003e 最多獲取的筆數, offset =\u003e 跳過的筆數) foreach (var movie in movies.Hits) { Console.WriteLine(movie.Title); } } 完整範例 public class Program { public MeilisearchClient client = new MeilisearchClient(\"http://127.0.0.1:7700\", \"jdWLTzfPHZK46YB8aQOXEPPD8RrPkU0E2505ixbMco8\"); public static void Main(string[] args) { var p = new Program(); Console.WriteLine(\"Wait for create Document...\"); p.CreateDocumentAsync().Wait(); Console.WriteLine(\"Input Your Search Keyword:\"); var keyword = Console.ReadLine(); Console.WriteLine(\"=================================\"); p.QueryAsync(keyword).Wait(); Console.ReadKey(); } public async Task CreateDocumentAsync() { var options = new JsonSerializerOptions { PropertyNameCaseInsensitive = true }; string jsonString = await File.ReadAllTextAsync(\"Models/Database/movies.json\"); var movies = JsonSerializer.Deserialize\u003cIEnumerable\u003cMovie\u003e\u003e(jsonString, options); // 如果index沒有建立過,在此會自動建立起來,如果已有此index,則會讀取相關內容 var index = client.Index(\"movies\"); // 此方法即是增加Document,也就是增加要被索引的內容 await index.AddDocumentsAsync(movies); // 取得當前新增後的Task,裡面會有當前狀態 var task = await client.GetTaskAsync(0); Console.WriteLine(\"Create Result:\" + task.Status); } public async Task QueryAsync(string? keyword) { // 獲取要搜尋的Index索引 var index = client.Index(\"movies\"); // 使用SearchAsync方法來搜尋鍵入的關鍵字 var movies = awai","date":"2023-03-08","objectID":"https://loulazynote.github.io/posts/meilisearchbasicusage/:1:4","tags":["MeiliSearch","MeiliSearch 1.0.0",".Net Core 6","C#","ASP.NET Core","Tools"],"title":"MeiliSearch基本用法","uri":"https://loulazynote.github.io/posts/meilisearchbasicusage/"},{"categories":["C#","ASP.NET Core","Tools"],"content":"參考資料 Meilisearch Documentation v1.0 Meilisearch Github ","date":"2023-03-08","objectID":"https://loulazynote.github.io/posts/meilisearchbasicusage/:2:0","tags":["MeiliSearch","MeiliSearch 1.0.0",".Net Core 6","C#","ASP.NET Core","Tools"],"title":"MeiliSearch基本用法","uri":"https://loulazynote.github.io/posts/meilisearchbasicusage/"},{"categories":["Teams","TeamsApp"],"content":"在B站看到 2021年9月 在對岸 微軟 Reactor 關於 Teams App 的活動， 也剛剛好~公司也有小小的需求希望能在 Teams 上做一些操作， 所以就順便動手研究了。 爬了很多文看了很多Doc， 發現大部分都是用 React 寫的， 關於 Angular 的部分可以說是幾乎沒有（不知道是太少人用還是太Easy🤣）。 所以這篇就記錄一下研究的過程！ ","date":"2022-07-25","objectID":"https://loulazynote.github.io/posts/teamsappwithangular/:0:0","tags":["Teams","TeamsApp","TeamsToolKit","Angular","TeamsAppTab"],"title":"使用Angular及Teams ToolKit建立Teams App","uri":"https://loulazynote.github.io/posts/teamsappwithangular/"},{"categories":["Teams","TeamsApp"],"content":"準備 Microsoft 365 組織 Prepare your Microsoft 365 tenant - Teams | Microsoft Docs 申請免費的 Microsoft 365 Developer Program ","date":"2022-07-25","objectID":"https://loulazynote.github.io/posts/teamsappwithangular/:1:0","tags":["Teams","TeamsApp","TeamsToolKit","Angular","TeamsAppTab"],"title":"使用Angular及Teams ToolKit建立Teams App","uri":"https://loulazynote.github.io/posts/teamsappwithangular/"},{"categories":["Teams","TeamsApp"],"content":"必要開發工具 Visual Studio Code choco install vscode -y Teams Toolkit extension code --install-extension TeamsDevApp.ms-teams-vscode-extension Node.js LTS 有裝 NVM 的直接下此 Command 就好 nvm install lts 沒有的話就用 Chocolatey 或到Node.js 官網下載了 choco install nodejs-lts -y TeamsFx CLI npm install -g @microsoft/teamsfx-cli Angular Cli npm install -g @angular/cli ","date":"2022-07-25","objectID":"https://loulazynote.github.io/posts/teamsappwithangular/:2:0","tags":["Teams","TeamsApp","TeamsToolKit","Angular","TeamsAppTab"],"title":"使用Angular及Teams ToolKit建立Teams App","uri":"https://loulazynote.github.io/posts/teamsappwithangular/"},{"categories":["Teams","TeamsApp"],"content":"建立步驟 建立一個新資料夾 cd D:\\ mkdir Demo 在此資料夾內以範本建立專案 teamsfx new template hello-world-tab-without-sso --folder \"./Demo\" cd ./Demo/hello-world-tab-without-sso code . 將 tabs 資料夾內全部檔案刪除, 並新增 Angular 專案 ng new tabs cd ./tabs 加入Teams App 在 Compiler 時必要套件 npm install @microsoft/teams-js npm install @types/node env-cmd cross-env --save-dev #後兩套件是對於開發環境變數做操做的, 如不需要可以不用裝(根據TeamsToolKit預設是有安裝的) 開啟 tabs內的Package.json 加入以下命令 \"dev:teamsfx\": \"env-cmd --silent -f .env.teamsfx.local npm run start\", \"install:teamsfx\": \"npm install\", \"build:teamsfx\": \"cross-env-shell \\\"env-cmd -f .env.teamsfx.${TEAMS_FX_ENV} npm run build\\\"\", \"build:teamsfx:dev\": \"cross-env TEAMS_FX_ENV=dev npm run build:teamsfx\" 點選 Teams ToolKit, 並點選 編輯 manifest 編輯 manifest , 修改以下欄位 安裝時所顯示的畫面 建立 Teams Config Component ng new TeamsConfig import teams-js 並寫入設定(❗不加此設定,會無法顯示❗) import { Component, OnInit } from '@angular/core'; import * as microsoftTeams from '@microsoft/teams-js';//引入 teams-js @Component({ selector: 'app-teams-config', templateUrl: './teams-config.component.html', styleUrls: ['./teams-config.component.scss'] }) export class TeamsConfigComponent implements OnInit { constructor() { } ngOnInit(): void { // Initialize the Microsoft Teams SDK microsoftTeams.initialize(); microsoftTeams.settings.registerOnSaveHandler((saveEvent) =\u003e { const baseUrl = window.location.protocol + '//' + window.location.host + '/'; microsoftTeams.settings.setSettings({ suggestedDisplayName: 'Tab Test', entityId: 'index', // 與 manifast內的staticTabs底下entityId需相同 contentUrl: baseUrl, websiteUrl: baseUrl, }); saveEvent.notifySuccess(); }); microsoftTeams.settings.setValidityState(true); } } 編輯 teams-config.component.html 建立 Tab Component 並撰寫內容 ng new tab 修改 app-routing.module.ts及app.module.ts //app-routing.module.ts import { NgModule } from '@angular/core'; import { RouterModule, Routes } from '@angular/router'; import { TabComponent } from './components/tab/tab.component'; import { TeamsConfigComponent } from './components/teams-config/teams-config.component'; const routes: Routes = [ { path: '', pathMatch: 'full', redirectTo: '/tab' }, { path: 'tab', component: TabComponent }, { path: 'config', component: TeamsConfigComponent }, { path: '**', pathMatch: 'full', redirectTo: '/tab' }, // catch any unfound routes and redirect to home page ]; @NgModule({ imports: [RouterModule.forRoot(routes)], exports: [RouterModule], }) export class AppRoutingModule {} //app.module.ts import { NgModule } from '@angular/core'; import { BrowserModule } from '@angular/platform-browser'; import { AppRoutingModule } from './app-routing.module'; import { AppComponent } from './app.component'; import { TabComponent } from './components/tab/tab.component'; import { TeamsConfigComponent } from './components/teams-config/teams-config.component'; @NgModule({ declarations: [AppComponent, TabComponent, TeamsConfigComponent], imports: [BrowserModule, AppRoutingModule], providers: [], bootstrap: [AppComponent], }) export class AppModule {} 修改完別忘了將 app.component.html也加上 \u003crouter-outlet\u003e\u003c/router-outlet\u003e 建立 開發測試用途的自簽憑證 (Self-Signed Certificate), 並放入tabs資料夾的根目錄 修改 package.json的 scripts,將 ng serve修改為下列命令列 ng serve --ssl --ssl-key server.key --ssl-cert server.crt 因Teams App要Tab顯示內容,包含的網頁必須是有 SSL ,所以要為Angular加入憑證 F5執行 執行時會看到 OUTPUT跑出下圖內容 compiler成功後就會自動開啟網頁版Teams 因選擇Add to a teams(加入到團隊頻道), 故此處要選擇團隊頻道 此處顯示的是 teams-config.component.html的內容 點選 about 裡面顯示的是 manifast 上 的內容 加入安裝完後, 顯示的是 tab.component.html的內容 ","date":"2022-07-25","objectID":"https://loulazynote.github.io/posts/teamsappwithangular/:3:0","tags":["Teams","TeamsApp","TeamsToolKit","Angular","TeamsAppTab"],"title":"使用Angular及Teams ToolKit建立Teams App","uri":"https://loulazynote.github.io/posts/teamsappwithangular/"},{"categories":["Teams","TeamsApp"],"content":"可能出現的錯誤 如果有跳出有關 env 的錯誤訊息的話, 較有可能的就是 需要 env-cmd或 cross-env這類套件(通常沒用到是不會有錯拉) 還有就是要從 Teams Toolkit內設定 ","date":"2022-07-25","objectID":"https://loulazynote.github.io/posts/teamsappwithangular/:3:1","tags":["Teams","TeamsApp","TeamsToolKit","Angular","TeamsAppTab"],"title":"使用Angular及Teams ToolKit建立Teams App","uri":"https://loulazynote.github.io/posts/teamsappwithangular/"},{"categories":["Teams","TeamsApp"],"content":"參考資料 The Will Will Web - 使用 Teams Toolkit 開發 Teams 應用程式：起手式 线下活动 | 从零开始开发一款属于你的Microsoft Teams小程序 Github - OfficeDev/TeamsFx Github - microsoft/DevAppsForTeams MSDN - Teams Toolkit for Visual Studio Code MSDN - Build apps with the Teams Toolkit and Visual Studio Code Microsoft Teams Blog - Build apps faster with the latest Microsoft Teams Toolkit PnP Samples ","date":"2022-07-25","objectID":"https://loulazynote.github.io/posts/teamsappwithangular/:4:0","tags":["Teams","TeamsApp","TeamsToolKit","Angular","TeamsAppTab"],"title":"使用Angular及Teams ToolKit建立Teams App","uri":"https://loulazynote.github.io/posts/teamsappwithangular/"},{"categories":["Learning","Microsoft Power Platform"],"content":"什麼是Dataverse? Dataverse是一個用於共享、儲存、引用、探索和分析研究資料的數據管理系統，同時也代表著透過該數據管理系統而建立的資料庫。 Dataverse的數據管理系統中定義了三個重要的層次：Dataverse、資料集(dataset) 和文件(file) 資料集是由一個或多個文件及詮釋資料(metadata)所組成的集合 而文件是組成資料集的最小單位，它可以是資料使用說明、資料檔、問卷或純文字檔等任何形式的檔案 Microsoft Dataverse 的資料會存放在一組資料表中, 資料表中的每個資料列都是用來儲存特定類型的資料，例如姓名、年齡和薪水等 Microsoft Dataverse 包含一組適用於一般案例的基本標準資料表，但也可以建立組織專屬的自訂資料表，然後使用 Power Query 將資料填入其中 應用程式製作者可以接著使用 Power Apps 來建置使用這項資料的豐富應用程式 Microsoft Dataverse 中的標準及自訂資料表可提供安全的雲端型儲存空間選項, 資料表允許您建立著重於業務的組織資料定義，以供應用程式內使用 Microsoft Dataverse 不需要編寫或只需編寫很少的程式碼，因此從知識工作者到專業開發人員，每個人都可以輕鬆使用它 ","date":"2022-07-07","objectID":"https://loulazynote.github.io/posts/microsoft_dataverse_intro/:1:0","tags":["Microsoft Power Platform","Microsoft Dataverse","Dataverse"],"title":"Microsoft Dataverse概觀","uri":"https://loulazynote.github.io/posts/microsoft_dataverse_intro/"},{"categories":["Learning","Microsoft Power Platform"],"content":"使用Microsoft Dataverse的好處 便於管理 : 不論是中繼資料(metadata) 或 一般data都存在雲端, 所以不用擔心如何儲存資料 輕鬆資料保護 : 資料以安全的方式儲存, User只有在你授予他們使用權限時才能看到, 可以使用角色權限管理控制組織/公司/團隊 內不同User對資料的存取 存取你的 Dynamics 365 資料 : Dynamics 365 應用程式的資料也存在 Dataverse 中, 可以快速組建使用Dynamics 365 資料的應用程式, 並使用 Power Apps 拓展應用程式 豐富的中繼資料(metadata) : 資料類型及資料關聯皆直接在Power Apps中使用 邏輯和驗證 : 定義 計算結果欄位、商業規則、工作流程、業務流程以確保資料品質及推動商務程序進展 生產力工具 : 資料表可在 Microsoft Excel 增益集中用來提高生產力並確保資料可及性 ","date":"2022-07-07","objectID":"https://loulazynote.github.io/posts/microsoft_dataverse_intro/:1:1","tags":["Microsoft Power Platform","Microsoft Dataverse","Dataverse"],"title":"Microsoft Dataverse概觀","uri":"https://loulazynote.github.io/posts/microsoft_dataverse_intro/"},{"categories":["Learning","Microsoft Power Platform"],"content":"Dynamics 365 和 Dataverse Dynamics 365 的應用程式： Dynamics 365 Sales Dynamics 365 Customer Service Dynamics 365 Talent 以上皆使用 Dataverse 來儲存和保護所使用的資料，這讓其組建應用程式時，可用 Power Apps 及 Dataverse 來直接連結 Dynamics 365 中已使用的核心商務資料，而不需要進行整合 根據 Dynamics 365 資料建置應用程式 : Power Apps 中或使用可擴充的平台針對您的業務資料快速建置應用程式，該平台可讓專業開發人員以程式設計方式資料和中繼資料進行互動，套用商務規則，建立自訂連接器，並與外部資料整合 管理可重複使用的商務規則與邏輯 : Dataverse 資料表中定義的商務規則與邏輯會套用至使用 Power Apps 建立的應用程式，以確保資料一致性，不論使用者如何存取資料，或透過哪些應用程式存取 Dynamics 365 和 Power Apps 中可重複使用技能 : 在 Power Apps 或 Dynamics 365 的熟練使用者現在可以在 Dataverse 平台上利用這些技能, 而現在，建立表格、表單和圖表是跨應用程式執行的一般工作 ","date":"2022-07-07","objectID":"https://loulazynote.github.io/posts/microsoft_dataverse_intro/:1:2","tags":["Microsoft Power Platform","Microsoft Dataverse","Dataverse"],"title":"Microsoft Dataverse概觀","uri":"https://loulazynote.github.io/posts/microsoft_dataverse_intro/"},{"categories":["Learning","Microsoft Power Platform"],"content":"邏輯和驗證 Dataverse 中的資料表可使用豐富的伺服器端邏輯和驗證，以確保資料品質，並讓建立及使用資料表內資料的每個應用程式，能減少重複程式碼 商務規則：對多個資料行和資料表驗證資料，並對所有應用程式建立的資料，提供警告和錯誤訊息 商務程序流程 : 引導使用者，以確保他們以一致的方式輸入資料，並且每次都遵循相同的步驟 目前只有模型導向應用程式支援商務程序流程 工作流程 : 可使其自動化商務程序，不需要使用者互動 使用程式碼的商務規則 : 支援進階開發人員案例，以直接透過程式碼擴充應用程式 ","date":"2022-07-07","objectID":"https://loulazynote.github.io/posts/microsoft_dataverse_intro/:1:3","tags":["Microsoft Power Platform","Microsoft Dataverse","Dataverse"],"title":"Microsoft Dataverse概觀","uri":"https://loulazynote.github.io/posts/microsoft_dataverse_intro/"},{"categories":["Learning","Microsoft Power Platform"],"content":"參考資料 MSDN - Power Apps SRDA’s blog - 10分鐘帶你認識Dataverse與 R「dataverse」套件 ","date":"2022-07-07","objectID":"https://loulazynote.github.io/posts/microsoft_dataverse_intro/:2:0","tags":["Microsoft Power Platform","Microsoft Dataverse","Dataverse"],"title":"Microsoft Dataverse概觀","uri":"https://loulazynote.github.io/posts/microsoft_dataverse_intro/"},{"categories":["Learning","Microsoft Power Platform"],"content":"Microsoft Power Platform是什麼? Power Platform是微軟的一個 SaaS 的雲端服務, 看字面感覺很陌生對吧? 其實就是由四種產品整合成的平台, 這四種產品分別為: Microsoft Power BI、Microsoft Power Automate、Microsoft Power Virtual Agents 和 Microsoft PowerApps, 而 Power Platform 是一個完全獨立的服務平台, 且還能結合 Office 365、 Dynamics 365 及 Azure等服務, 不僅如此還能整合第三方服務廠商及應用 , 使其企業的商務應用整合可以更容易、方便、快速, 並且 微軟 主打可協作且可擴充的低程式碼/無程式碼的工具平台。 ","date":"2022-07-06","objectID":"https://loulazynote.github.io/posts/microsoftpowerplatforminfo/:1:0","tags":["Microsoft Power Platform","Microsoft Power BI","Microsoft Flow","Microsoft PowerApps","Microsoft Power Automate","Microsoft Power Virtual Agents"],"title":"認識微軟生產力平台 - Microsoft Power Platform","uri":"https://loulazynote.github.io/posts/microsoftpowerplatforminfo/"},{"categories":["Learning","Microsoft Power Platform"],"content":"Power BI 這一套服務應該比較多人聽說過, 這是一個基於資料分析的應用, Power BI 提供了 Dashboard 的視覺化資料分析服務, 且可以使用在所有裝置上, 讓使用者可以很直覺的使用並洞察先機。 此服務可以讓使用者快速連接資料, 而資料可以是內部資料庫或Azure的資料存儲服務, 並以視覺化呈現。 ","date":"2022-07-06","objectID":"https://loulazynote.github.io/posts/microsoftpowerplatforminfo/:1:1","tags":["Microsoft Power Platform","Microsoft Power BI","Microsoft Flow","Microsoft PowerApps","Microsoft Power Automate","Microsoft Power Virtual Agents"],"title":"認識微軟生產力平台 - Microsoft Power Platform","uri":"https://loulazynote.github.io/posts/microsoftpowerplatforminfo/"},{"categories":["Learning","Microsoft Power Platform"],"content":"Power Automate(原Microsoft Flow) 提供自動化流程及工作的設計, 在應用程式及服務之間建立自動化工作流程的工具,例如: 自動回應留言、自動發送Email等等。 而此項服務主要是想要讓非開發人員也可以很快運用該工具, 微軟也提供了許多範本方便於建立 Power Automate也分幾種類型: 觸發事件(Trigger)進而觸動了自動化流程 立即流程: 可由 User 在Power Automate Mobile/Power Automate Web上觸發 計劃流程: 每天/每小時或每分鐘觸發一次；在您指定的日期；或指定的天數、小時數或分鐘數之後觸發 業務流程: 類似於引導，但對於某些業務工作流程，則需要去遵循, 例如: 註冊流程 UI流程: 可以在Windows 及 Web 應用程式中自動化執行重複的工作 ","date":"2022-07-06","objectID":"https://loulazynote.github.io/posts/microsoftpowerplatforminfo/:1:2","tags":["Microsoft Power Platform","Microsoft Power BI","Microsoft Flow","Microsoft PowerApps","Microsoft Power Automate","Microsoft Power Virtual Agents"],"title":"認識微軟生產力平台 - Microsoft Power Platform","uri":"https://loulazynote.github.io/posts/microsoftpowerplatforminfo/"},{"categories":["Learning","Microsoft Power Platform"],"content":"Power Virtual Agents 使用低程式碼及專業AI程式碼機器人開發,並整合到一個統一製作的畫布中,使每個人都能輕鬆建立交談機器人 也就是說一般User使用 Power Virtual Agents 無需撰寫程式碼，只要透過畫布，新增需要的步驟就可以快速建置機器人 (此示意圖取自2021iThome鐵人賽 - 善用 Microsoft 365 提升你的生產力！) Power Virtual Agents 可以是獨立 web 應用程式，也可以是 Microsoft Teams 中的單獨應用程式 ","date":"2022-07-06","objectID":"https://loulazynote.github.io/posts/microsoftpowerplatforminfo/:1:3","tags":["Microsoft Power Platform","Microsoft Power BI","Microsoft Flow","Microsoft PowerApps","Microsoft Power Automate","Microsoft Power Virtual Agents"],"title":"認識微軟生產力平台 - Microsoft Power Platform","uri":"https://loulazynote.github.io/posts/microsoftpowerplatforminfo/"},{"categories":["Learning","Microsoft Power Platform"],"content":"PowerApps 是一套應用程式、服務、連接器和資料平台，能夠提供快速的應用程式開發環境，以依照User 的業務需求來建置自訂應用程式 其優點為: User可使用最少量程式碼(或不使用), 以建置一個提供豐富商務邏輯和工作流程且自訂的應用程式 提供豐富的商務邏輯及工作流程功能, 將手動商務作業轉換為自動化的數位程序 響應式設計可讓User在各種裝置上使用 ","date":"2022-07-06","objectID":"https://loulazynote.github.io/posts/microsoftpowerplatforminfo/:1:4","tags":["Microsoft Power Platform","Microsoft Power BI","Microsoft Flow","Microsoft PowerApps","Microsoft Power Automate","Microsoft Power Virtual Agents"],"title":"認識微軟生產力平台 - Microsoft Power Platform","uri":"https://loulazynote.github.io/posts/microsoftpowerplatforminfo/"},{"categories":["Learning","Microsoft Power Platform"],"content":"Bonus : Power Pages 是一個低程式碼、具有擴展性且安全的解決方案, 可以用於快速建立商務網站 此工具有提供大量的範本以協助建立, 並且還有提供教學課程和影片可以協助, 當然也能自行定義所有頁面 如是專業技術人員也能使用專業的工具建立, 例如: Visual Studio Code、Azure DevOps、 Github 可以透過 Azure 提供角色以權限存取管理以及安全性來保護網站 ","date":"2022-07-06","objectID":"https://loulazynote.github.io/posts/microsoftpowerplatforminfo/:1:5","tags":["Microsoft Power Platform","Microsoft Power BI","Microsoft Flow","Microsoft PowerApps","Microsoft Power Automate","Microsoft Power Virtual Agents"],"title":"認識微軟生產力平台 - Microsoft Power Platform","uri":"https://loulazynote.github.io/posts/microsoftpowerplatforminfo/"},{"categories":["Learning","Microsoft Power Platform"],"content":"參考資料 2021iThome鐵人賽 - 善用 Microsoft 365 提升你的生產力！ 雅閣科技 - 認識 Microsoft Power Automate (原本的 Microsoft Flow) Edward Kuo - 微軟新一代的生產力平台Microsoft Power Platform 11屆iThome鐵人賽 - 打造 Microsoft BI 資料服務平台 Microsoft Power Platform MSDN - Power Apps ","date":"2022-07-06","objectID":"https://loulazynote.github.io/posts/microsoftpowerplatforminfo/:2:0","tags":["Microsoft Power Platform","Microsoft Power BI","Microsoft Flow","Microsoft PowerApps","Microsoft Power Automate","Microsoft Power Virtual Agents"],"title":"認識微軟生產力平台 - Microsoft Power Platform","uri":"https://loulazynote.github.io/posts/microsoftpowerplatforminfo/"},{"categories":["C#","ASP.NET Core"],"content":"Installation 用 NuGet 搜尋 Serilog.AspNetCore安裝套件 在 Program.cs 加入設定 Log.Logger = new LoggerConfiguration() .MinimumLevel.Override(\"Microsoft\", LogEventLevel.Warning) .MinimumLevel.Override(\"System\", LogEventLevel.Warning)//使用MinimumLevel 來設定 LogLevel 層級,如果來源為 Microsoft 及 系統的訊息 則LogLevel 層級為 警告 .WriteTo.Console(new RenderedCompactJsonFormatter()) .WriteTo.File(new CompactJsonFormatter().ToString())//Output templates, 輸出至Console及檔案 .Enrich.FromLogContext() .CreateLogger(); CompactJsonFormatter 將保留消息模板、屬性和格式信息，以便稍後可以創建呈現的消息。當 JSON 旨在在沒有消息模板呈現的環境中使用時，可以改用 RenderedCompactJsonFormatter。 loggerConfiguration.ReadFrom.Configuration(hostingContext.Configuration) : 讀取現在的Configuration appsetting.json 加入設定 Microsoft.Hosting.Lifetime : 應用程式生命週期事件的通知 Microsoft.EntityFrameworkCore.Database.Command : 紀錄 EF Core 自動產生的 SQL 命令 Startup.cs 設定 app.UseSerilogRequestLogging(options =\u003e { // Customize the message template options.MessageTemplate = \"Handled {RequestPath}\"; // Emit debug-level events instead of the defaults options.GetLevel = (httpContext, elapsed, ex) =\u003e LogEventLevel.Debug; // Attach additional properties to the request completion event options.EnrichDiagnosticContext = (diagnosticContext, httpContext) =\u003e { diagnosticContext.Set(\"RequestHost\", httpContext.Request.Host.Value); diagnosticContext.Set(\"RequestScheme\", httpContext.Request.Scheme); }; }); ","date":"2022-06-28","objectID":"https://loulazynote.github.io/posts/serilogusage/:1:0","tags":["C#","ASP.NET Core","Tools","SeriLog"],"title":"SeriLog 設定之眉角","uri":"https://loulazynote.github.io/posts/serilogusage/"},{"categories":["C#","ASP.NET Core"],"content":"Usage 在需要的地方加入 log 先 using Microsoft.Extensions.Logging 加入建構式 在需要 log 的部分加入 log 記錄 可以自訂訊息等級 因在Program.cs及appsetting.json有加入設定,其餘 System 的操作及 Database 的讀取皆會被 log 下來 ","date":"2022-06-28","objectID":"https://loulazynote.github.io/posts/serilogusage/:2:0","tags":["C#","ASP.NET Core","Tools","SeriLog"],"title":"SeriLog 設定之眉角","uri":"https://loulazynote.github.io/posts/serilogusage/"},{"categories":["C#","ASP.NET Core"],"content":"參考資料 Github - serilog-aspnetcore Github - Serilog.Formatting.Compact Microsoft - .NET Core 與 ASP.NET Core 中的記錄 WilL Blog - ASP.NET Core 如何紀錄 Entity Framework Core 5.0 自動產生的 SQL 命令 m@rcus 學習筆記 - [NETCore] 結構化日誌 Serilog - 配置設定 C# Corner - How To Implement Logging Using Serilog In ASP.NET Core 5.0 Application With Database ","date":"2022-06-28","objectID":"https://loulazynote.github.io/posts/serilogusage/:3:0","tags":["C#","ASP.NET Core","Tools","SeriLog"],"title":"SeriLog 設定之眉角","uri":"https://loulazynote.github.io/posts/serilogusage/"},{"categories":["C#","ASP.NET Core","Tools"],"content":"基本用法 一般對應 var mapper = Mapper.Map\u003cTargetType\u003e(customer); var mapper = Mapper.Map\u003cFromType, TargetType\u003e(customer); 客製化對應 Mapper.AddMap\u003cFromType, TargetType\u003e(src =\u003e { var res = new TargetType(); res.InjectFrom(src); // 對應相同名字及型別的屬性 res.FullName = src.FirstName + \" \" + src.LastName; return res; }); InjectFrom 的用法 InjectFrom\u003cTInjection\u003e(source)用於使用約定映射，當未指定 TInjection 時，它將對應具有完全相同名稱和類型的屬性 target.InjectFrom(source); target.InjectFrom\u003cInjection\u003e(source); target.InjectFrom(new Injection(parameters), source); target.InjectFrom\u003cInjection\u003e(); ","date":"2022-06-22","objectID":"https://loulazynote.github.io/posts/valueinjecter_meta/:1:0","tags":["C#","ValueInjecter","ASP.NET Core","Tools"],"title":"ValueInjecter@3.2.0 簡單用法","uri":"https://loulazynote.github.io/posts/valueinjecter_meta/"},{"categories":["C#","ASP.NET Core","Tools"],"content":"專案上使用遇到的問題 當 List 需要轉換對應時 問題: public async Task\u003cList\u003cEmplyeeListDto\u003e\u003e GetAllEmployeeAsync(CancellationToken token) { var query = await _context.Emplyees.OrderByDescending(e =\u003e e.Jointime).ToListAsync(token); var data = Mapper.map\u003cList\u003cEmplyeeListDto\u003e\u003e(query);//此方式是無法對應任何屬性的 return data; } 解法: public async Task\u003cList\u003cEmplyeeListDto\u003e\u003e GetAllEmployeeAsync(CancellationToken token) { var query = await _context.Employees.OrderByDescending(e =\u003e e.Jointime).ToListAsync(token); var data = query.Select(q =\u003e new EmplyeeListDto().InjectFrom(q)).Cast\u003cEmplyeeListDto\u003e().ToList();//改用此方式即可,需使用Cast\u003cT\u003e才會是正確的屬性 return data; } 如沒使用Cast\u003cT\u003e則會變成 Object 屬性: ","date":"2022-06-22","objectID":"https://loulazynote.github.io/posts/valueinjecter_meta/:2:0","tags":["C#","ValueInjecter","ASP.NET Core","Tools"],"title":"ValueInjecter@3.2.0 簡單用法","uri":"https://loulazynote.github.io/posts/valueinjecter_meta/"},{"categories":["C#","ASP.NET Core","Tools"],"content":"參考資料 GitHub - ValueInjecter StackOverFlow ","date":"2022-06-22","objectID":"https://loulazynote.github.io/posts/valueinjecter_meta/:3:0","tags":["C#","ValueInjecter","ASP.NET Core","Tools"],"title":"ValueInjecter@3.2.0 簡單用法","uri":"https://loulazynote.github.io/posts/valueinjecter_meta/"},{"categories":["SQL","Database"],"content":"關聯式資料庫(RDBMS) 目前常用的資料庫,完全遵守 ACID 原則,在任何情況下(Atomicity)都可保持每個Transaction不成功則roll back,(Consistency)資料一致性,(Isolation)讀寫不互相干擾,(Duration)資料永久性(EX:SQL Server,PostgreSQL,MySQL…等) 且僅能支援垂直擴充,假設要應用在大量的資料的時候,只能透過硬體的升級(CPU 升級、加 HDD、增加 RAM…等) ","date":"2022-06-18","objectID":"https://loulazynote.github.io/posts/nosql-knowledge/:1:0","tags":["SQL","NoSQL","RDBMS","MongoDB"],"title":"What is NoSQL","uri":"https://loulazynote.github.io/posts/nosql-knowledge/"},{"categories":["SQL","Database"],"content":"非關聯式資料庫(NOSQL) NOSQL(Non-SQL,又為 Not only SQL) 稱為非關聯式資料庫,跟關聯式資料庫不一樣,不需要定義 schema且沒有關聯的關係(EX:MongoDB,Redis,MariaDB…) 非關聯式資料庫特點： 資料庫由 collection 組成 collection 中每筆資料為一份 document,document 的資料格式不需一致 以 CAP theorem 為概念設計 常用於分散式雲端系統 ","date":"2022-06-18","objectID":"https://loulazynote.github.io/posts/nosql-knowledge/:2:0","tags":["SQL","NoSQL","RDBMS","MongoDB"],"title":"What is NoSQL","uri":"https://loulazynote.github.io/posts/nosql-knowledge/"},{"categories":["SQL","Database"],"content":"NoSQL v.s RDBMS ","date":"2022-06-18","objectID":"https://loulazynote.github.io/posts/nosql-knowledge/:3:0","tags":["SQL","NoSQL","RDBMS","MongoDB"],"title":"What is NoSQL","uri":"https://loulazynote.github.io/posts/nosql-knowledge/"},{"categories":["SQL","Database"],"content":"RDBMS RDBMS 因具備 ACID 特性,且保證了資料的一致性,若資料需在任何情況下都穩定且一致,則推薦此類(EX: 金融系統) ","date":"2022-06-18","objectID":"https://loulazynote.github.io/posts/nosql-knowledge/:3:1","tags":["SQL","NoSQL","RDBMS","MongoDB"],"title":"What is NoSQL","uri":"https://loulazynote.github.io/posts/nosql-knowledge/"},{"categories":["SQL","Database"],"content":"NOSQL 由於 NOSQL 的 schema 不需要固定,且資料可以為任意結構,所以在 schema 需要頻繁變動或者是 schema 不固定的時候,NOSQL 提供更有彈性的開發 需要儲存大量資料,利用分散式系統以及雲端儲存的時候,由於 NOSQL 相較於 RDBMS 更容易做水平擴充 (horizontal scaling),且本身的設計就是分散式系統的設計,因此對於未來有大量擴充需求的系統,會更容易的去擴充,且擴充的成本也較低 具備水平擴充,較不會有Single Failed ","date":"2022-06-18","objectID":"https://loulazynote.github.io/posts/nosql-knowledge/:3:2","tags":["SQL","NoSQL","RDBMS","MongoDB"],"title":"What is NoSQL","uri":"https://loulazynote.github.io/posts/nosql-knowledge/"},{"categories":["SQL","Database"],"content":"NOSQL 類別 ","date":"2022-06-18","objectID":"https://loulazynote.github.io/posts/nosql-knowledge/:4:0","tags":["SQL","NoSQL","RDBMS","MongoDB"],"title":"What is NoSQL","uri":"https://loulazynote.github.io/posts/nosql-knowledge/"},{"categories":["SQL","Database"],"content":"1. 資料形態(粗略分類) Key-Value: Key-Value資料庫是 NoSQL 資料庫中最大宗的類型,這類資料最大的特色就是採用Key-Value資料架構,取消了原本關聯式資料庫中常用的欄位架構（Schema）,每筆資料各自獨立,所以,可以打造出分散式和高擴充能力的特性 例如: Google BigTable,Hadoop HBase,Amazon Dynamo,Cassandra,Hypertable,Redis,Firebase… Document: 也是一種key-value,限制 value 的結構為半結構化資料semi-structure,像是 JSON 等 將資訊存儲在文檔中的資料庫,旨在將資料儲存為類似 JSON 的文件並對其進行查詢 文件資料庫主要是用來儲存非結構性的文件,例如最常見的非結構化資料就是HTML網頁,一個HTML網頁結構不像一般表格那樣有固定的欄位,每個欄位有特定資料類型和大小,例如網頁裡有Head和Body結構,Body元素中可能會有10個段落,段落中會有文字、連結、圖片等,文件資料庫的資料結構往往是鬆散的樹狀結構 例如:MongoDB,CouchDB,Lotus Notes… Wide-column(圖學架構): 運用圖學架構來儲存節點間關係資料架構(基本的圖學資料包括了節點（Node）、關係（Relation）和屬性（Property）三種結構) 以多個raw、column進行存取,將資料拆成小資料再進行組合,之後可透過column key / row key 進行關聯查詢(可有效的壓縮資料及取用同級的資料集) 例如:Neo4j,InfoGrid,AllegroGrph,Sparksee… ","date":"2022-06-18","objectID":"https://loulazynote.github.io/posts/nosql-knowledge/:4:1","tags":["SQL","NoSQL","RDBMS","MongoDB"],"title":"What is NoSQL","uri":"https://loulazynote.github.io/posts/nosql-knowledge/"},{"categories":["SQL","Database"],"content":"2. CAP定理 (Consistency, Availability, Partition Tolerance) Consistency: 一致性,讀寫都會遵循 Atomicity 原則,等同於所有節點訪問同一份最新的資料副本 Availability: 可用性,每次請求都能獲取到非錯的響應,但是無法保證得到的資料為最新的 Partition Tolerance: 分區容錯性,電腦網路區分為相對獨立的子網,這些子網可以通過設計單獨優化,也可以是網絡設備的故障而導致,而分散式軟體必須設計成具有分區容錯性,也就是說,即使網路被分區後,仍然可以正常工作 根據定理,分散式系統只能滿足三項中的兩項而不可能滿足全部三項,因為在Available的情況下,Consistency與Partition Tolerance是互相矛盾的,因此大致的分類有 AP、CA、CP AP: 只要節點可用就能持續運作 CA: 在沒有任何的例外下,都是可用並保證資料的一致性 CP: 在節點不穩定的時候不接受 request ","date":"2022-06-18","objectID":"https://loulazynote.github.io/posts/nosql-knowledge/:4:2","tags":["SQL","NoSQL","RDBMS","MongoDB"],"title":"What is NoSQL","uri":"https://loulazynote.github.io/posts/nosql-knowledge/"},{"categories":["SQL","Database"],"content":"參考資料 NoSQL | wikipedia.org 什麼是 NoSQL？| AWS 快速認識4類主流NoSQL資料庫 | iThome [淺談]-NoSQL資料庫怎麼選？ | ZiXiang-Blog RDBMS vs. NOSQL - 關聯式資料庫 vs. 非關聯式資料庫 | Hs-medium 結構、半結構、非結構式資料是啥意思？ | Kevin的MongoDB工作筆記 ","date":"2022-06-18","objectID":"https://loulazynote.github.io/posts/nosql-knowledge/:5:0","tags":["SQL","NoSQL","RDBMS","MongoDB"],"title":"What is NoSQL","uri":"https://loulazynote.github.io/posts/nosql-knowledge/"},{"categories":["C#","Learning"],"content":"物件導向四大原則 ","date":"2022-06-17","objectID":"https://loulazynote.github.io/posts/ooplearning/:1:0","tags":["OOP","C#"],"title":"OOP 物件導向學習筆記","uri":"https://loulazynote.github.io/posts/ooplearning/"},{"categories":["C#","Learning"],"content":"封裝(Encapsulation) 封裝（Encapsulation）在物件導向程式設計中是用來將資料與函式的實作內容包裝、隱藏起來的技巧，其中資料更常被稱為類別的成員屬性（Attributes）、函式更常被稱為類別的成員方法（Methods）。 「封裝」有時被稱為物件導向程式設計的第一大支柱或原則。 類別或結構可以指定其每個成員在類別或結構外部程式碼的可存取程度。 無法從類別或元件外部使用的方法和變數可以隱藏，以限制編碼錯誤或惡意探索的可能性。 舉個例子，如同部落格發文，公開貼文大家都看的到，設定私人或草稿除了自己其他人都看不到。 說白了，就是公開出來的才看的到（public）。而未公開的，就怎麼也找不到（private、protected）。 public 顧名思義, 任何人都可以存取 // 部落格基本功能都是必要的公開行為，文章抬頭、文章內容、發文 public class blog { public string Title { get; set; } public string Content { get; set; } public void Post { get; set; } } public class LouNote : blog { // 因繼承blog關係會有下列欄位（僅示意，在C#內繼承後不會實際顯示這些欄位，但可以使用） public string Title { get; set; } public string Content { get; set; } public void Post { get; set; } // 示意結束 // 為文章增加分類也是公開行為 public string[] Categories { get; set; } } private 只有 class 本身可以存取 public class LouNote : blog { // 因繼承blog關係會有下列欄位（僅示意，在C#內繼承後不會實際顯示這些欄位，但可以使用） public string Title { get; set; } public string Content { get; set; } public void Post { get; set; } // 示意結束 // 為文章增加分類也是公開行為 public string[] Categories { get; set; } // 因存入草稿是不公開的，僅有自己看的到 private object Draft { get; set; } } protected 自身Class及被繼承的 class 可以存取 public class 會員優惠 { // 給予5折優惠 protected int 折扣 = 50; protected string 禮品 = \"Iphone 14 Pro\"; } public class 消費者: 會員優惠 { static void Main(string[] args) { var 非本人 = new 會員優惠();// Error CS1540,因為 會員優惠 只能會員 本人使用 var 本人 = new 消費者(); // 因是會員本人,所以可以使用此折扣,且還能更改折扣為3折 本人.折扣 = 70; 本人.禮品 = \"Iphone 14 Pro Max\"; Console.WriteLine($\"此會員因消費滿額,故給予優惠 折扣 {本人.折扣}% 及贈品 {本人.禮品}!\"); } } // Output: 此會員因消費滿額,故給予優惠 折扣 70% 及贈品 Iphone 14 Pro Max! C# 額外其他3種存取方式 internal : 類別: 相同命名空間 (相同dll存取) 可存取 成員: 只有自身Class可存取 protected internal : 類別: 自身Class, 被繼承Class 皆可存取 成員: 自身Class, 相同命名空間, 被繼承Class 皆可存取 private protected : 類別: 自身Class, 被繼承Class 皆可存取 成員: 自身Class 可存取, 被繼承Class無法存取 ","date":"2022-06-17","objectID":"https://loulazynote.github.io/posts/ooplearning/:1:1","tags":["OOP","C#"],"title":"OOP 物件導向學習筆記","uri":"https://loulazynote.github.io/posts/ooplearning/"},{"categories":["C#","Learning"],"content":"繼承(Inheritance) 類別 (而不是結構) 支援繼承的概念。 衍生自另一個類別的類別，稱為 基類，會自動包含基類的所有公用、受保護和內部成員，但建構函式和完成項除外。 類別可宣告為抽象，這表示其一或多個方法沒有任何實作。 (雖然抽象類別無法直接具現化，但是它們可以做為其他能提供遺失實作之類別的基底類別。) 類別也可以宣告為密封(sealed)，以防止其他類別繼承它們。(類別可以藉由將本身或成員宣告為 sealed ，以防止其他類別繼承自它或其任何成員) 關係是一層一層繼承下來的, 舉例來說,手機可以通話、傳訊息，所以各品牌都是繼承 手機 的功能 並延伸自己的特色及功能，比如說 早期 3310 有基本手機功能且黑白畫面， 而目前 Iphone 有彩色畫面且還能上網 public class Program { static void Main(string[] args) { var Phone_3310 = new Phone(); Console.WriteLine(\"手機型號: 3310, 其功能如下\"); Phone_3310.Text(); Phone_3310.Call(); Console.ReadKey(); } // Output: 手機型號: 3310, 其功能如下 // 傳簡訊 // 打電話 public class Phone { public void Text(){ Console.WriteLine(\"傳簡訊\"); } public void Call(){ Console.WriteLine(\"打電話\"); }; } } public class Program { static void Main(string[] args) { var Phone_Iphone = new Iphone(); Console.WriteLine(\"手機型號: Iphone, 其功能如下\"); Phone_Iphone.Text(); Phone_Iphone.Call(); Phone_Iphone.Internet(); Phone_Iphone.OLED(); Console.ReadKey(); } // Output: 手機型號: 3310, 其功能如下 // 傳簡訊 // 打電話 // 可上網 // 彩色螢幕 public class Phone { public void Text(){ Console.WriteLine(\"傳簡訊\"); } public void Call(){ Console.WriteLine(\"打電話\"); }; } public class Iphone: Phone { public void Internet(){ Console.WriteLine(\"可上網\"); } public void OLED(){ Console.WriteLine(\"彩色螢幕\"); }; } } ","date":"2022-06-17","objectID":"https://loulazynote.github.io/posts/ooplearning/:1:2","tags":["OOP","C#"],"title":"OOP 物件導向學習筆記","uri":"https://loulazynote.github.io/posts/ooplearning/"},{"categories":["C#","Learning"],"content":"多型(Polymorphism) 多型在希臘文中表示「多種形狀」 在執行階段，衍生類別物件可視為方法參數和集合或陣列等位置中的基底類別物件。 當這個多型發生時，物件的宣告型別與其執行時間型別不再相同。(比較文言文的說法😓) 就是同一件事情，有需多不同的做法(比較白話文的說法😛) 同一件事情，有需多不同的做法，舉個例子，如同 粽子，同是粽子有分南部粽、北部粽、東部粽、潮州粽…等不同做法。 interface // 介面多型 public class Program { static void Main(string[] args) { I粽子 南部粽做法 = new 南部粽(); 南部粽做法.做法();// Output: 南部粽:米半熟~水煮 I粽子 北部粽做法 = new 北部粽(); 北部粽做法.做法();// Output: 北部粽:油飯~蒸煮 北部粽做法.評價();// Error: I粽子 未包含 評價 的定義(也就是說, 子類以父類建立時，只能以父類有的為主) Console.ReadKey(); } public interface I粽子 { void 做法(); } public class 南部粽: I粽子{ public void 做法(){ Console.WriteLine(\"南部粽:米半熟~水煮\"); } } public class 北部粽: I粽子{ public void 做法(){ Console.WriteLine(\"北部粽:油飯~蒸煮\"); } public void 評價(){ Console.WriteLine(\"好吃\"); } } } virual method // virual method public class Program { static void Main(string[] args) { Coffee normalcafe = new Coffee(); ShallowPeas sp = new ShallowPeas(); DeepPeeledBeans dp = new DeepPeeledBeans(); Coffee[] cafes = { normalcafe, sp, dp }; foreach(var cafe in cafes){ cafe.make(); } Console.ReadKey(); // Output: // Brewed and taste normal // Brewed and tasted sour // Brewed and tasted bitter } public class Coffee { public virual void make(){ Console.WriteLine(\"Brewed and taste normal\"); } } public class ShallowPeas: Coffee{ public override void make(){ Console.WriteLine(\"Brewed and tasted sour\"); } } public class DeepPeeledBeans: Coffee{ public override void make(){ Console.WriteLine(\"Brewed and tasted bitter\"); } } } 可以使用 base 取得父類方法或屬性 public class Program { static void Main(string[] args) { Coffee normalcafe = new Coffee(); Americano Acafe = new Americano(); normalcafe.make();// Output: Brewed and taste normal Acafe.make();// Output: Brewed and taste normal Console.ReadKey(); } public class Coffee { public virual void make(){ Console.WriteLine(\"Brewed and taste normal\"); } } public class Americano: Coffee{ public override void make(){ base.make(); } } } Use New to hide the base class member // Use new to hide the base class member public class Program { static void Main(string[] args) { ShallowPeas sp = new ShallowPeas(); sp.make();// Output: Brewed and tasted sour Coffee normalcafe = (Coffee)sp; normalcafe.make();// Output: Brewed and taste normal Console.ReadKey(); } public class Coffee { public void make(){ Console.WriteLine(\"Brewed and taste normal\"); } } public class ShallowPeas: Coffee{ public new void make(){ Console.WriteLine(\"Brewed and tasted sour\"); } } } ","date":"2022-06-17","objectID":"https://loulazynote.github.io/posts/ooplearning/:1:3","tags":["OOP","C#"],"title":"OOP 物件導向學習筆記","uri":"https://loulazynote.github.io/posts/ooplearning/"},{"categories":["C#","Learning"],"content":"抽象化(Abstraction) 以特性來說,就是將需求轉為類別,而此類別可以包含狀態(Property)及行為(Method),前幾個特性皆有示例已包含抽象化特性 public class Program { static void Main(string[] args) { Coffee cafe = new Coffee(); cafe.from = \"Ethiopia\"; cafe.type = \"ShallowPeas\" Console.WriteLine($\"來自{cafe.from}的{cafe.type}咖啡\"); cafe.make(); Console.ReadKey(); // Output: // 來自Ethiopia的ShallowPeas咖啡 // Brewed and tasted sour } public class Coffee { public string from { get; set; } public string type { get; set; } public void make(){ Console.WriteLine(\"Brewed and taste sour\"); } } } abstract 抽象類別 不能被實例化 如不應該被實體化成一個物件，此類別就應該成為抽象類別 子類必須要 override 方法才能使用 public class Program { static void Main(string[] args) { var pg = new Lou(); Console.WriteLine($\"The Programming Language is {pg.language}\"); pg.Coding(); Console.ReadKey(); // Output: // The Programming Language is CSharp // 努力寫專案 } public class Programer { public string language { get; set; } public abstract void Coding(); } public class Lou: Programer{ public string language { get; set; } =\u003e \"CSharp\"; public override void Coding(){ Console.WriteLine(\"努力寫專案\"); } } } ","date":"2022-06-17","objectID":"https://loulazynote.github.io/posts/ooplearning/:1:4","tags":["OOP","C#"],"title":"OOP 物件導向學習筆記","uri":"https://loulazynote.github.io/posts/ooplearning/"},{"categories":["C#","Learning"],"content":"參考資料 MSDN - C# 文件 YaYi - OOP三大特性：封裝、繼承、多型 保持前進、持續優化程式碼內涵 數據交點文摘 - 物件導向程式設計四大支柱之一：封裝 理工宅 - c# Public? Private? protected? 比較各種修飾詞存取範圍 程式人生 - C#多型的實現：虛方法、抽象類、介面 搞笑談軟工 - 什麼是物件導向（3）：Polymorphism 伊果的沒人看筆記本 - 菜雞與物件導向 (5): 多型 伊果的沒人看筆記本 - 菜雞與物件導向 (6): 抽象、覆寫 菜鳥工程師 肉豬 - Java 什麼是多載(Overload), 覆寫(Override), 多型(Polymorphism) ","date":"2022-06-17","objectID":"https://loulazynote.github.io/posts/ooplearning/:2:0","tags":["OOP","C#"],"title":"OOP 物件導向學習筆記","uri":"https://loulazynote.github.io/posts/ooplearning/"},{"categories":["WSL","Docker"],"content":"❗這個設定檔很重要❗ ❗這個設定檔很重要❗ ❗這個設定檔很重要❗ 為什麼這麼說呢? 在前陣子我的電腦重灌後就遺忘了設定檔這件事，這幾天突然發現我的RAM的使用率大飆升,每天電腦都像飛機要起飛一樣，且導致電腦變的很慢。 查看工作管理員 才想到 我的 WSL 裝好後都沒有設定它，所以這裡記錄一下該設定的設定檔內容。 ","date":"2022-06-10","objectID":"https://loulazynote.github.io/posts/wsl2-config-note/:0:0","tags":["WSL","Docker","Windows"],"title":"關於WSL的設定檔 - 不可不知的眉角","uri":"https://loulazynote.github.io/posts/wsl2-config-note/"},{"categories":["WSL","Docker"],"content":"WSL 2 的 .wslconfig 設定檔 編輯 %UserProfile%\\.wslconfig 檔案 code %UserProfile%\\.wslconfig 沒有此檔案的話，可以自行建立一個在%UserProfile% 根目錄下 設定內容說明 [wsl2] kernel=\u003cpath\u003e # 自定義 Linux 的絕對路徑 memory=\u003csize\u003e # 給予 WSL2 虛擬機的記憶體大小 processors=\u003cnumber\u003e # 給 WSL2 虛擬機分配的處理核心數 swap=\u003csize\u003e # 給 WSL2 虛擬機分配的交換空間 (設定 0 的話表示沒有給予交換空間) swapFile=\u003cpath\u003e # 自定義交換虛擬硬碟vhd的絕對路徑 localhostForwarding=\u003cbool\u003e # 允許 WSL2 的port轉發至本地主機 (default true). # \u003cpath\u003e 必須是反斜線的絕對路徑, for example: C:\\\\Users\\\\Ben\\\\kernel # \u003csize\u003e 必須在數字後加上單位, for example: 8GB or 512MB 參數 參數類型 預設值 說明 kernel string 微軟預設提供的 WSL 核心 連接自定義 Linux 的絕對路徑 memory size Windows 全部記憶體的 80% 給予 WSL2 虛擬機的記憶體大小 processors number 相同於Windows 本地主機的處理器核心 給 WSL2 虛擬機分配的處理核心數 localhostForwarding boolean TRUE 是否應可通過 localhost:port 指定綁定到 WSL2 VM 中的通配符或本地主機的埠連接到本地主機的布林值 (允許 WSL2 的port轉發至本地主機) kernelCommandLine string none 額外的核心命令列參數 swap size Windows 上所有記憶體的的 25% 給 WSL2 虛擬機分配的交換空間，設定 0 的話表示沒有給予交換空間 swapFile string %USERPROFILE%\\AppData\\Local\\Temp\\swap.vhdx 交換虛擬硬碟vhd的絕對路徑 ","date":"2022-06-10","objectID":"https://loulazynote.github.io/posts/wsl2-config-note/:1:0","tags":["WSL","Docker","Windows"],"title":"關於WSL的設定檔 - 不可不知的眉角","uri":"https://loulazynote.github.io/posts/wsl2-config-note/"},{"categories":["WSL","Docker"],"content":"參考資料 Release Notes for Windows Subsystem for Linux | Microsoft Docs - Build 18945 WSL 中的進階設定組態 Dev on Windows with WSL - 配置 WSL 2 全局设置 ","date":"2022-06-10","objectID":"https://loulazynote.github.io/posts/wsl2-config-note/:2:0","tags":["WSL","Docker","Windows"],"title":"關於WSL的設定檔 - 不可不知的眉角","uri":"https://loulazynote.github.io/posts/wsl2-config-note/"},{"categories":["C#","Learning"],"content":"型別系統 概觀 ❗ 是強型別語言, 每個變數和常數都有型別 ❗ 在 C# bool 中無法轉換成 int 儲存在類型中的資訊可以包含下列 型別的變數需要的儲存空間 它可以代表的最大值和最小值 它所包含的成員 (方法、欄位、事件等等) 它繼承自的基底型別 interface (實作) 允許的作業類型 編譯器會將型別資訊視為中繼資料內嵌至可執行檔 通用語言執行平台 (CLR) 會在執行階段使用該中繼資料，以在它配置和回收記憶體時，進一步保證型別安全 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/csharpbasicpart1/:1:0","tags":["Basic Level","C#"],"title":"C# 基礎複習Note(型別系統)","uri":"https://loulazynote.github.io/posts/csharpbasicpart1/"},{"categories":["C#","Learning"],"content":"變數宣告中指定類型 ❗ 程式中宣告變數或常數時 必須指定其類型 ❗ 也能使用var關鍵字來讓編譯器推斷類型 // Declaration only string name; int studentId; AClass aclass; // Declaration with initializers (four examples) string studentName = \"Lou\"; string [] ClassList = {\"Elaine\",\"Louis\",\"Kyber\", \"Peter\",\"Jeff\",\"Mary\"} // 型別推斷 var query = ClassList.Where(q =\u003e q == studentName).First(); ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/csharpbasicpart1/:1:1","tags":["Basic Level","C#"],"title":"C# 基礎複習Note(型別系統)","uri":"https://loulazynote.github.io/posts/csharpbasicpart1/"},{"categories":["C#","Learning"],"content":"內建類型 C# 提供一組標準內建類型 整數 浮點值 布林運算式 文字字元 十進位值 string object ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/csharpbasicpart1/:1:2","tags":["Basic Level","C#"],"title":"C# 基礎複習Note(型別系統)","uri":"https://loulazynote.github.io/posts/csharpbasicpart1/"},{"categories":["C#","Learning"],"content":"自訂類型 可以使用 結構類型(struct)、 類別(Class) 、 interface(interface)、列舉 (enum) 和 記錄(record) 建構來建立您自己的自訂類型 當明確將專案參考新增至定義這些專案的元件時，其他專案才可用 編譯器在有該組件的參考之後，您可以針對在原始程式碼的那個組件中宣告的型別宣告變數 (或常數) .NET 類別庫本身是自訂類型的集合，可以在應用程式中使用 根據預設，類別庫中最常使用的型別可用於任何 C# 程式 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/csharpbasicpart1/:1:3","tags":["Basic Level","C#"],"title":"C# 基礎複習Note(型別系統)","uri":"https://loulazynote.github.io/posts/csharpbasicpart1/"},{"categories":["C#","Learning"],"content":"一般型別系統(CTS) 支援繼承原則 型別可以衍生自稱為「基底型別」的其他型別, 而衍生的型別會繼承 (有部份限制) 基底型別的方法、屬性和其他成員 基底型別同樣可以衍生自一些其他型別，所衍生的型別會繼承其繼承階層架構中兩個基底型別的成員 所有類型 最終衍生自單一基底類型，即 System.Object (C# 關鍵字：object) 這種統一型別階層架構稱為一般型別系統 (CTS) 一般型別系統 (CTS)中的每個型別都會定義為「實值型別」或「參考型別」 包括 .NET 類別庫中的所有自訂類型 使用者定義型別 使用 結構類型(struct) 關鍵字定義的類型為實值型別，所有內建的數數值型別都是 結構類型(struct) 使用 類別(class) 或 記錄(record) 關鍵字定義的類型是參考型別 參考型別和實值型別有不同的編譯時期規則和不同的執行階段行為 C# 9.0 新增 記錄型別 資料和行為是類別、結構或記錄 的成員 類別、結構或記錄宣告就像是用來在執行時間建立實例或物件的藍圖 //p 為 Person 的物件或執行個體 Person p = new Person(){ Name = \"Lou\", Age = 18 }; // 可以建立多個相同 Person 型別的執行個體，且每個執行個體在其屬性與欄位中都可以有不同的值 Person p2 = new Person(){ Name = \"Elaine\", Age = 18 }; // Person 的類別、結構 public class Person{ public string Name { get; set; } public int Age { get; set; } } 類別是參考型別 建立型別的物件時，指派物件的變數只會保留該記憶體的參考 當物件參考指派至新的變數時，新的變數會參考到原始物件 透過某個變數所做的變更會反映在其他變數中，因為它們都參考相同的資料 結構是實值型別 建立結構時，結構指派的變數會保留結構的實際資料 當結構指派給新的變數時，就會複製它 新的變數和原始變數會各自包含一份相同的資料，對一個複本所做的變更不會影響另一個複本 記錄類型可以是參考型別(record class)或實值型別(record struct) 類別 是用來建立更複雜的行為模型 類別通常會儲存在建立類別物件之後要修改的資料 結構 最適合小型資料結構 結構通常會儲存在建立結構之後不打算修改的資料 記錄類型 是具有其他編譯器合成成員的資料結構 記錄通常會儲存在建立物件之後不打算修改的資料 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/csharpbasicpart1/:1:4","tags":["Basic Level","C#"],"title":"C# 基礎複習Note(型別系統)","uri":"https://loulazynote.github.io/posts/csharpbasicpart1/"},{"categories":["C#","Learning"],"content":"值類型 實值型別衍生自 System.ValueType，該型別又衍生自 System.Object 實數值型別變數會直接包含其值 結構記憶體會內嵌配置於變數所宣告的任何內容中，實數值型別變數沒有個別的堆積配置或垃圾收集額外負荷 實值型別有兩種類別 實值型別為 密封, 無法從任何實值型別衍生型別 結構類型(struct) 列舉 (enum) // 內建的數數值型別是結構，而且其具有您可以存取的欄位和方法 // constant field on type byte. byte b = byte.MaxValue; // 宣告並指派值給它們，就像是簡單的非匯總類型 byte num = 0xA; int i = 5; char c = 'Z'; 使用 結構類型 來建立自訂實值型別: public struct Coords { public int x, y; public Coords(int p1, int p2) { x = p1; y = p2; } } 實值型別的另一個類別是 enum: // 列舉會定義一組具名的整數常數 public enum FileMode { CreateNew = 1, Create = 2, Open = 3, OpenOrCreate = 4, Truncate = 5, Append = 6, } ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/csharpbasicpart1/:1:5","tags":["Basic Level","C#"],"title":"C# 基礎複習Note(型別系統)","uri":"https://loulazynote.github.io/posts/csharpbasicpart1/"},{"categories":["C#","Learning"],"content":"參考型別 其定義為 類別(class), 記錄(record), 委派(delegate), 陣列(array)或 interface(interface)的類型是參考型別 參考型別完全支援繼承 當您建立類別時，可以繼承自未定義為 密封的任何其他interface或類別 其他類別可以繼承自您的類別，並覆寫您的虛擬方法 類別的建立和指派 Example: // 建立 MyClass myClass = new MyClass(); // 指派 MyClass myClass2 = myClass; interface(interface) 無法使用new 運算子直接具現化，請建立並指派實作 interface之類別的實例 Example: // 建立 MyClass myClass = new MyClass(); // 用現值宣告及賦值 IMyInterface myInterface = myClass; // 或 建立並賦值 給`interface` IMyInterface myInterface2 = new MyClass(); 所有陣列都是參考型別，即使其元素都是實值型別 陣列會隱含衍生自System.Array 類別，可以宣告並使用 搭配 C# 提供的簡化語法 // 宣告並初始化一個數字陣列 int[] nums = { 1, 2, 3, 4, 5 }; // 訪問 System.Array 的實例屬性 int len = nums.Length; ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/csharpbasicpart1/:1:6","tags":["Basic Level","C#"],"title":"C# 基礎複習Note(型別系統)","uri":"https://loulazynote.github.io/posts/csharpbasicpart1/"},{"categories":["C#","Learning"],"content":"泛型類型 類型可以使用一或多個 類型參數 來宣告，做為實際型別的預留位置 建立 類型的實例時，可以指定清單將包含的物件類型，例如 string： // \u003c\u003e即為泛型,此處為 包含string型別的清單 List\u003cstring\u003e stringList = new List\u003cstring\u003e(); stringList.Add(\"String example\"); // compile time error adding a type other than a string: stringList.Add(4); 使用型別參數(\u003cT\u003e)讓您能夠重複使用相同的類別來保存任何元素型別，而不需要將每個元素都轉換成 object 泛型集合類別稱為 強型別集合 ，因為編譯器知道集合元素的特定類型 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/csharpbasicpart1/:1:7","tags":["Basic Level","C#"],"title":"C# 基礎複習Note(型別系統)","uri":"https://loulazynote.github.io/posts/csharpbasicpart1/"},{"categories":["C#","Learning"],"content":"隱含型別、匿名型別和可為 Null 的實值型別 隱含型別 : 可以使用 var 隱含輸入區域變數（但不能輸入類別成員），其變數還是會在編譯時期收到型別，但其是由編譯器所提供的型別 匿名型別 : 針對不想要在外部方法 儲存或傳遞的簡單相關值集合，建立具名類型可能很不方便，為此，可以建立「匿名型別」 可為 Null 的實值型別 : 一般實值型別不能有 null 的值, 在類別後附加?後，允許建立可為 Null 的實值型別，例如， int? 是一種 int 類型，也可以有 值 null 可為 Null 的實值型別是泛型結構類型的 System.Nullable\u003cT\u003e 實例。 當您將資料傳入資料庫時，可為 Null 的實值型別特別有用，其中數值可能是 null ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/csharpbasicpart1/:1:8","tags":["Basic Level","C#"],"title":"C# 基礎複習Note(型別系統)","uri":"https://loulazynote.github.io/posts/csharpbasicpart1/"},{"categories":["C#","Learning"],"content":"編譯時間類型和執行時間類型 變數可以有不同的編譯時間和執行時間類型 編譯時間類型是原始程式碼中變數的宣告或推斷類型 執行時間類型是該變數所參考之實例的類型 這兩種類型通常相同,Example: string message = \"This is a string of characters\"; 在其他情況下，編譯時間類型不同,Example: // 編譯時間類型位於 object, 執行時間類型為 string object anotherMessage = \"This is another string of characters\"; // 編譯時間類型位於 IEnumerable\u003cchar\u003e, 執行時間類型為 string IEnumerable\u003cchar\u003e someCharacters =\"abcdefghijklmnopqrstuvwxyz\"; 變數的兩種類型不同，請務必瞭解編譯時間類型和執行時間類型套用的時間，而編譯時間類型會決定編譯器所採取的所有動作 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/csharpbasicpart1/:1:9","tags":["Basic Level","C#"],"title":"C# 基礎複習Note(型別系統)","uri":"https://loulazynote.github.io/posts/csharpbasicpart1/"},{"categories":["C#","Learning"],"content":"命名空間(宣告命名空間以組織類型) C# 程式設計大量使用命名空間的原因有兩個 .NET 會使用命名空間來組織其許多類別 // System 是命名空間，而 Console 是該命名空間中的類別 System.Console.WriteLine(\"Hello World!\"); // using關鍵字可用來讓完整名稱不需要 using System; Console.WriteLine(\"Hello World!\"); 宣告您自己的命名空間，將有助於在較大型的程式設計專案中控制類別和方法名稱的範圍 // 使用 namespace 關鍵字宣告命名空間 namespace SampleNamespace { class SampleClass { public void SampleMethod() { System.Console.WriteLine( \"SampleMethod inside SampleNamespace\"); } } } 命名空間的名稱必須是有效的 C# 識別碼名稱 // 從 C# 10 開始，您可以針對該檔案中定義的所有類型宣告命名空間 namespace SampleNamespace; class AnotherSampleClass { public void AnotherSampleMethod() { System.Console.WriteLine( \"SampleMethod inside SampleNamespace\"); } } ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/csharpbasicpart1/:2:0","tags":["Basic Level","C#"],"title":"C# 基礎複習Note(型別系統)","uri":"https://loulazynote.github.io/posts/csharpbasicpart1/"},{"categories":["C#","Learning"],"content":"命名空間概觀 命名空間具有下列屬性： 命名空間可組織大型程式碼專案 它們會使用.運算子來分隔 using 指示詞讓其不需要指定每個類別的命名空間名稱 global 命名空間是 “root” 命名空間：global::System 一律會參考 .NET System 命名空間 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/csharpbasicpart1/:2:1","tags":["Basic Level","C#"],"title":"C# 基礎複習Note(型別系統)","uri":"https://loulazynote.github.io/posts/csharpbasicpart1/"},{"categories":["C#","Learning"],"content":"類別 參考型別 : 定義為類別(Class)的類型是參考型別 執行時間，當宣告參考型別的變數時，該變數會包含值 null ，直到使用 new 運算子明確建立類別的實例，或指派可能已在其他地方建立之相容型別的物件 //Declaring an object of type MyClass. MyClass mc = new MyClass(); //Declaring another object of the same type, assigning it the value of the first object. MyClass mc2 = mc; 宣告類別 : 類別是使用 class 關鍵字來宣告，後面接著唯一識別碼 // class 關鍵字的前面會加上存取層級(public) // [access modifier] - [class] - [identifier] public class Customer { // 類別上的欄位、屬性、方法和事件統稱為「類別成員」 // Fields, properties, methods and events go here... } 建立物件 : 物件是根據類別的具體實體，而且有時稱為類別的執行個體 類別會定義一種類型的物件，但不是物件本身 // 使用 new 關鍵字來建立物件 // object1 是根據 Customer 之物件的參考 Customer object1 = new Customer(); // 可以建立物件參考，而根本不需要建立物件 Customer object2; 建立物件參考，如未參考上一個物件參考，嘗試透過這類參考來存取物件將會在執行時間失敗 //可以藉由建立新的物件，或為其指派現有的物件，來參考物件 Customer object3 = new Customer(); Customer object4 = object3; 類別繼承 : 類別完全支援「繼承」，這是物件導向程式設計的基礎特性 建立類別時，可以繼承自任何其他未定義為 sealed 的類別，而其他類別可以繼承自您的類別，並覆寫類別虛擬方法，且可以執行一或多個interface 使用「衍生」可完成繼承，這表示使用從中繼承資料和行為的「基底類別」來宣告類別。 附加冒號以及接著衍生類別名稱後面的基底類別名稱，以指定基底類別 類別宣告基底類別時，會繼承基底類別的所有成員，但建構函式除外 public class Manager : Employee { // Employee fields, properties, methods and events are inherited // New Manager fields, properties, methods and events go here... } 可用abstract 宣告類別 抽象類別包含具有簽章定義但沒有實作的抽象方法， 無法具現化抽象類別 它們僅用於實作抽象方法的衍生類別 與sealed類別相反，sealed不允許從它衍生其他類別 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/csharpbasicpart1/:3:0","tags":["Basic Level","C#"],"title":"C# 基礎複習Note(型別系統)","uri":"https://loulazynote.github.io/posts/csharpbasicpart1/"},{"categories":["C#","Learning"],"content":"記錄 C# 中的 記錄 是一種 類別 或 結構 ，可提供使用資料模型的特殊語法和行為 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/csharpbasicpart1/:4:0","tags":["Basic Level","C#"],"title":"C# 基礎複習Note(型別系統)","uri":"https://loulazynote.github.io/posts/csharpbasicpart1/"},{"categories":["C#","Learning"],"content":"使用記錄的時機 您想要定義相依于\"值相等“的資料模型 您想要定義物件為”不可變“的類型 實值相等 對於記錄而言，值相等表示如果類型相符且所有屬性和域值相符，則記錄類型的兩個變數會相等 對於其他參考型別（例如類別），相等表示 參考相等 並非所有資料模型都能搭配值相等來運作， 例如 : Entity Framework Core 取決於參考是否相等，以確保它只針對概念為一個實體的實體類型使用一個實例 ， 基於這個理由，記錄類型不適合用來做為 Entity Framework Core 中的實體類型 不變性 不可變的型別是一種可防止在物件具現化之後，變更該物件的任何屬性或域值 需要型別必須是安全線程，或者您是根據雜湊表中剩餘的雜湊碼而定時，永久性可能很有用(JWTToken、EnycrptPassword) 記錄提供簡潔的語法來建立和使用不可變的類型 永久性並不適用于所有資料案例， 例如 : Entity Framework Core不支援使用不可變的實體類型進行更新 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/csharpbasicpart1/:4:1","tags":["Basic Level","C#"],"title":"C# 基礎複習Note(型別系統)","uri":"https://loulazynote.github.io/posts/csharpbasicpart1/"},{"categories":["C#","Learning"],"content":"記錄與類別和結構有何不同 宣告和具現化類別或結構的相同語法可用於記錄 只需以關鍵字取代 class ，或使用 record struct 取代 struct record 同樣地，記錄類別也支援用來表示繼承關聯性的相同語法 記錄與類別的差異如下： 您可以使用 位置參數 ，利用不可變的屬性來建立和具現化型別 在類別中指出參考相等或不相等的相同方法和運算子 (例如 Object.Equals(Object) 和 ==) ，表示記錄中的 Object.Equals(Object) 不相等 可以用 Object.Equals(Object)檢測是否相等 您可以使用 運算式來建立不可變物件的複本，並在選取的屬性中包含新的值 記錄的 ToString方法會建立格式化的字串，以顯示物件的類型名稱以及其所有公用屬性的名稱和值 記錄可以 繼承自另一個記錄， 記錄無法繼承自類別，而且類別無法繼承自記錄 記錄結構與結構的不同之處在於 編譯器合成了相等的方法和 ToString 編譯器為位置記錄結構合成 Deconstruct 方法 Example // 定義公開記錄 public record Person(string FirstName, string LastName); public static void Main() { // 使用位置參數來宣告和具現化記錄 Person person = new(\"Nancy\", \"Davolio\"); // 列印類型名稱和屬性值 Console.WriteLine(person); // output: Person { FirstName = Nancy, LastName = Davolio } } // 定義公開記錄 public record Person(string FirstName, string LastName, string[] PhoneNumbers); public static void Main() { var phoneNumbers = new string[2]; // 使用位置參數來宣告和具現化記錄 Person person1 = new(\"Nancy\", \"Davolio\", phoneNumbers); Person person2 = new(\"Nancy\", \"Davolio\", phoneNumbers); Console.WriteLine(person1 == person2); // output: True person1.PhoneNumbers[0] = \"555-1234\"; // 位置及長度相同 Console.WriteLine(person1 == person2); // output: True // 不同的執行個體也不為 null Console.WriteLine(ReferenceEquals(person1, person2)); // output: False } // 定義公開記錄 public record Person(string FirstName, string LastName) { public string[] PhoneNumbers { get; init; } } public static void Main() { Person person1 = new(\"Nancy\", \"Davolio\") { PhoneNumbers = new string[1] }; Console.WriteLine(person1); // output: Person { FirstName = Nancy, LastName = Davolio, PhoneNumbers = System.String[] } // 使用 with 運算式來複製不可變的物件，並變更其中一個屬性 Person person2 = person1 with { FirstName = \"John\" }; Console.WriteLine(person2); // output: Person { FirstName = John, LastName = Davolio, PhoneNumbers = System.String[] } Console.WriteLine(person1 == person2); // output: False person2 = person1 with { PhoneNumbers = new string[1] }; Console.WriteLine(person2); // output: Person { FirstName = Nancy, LastName = Davolio, PhoneNumbers = System.String[] } Console.WriteLine(person1 == person2); // output: False // 因 new string[1]是一個新的object與原object不相同 person2 = person1 with { }; Console.WriteLine(person1 == person2); // output: True // 因複製了卻無改變其值 } ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/csharpbasicpart1/:4:2","tags":["Basic Level","C#"],"title":"C# 基礎複習Note(型別系統)","uri":"https://loulazynote.github.io/posts/csharpbasicpart1/"},{"categories":["C#","Learning"],"content":"介面(定義多個類型的行為) interface包含非抽象 類別(class) 或 結構(struct) 必須實作之相關功能群組的定義 interface可以定義 靜態(static) 必須具有實作的方法 從 C# 8.0 開始，interface可能會定義成員的預設實作 可以藉由使用interface，在類別中包含多個來源的行為(這項功能在 C# 中是很重要的，因為語言不支援類別的多重繼承) 如果要模擬結構繼承，則必須使用interface，因為它們實際上無法繼承自另一個結構或類別 使用 interface 關鍵字來定義interface: interface IEquatable\u003cT\u003e { bool Equals(T obj); } // 任何實作 IEquatable\u003cT\u003e `interface`的類別或結構，必須包含 Equals 方法的定義，該方法符合`interface`指定的簽章 interface的名稱必須是有效的 C# 識別碼名稱(依慣例，interface名稱以大寫字母 I 開頭) IEquatable\u003cT\u003e的定義沒有提供 Equals的實作 類別 或 結構 可以實現多個interface，但 類別 只能繼承自 單一類別 interface可以包含實作方法、屬性、事件、索引子，或這四個成員類型的任何組合 interface可能包含靜態建構函式、欄位、常數或運算子 C# 11 開始，不是欄位的interface成員可能是 static abstract interface不能包含實例欄位、實例建構函式或完成項(interface是無法被實例化的) interface成員預設為公用，而且可以明確指定協助工具修飾詞，EX: public 、 protected 、 internal 、 private 、 protected internal Or private protected 成員 private 必須具有預設實作 若要實作interface成員，實作類別的對應成員必須是公用、非靜態，且具有與interface成員相同的名稱和簽章 ❗ 當interface宣告靜態成員時，實作該interface的類型也可能宣告具有相同簽章的靜態成員， 這些是宣告成員的型別有所區別且是唯一識別的， 在型別中宣告的靜態成員 不會覆寫 interface中所宣告的靜態成員 ❗ class/struct繼承了interface必須實作該interface的所有成員，而不需要interface提供預設實作 如果基底類別實作interface，則衍生自基底類別的任何class/struct都會繼承該實作 interface也能繼承interface(一或多個) class/struct繼承了interface,而此interface如有繼承其他interface,則該class/struct必須實作出所有繼承鏈中所有interface的成員 該class/struct可能會隱含轉換成衍生interface或其任何基底interface class/struct可能透過基底類別包含interface多次，繼承或透過其他interface繼承的interface 只有在類別將interface宣告為類別 (class ClassName : InterfaceName) 定義的一部分時，類別只能提供interface實作一次 Example // 類別的屬性與索引子可以針對`interface`中定義的屬性或索引子定義額外的存取子 public class Car : IEquatable\u003cCar\u003e { // 實作`interface`的類別可以宣告具有 get 和 set 存取子的相同屬性 public string? Make { get; set; } public string? Model { get; set; } public string? Year { get; set; } // 屬性或索引子使用明確的實作，則存取子必須相符 // Implementation of IEquatable\u003cT\u003e interface public bool Equals(Car? car) { return (this.Make, this.Model, this.Year) == (car?.Make, car?.Model, car?.Year); } } 如果類別實作兩個具有相同簽章成員的介面，則在類別上實作該成員會造成這兩個介面都使用該成員進行實作 public interface IControl { void Paint(); } public interface ISurface { void Paint(); } public class SampleClass : IControl, ISurface { // Both ISurface.Paint and IControl.Paint call this method. public void Paint() { Console.WriteLine(\"Paint method in SampleClass\"); } } SampleClass sample = new SampleClass(); IControl control = sample; ISurface surface = sample; // The following lines all call the same method. sample.Paint(); control.Paint(); surface.Paint(); // Output: // Paint method in SampleClass // Paint method in SampleClass // Paint method in SampleClass 若要根據使用中的介面來呼叫不同的執行，可以明確地執行介面成員，明確的介面實作為僅透過指定介面呼叫的類別成員: public class SampleClass : IControl, ISurface { void IControl.Paint() { System.Console.WriteLine(\"IControl.Paint\"); } void ISurface.Paint() { System.Console.WriteLine(\"ISurface.Paint\"); } } 類別成員 IControl.Paint 只能透過 IControl 介面取得，ISurface.Paint 只能透過 ISurface 取得(這兩種方法都是分開的，而且不會直接在類別上使用) SampleClass sample = new SampleClass(); IControl control = sample; ISurface surface = sample; // The following lines all call the same method. //sample.Paint(); // Compiler error. control.Paint(); // Calls IControl.Paint on SampleClass. surface.Paint(); // Calls ISurface.Paint on SampleClass. // Output: // IControl.Paint // ISurface.Paint 若要同時執行這兩個介面，類別必須使用明確的實作為屬性 P 或方法 P （或兩者），以避免編譯器錯誤 interface ILeft { int P { get;} } interface IRight { int P(); } class Middle : ILeft, IRight { public int P() { return 0; } int ILeft.P { get { return 0; } } } 從 c # 8.0開始，可以為介面中所宣告的成員定義實作為 如果類別從介面繼承方法執行，則只能透過介面類別型的參考來存取該方法，繼承的成員不會顯示為公用介面的一部分 public interface IControl { void Paint() =\u003e Console.WriteLine(\"Default Paint method\"); } public class SampleClass : IControl { // Paint() is inherited from IControl. } var sample = new SampleClass(); //sample.Paint();// \"Paint\" isn't accessible. var control = sample as IControl; control.Paint(); // 任何實介面的類別 IControl 都可以覆寫預設 Paint 方法，例如公用方法，或做為明確的介面執行 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/csharpbasicpart1/:5:0","tags":["Basic Level","C#"],"title":"C# 基礎複習Note(型別系統)","uri":"https://loulazynote.github.io/posts/csharpbasicpart1/"},{"categories":["C#","Learning"],"content":"泛型 泛型會將型別參數的概念引進 .NET，讓您能夠設計類別和方法來延遲一或多個型別的規格，直到用戶端程式代碼宣告並具現化類別或方法為止 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/csharpbasicpart1/:6:0","tags":["Basic Level","C#"],"title":"C# 基礎複習Note(型別系統)","uri":"https://loulazynote.github.io/posts/csharpbasicpart1/"},{"categories":["C#","Learning"],"content":"藉由使用泛型型別參數 T ，您可以撰寫可供其他用戶端程式代碼使用的單一類別，而不會產生執行時間轉換或裝箱作業的成本或風險 // Declare the generic class. public class GenericList\u003cT\u003e { public void Add(T input) { } } class TestGenericList { private class ExampleClass { } static void Main() { // Declare a list of type int. GenericList\u003cint\u003e list1 = new GenericList\u003cint\u003e(); list1.Add(1); // Declare a list of type string. GenericList\u003cstring\u003e list2 = new GenericList\u003cstring\u003e(); list2.Add(\"\"); // Declare a list of type ExampleClass. GenericList\u003cExampleClass\u003e list3 = new GenericList\u003cExampleClass\u003e(); list3.Add(new ExampleClass()); } } 泛型類別和方法結合了重複使用性、型別安全和效率 泛型最常搭配在其上操作的集合和方法使用 System.Collections.Generic命名空間包含數個以泛型為基礎的集合類別 非泛型集合（例如 ArrayList ）不建議使用 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/csharpbasicpart1/:6:1","tags":["Basic Level","C#"],"title":"C# 基礎複習Note(型別系統)","uri":"https://loulazynote.github.io/posts/csharpbasicpart1/"},{"categories":["C#","Learning"],"content":"建立自訂的泛型型別和方法，簡單的泛型類別 當 GenericArray\u003cT\u003e 以具象類型具現化時 (例如具現化為 GenericArray\u003cint\u003e)，所出現的每個 T 都會以 int 取代 public class GenericArray\u003cT\u003e { private T[] array; public GenericArray(int size) { array = new T[size + 1]; } public T getItem(int index) { return array[index]; } public void setItem(int index, T value) { array[index] = value; } } 使用泛型 GenericArray 類別並輸出結果: class Tester { static void Main(string[] args) { //declaring an int array MyGenericArray\u003cint\u003e intArray = new MyGenericArray\u003cint\u003e(5); //setting values for (int c = 0; c \u003c 5; c++) { intArray.setItem(c, c*5); } //retrieving the values for (int c = 0; c \u003c 5; c++) { Console.Write(intArray.getItem(c) + \" \"); } Console.WriteLine(); //declaring a character array MyGenericArray\u003cchar\u003e charArray = new MyGenericArray\u003cchar\u003e(5); //setting values for (int c = 0; c \u003c 5; c++) { charArray.setItem(c, (char)(c+97)); } //retrieving the values for (int c = 0; c\u003c 5; c++) { Console.Write(charArray.getItem(c) + \" \"); } Console.WriteLine(); Console.ReadKey(); } } //OutPut: //0 5 10 15 20 //a b c d e 泛型方法 Example 2: class Program { static void Swap\u003cT\u003e(ref T lhs, ref T rhs) { T temp; temp = lhs; lhs = rhs; rhs = temp; } static void Main(string[] args) { int a, b; char c, d; a = 10; b = 20; c = 'I'; d = 'V'; //display values before swap: Console.WriteLine(\"Int values before calling swap:\"); Console.WriteLine(\"a = {0}, b = {1}\", a, b); Console.WriteLine(\"Char values before calling swap:\"); Console.WriteLine(\"c = {0}, d = {1}\", c, d); //call swap Swap\u003cint\u003e(ref a, ref b); Swap\u003cchar\u003e(ref c, ref d); //display values after swap: Console.WriteLine(\"Int values after calling swap:\"); Console.WriteLine(\"a = {0}, b = {1}\", a, b); Console.WriteLine(\"Char values after calling swap:\"); Console.WriteLine(\"c = {0}, d = {1}\", c, d); Console.ReadKey(); } } /// OutPut: /// Int values before calling swap: /// a = 10, b = 20 /// Char values before calling swap: /// c = I, d = V /// Int values after calling swap: /// a = 20, b = 10 /// Char values after calling swap: /// c = V, d = I ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/csharpbasicpart1/:6:2","tags":["Basic Level","C#"],"title":"C# 基礎複習Note(型別系統)","uri":"https://loulazynote.github.io/posts/csharpbasicpart1/"},{"categories":["C#","Learning"],"content":"泛型總覽 使用泛型型別以最佳化程式碼重複使用、型別安全和效能 泛型的最常見用法是建立集合類別 .NET 類別庫包含命名空間中 System.Collections.Generic 有數個泛型集合類別，應該盡可能使用泛型集合，而不是命名空間中 System.Collections 的類別 ArrayList 可以建立自己的泛型介面、類別、方法、事件和委派 泛型類別可限制為允許存取特定資料類型上的方法 泛型資料類型中所使用的類型相關資訊，可在執行階段透過反映取得 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/csharpbasicpart1/:6:3","tags":["Basic Level","C#"],"title":"C# 基礎複習Note(型別系統)","uri":"https://loulazynote.github.io/posts/csharpbasicpart1/"},{"categories":["C#","Learning"],"content":"匿名類型 匿名類型提供一個便利的方法，將一組唯讀屬性封裝成一個物件，而不需要事先明確定義類型 類型名稱會由編譯器產生，並且無法在原始程式碼層級使用 每個屬性的類型會由編譯器推斷 // 以兩個名為 Amount 和 Message 的屬性初始化的匿名類型 var v = new { Amount = 108, Message = \"Hello\" }; // Rest the mouse pointer over v.Amount and v.Message in the following // statement to verify that their inferred types are int and string. Console.WriteLine(v.Amount + v.Message); 匿名型別通常用於查詢運算式的select子句中 ，以從來源序列中的每個物件傳回屬性的子集 匿名類型包含一個或多個公用唯讀屬性 其他類型的類別成員 (例如方法或事件) 則無效 用於初始化屬性的運算式不可以是 null、匿名函式或指標類型 var productQuery = from prod in products select new { prod.Color, prod.Price }; foreach (var v in productQuery) { Console.WriteLine(\"Color={0}, Price={1}\", v.Color, v.Price); } 可以使用 var 將變數宣告為隱含型別區域變數， 由於只有編譯器可以存取匿名類型的基本名稱，因此無法在變數宣告中指定類型名稱 // 合併隱含類型區域變數和隱含類型陣列，以建立匿名類型項目的陣列 var anonArray = new[] { new { name = \"apple\", diam = 4 }, new { name = \"grape\", diam = 1 }}; 匿名型別是class衍生自object的型別，而且不能轉換成除了object以外的任何類型 如果組件中有兩個或多個匿名物件初始設定式，指定了順序相同並具有相同名稱和類型的屬性序列，編譯器會將這些物件視為相同類型的執行個體 這些物件會共用編譯器產生的相同類型資訊 匿名型別以 運算式的形式支援非破壞性變化，這可建立匿名型別的新實例，其中一或多個屬性具有新的值 var apple = new { Item = \"apples\", Price = 1.35 }; var onSale = apple with { Price = 0.79 }; Console.WriteLine(apple); Console.WriteLine(onSale); 無法將欄位、屬性、事件或方法的傳回類型，宣告為具有匿名類型 無法將方法、屬性、建構函式或索引子的型式參數宣告為具有匿名類型 若要傳遞匿名型別或包含匿名型別的集合，做為方法的引數，可以將參數宣告為類型 object ❗ 針對匿名型別使用 object 會破壞強型別的目的 ❗ 如果必須在方法界限外儲存或傳遞查詢結果，請考慮使用一般具名結構或類別來取代匿名類型 匿名類型上的 Equals 和 GetHashCode 方法會以屬性的 Equals 和 GetHashCode 方法來定義，相同匿名類型的兩個執行個體僅在其所有屬性都相等時，這兩個執行個體才相等 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/csharpbasicpart1/:7:0","tags":["Basic Level","C#"],"title":"C# 基礎複習Note(型別系統)","uri":"https://loulazynote.github.io/posts/csharpbasicpart1/"},{"categories":["C#","Learning"],"content":"參考資料 MSDN - C# 文件 Gitbook - C#教學 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/csharpbasicpart1/:8:0","tags":["Basic Level","C#"],"title":"C# 基礎複習Note(型別系統)","uri":"https://loulazynote.github.io/posts/csharpbasicpart1/"},{"categories":["Kerberos"],"content":"Keberos 概述 Kerberos 是一種計算機網絡認證協議 它允許某實體在非安全網絡環境下通信 向另一個實體以一種安全的方式證明自己的身份 Kerberos 伺服器本身稱為鑰匙分配中心或 KDC 一般來說，KDC 除了發放票據與金鑰之外，同時也負責身份驗證的功能 (Authentication Server, AS) Kerberos 使用 Needham-Schroeder 協議作為基礎 它使用一個由兩個獨立的邏輯部分： 認證伺服器 票據授權伺服器 組成\"可信賴的第三方\" Kerberos 工作在用於證明用戶身份的\"票據\"基礎上 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/:1:0","tags":["Kerberos"],"title":"Single Sign On with Kerberos","uri":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/"},{"categories":["Kerberos"],"content":"Needham-Schroeder Needham 與 Schroeder 於 1978 年提出一種『多重盤問與回應』的認證協定，它不但可以避免重播攻擊，也可以解決相互認證的問題。 而協議的安全主要依賴於參加者對時間的鬆散同步和短周期的叫做 Kerberos 票據的認證聲明 下面為 Kerberos 內容名詞縮寫及解釋： AS（Authentication Server）: 認證伺服器 KDC（Key Distribution Center）: 鑰匙分配中心 TGS（Ticket Granting Server）: 票據授權伺服器 TGT（Ticket Granting Ticket）: 票據授權票據，票據的票據 ST（Service Ticket）: 服務門票 SS（Service Server）: 特定服務提供端 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/:1:1","tags":["Kerberos"],"title":"Single Sign On with Kerberos","uri":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/"},{"categories":["Kerberos"],"content":"認證伺服器（Authentication Server/AS） 相當於『鑰匙分配中心』（KDC） 管理每一個使用者的主密鑰（或稱共享密鑰） 欲加入的使用者都必須向 AS 伺服器申請帳戶並取得主密鑰 網路上任何一個使用者登入系統時，都會向認證中心取得通行證（Pass Book 或 TGT 票），有了通行證便可以在網路上索取所要的資源 簡單來說就是 驗證 Client 端的身份（確定你是身份證上的本人） 驗證通過就會給一張票證授予票證（Ticket Granting Ticket/TGT）給 Client ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/:1:2","tags":["Kerberos"],"title":"Single Sign On with Kerberos","uri":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/"},{"categories":["Kerberos"],"content":"鑰匙分配中心(Key Distribution Center/KDC) KDC 是一台伺服器，它與每位註冊的使用者分享不同的的私密對稱金鑰，當使用者第一次使用註冊時，這支金鑰可以利用人工輸入到伺服器 KDC 知道每位使用者的私密金鑰，而每位使用者可以使用此金鑰與 KDC 進行安全通訊 以 Star 星狀方式配置，從中心集中管理對外分散的 Key 採用 KDC 的管理方式可以減少 Key 的數量，它將所有的 Key 集中到一個中心點因此降降低了 Key 的數目，n 個 node 只需要 n 把 Key 即可，以 5 個點的拓樸系統來看只需要 5 把 Key，因此大大的降低系統對 Key 的需求 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/:1:3","tags":["Kerberos"],"title":"Single Sign On with Kerberos","uri":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/"},{"categories":["Kerberos"],"content":"票據授權伺服器（Ticket Granting Server/TGS） TGS 管理網路上所有服務伺服器，並紀錄所有服務伺服器的秘密鑰匙 當有新的伺服器加入或退出時，都必須向 TGS 伺服器申請 而且某一秘密鑰匙也只有 TGS 伺服器和該服務伺服器兩者所擁有，因此 TGS 伺服器必須管理網路上所有伺服器的秘密鑰匙 使用者如要存取服務伺服器上資源時，必須向 TGS 提出它的身份證明，即 TGT 門票。 TGT 門票是經過 TGS 伺服器的秘密鑰匙加密，因此只有 TGS 伺服器能觀察門票的內容，別人無法仿冒 TGS 伺服器驗證完使用者的通行證後，再發給使用者有關使用者本身和所欲要求的服務伺服器的『服務門票』（Service Ticket, ST） 有了 ST 門票之後，使用者才可以到服務伺服器上存取資源，ST 門票同時包含了會議鑰匙 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/:1:4","tags":["Kerberos"],"title":"Single Sign On with Kerberos","uri":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/"},{"categories":["Kerberos"],"content":"票據授權票據，票據的票據（Ticket Granting Ticket/TGT） 此票是由 AS 伺服器發給客戶端的身分證明使用；使用者可以持此票向 TGS 伺服器申請通往某一伺服器的請求 Kerberos 協議將 TGT 的使用設計成可以避免經常向用戶詢問密碼（Kerberos 用來派生主密鑰的密碼）或將主密鑰存儲在工作站上 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/:1:5","tags":["Kerberos"],"title":"Single Sign On with Kerberos","uri":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/"},{"categories":["Kerberos"],"content":"服務門票（Service Ticket/ST） 當使用者出示 TGT 門票，向 TGS 伺服器要求前往某一伺服器 如果 TGS 伺服器同意其要求時，則發給所要求伺服器的 ST 門票給使用者，使用者持此票即可要求該伺服器提供服務 ST（Service Ticket）也有資料稱為 TGS Ticket ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/:1:6","tags":["Kerberos"],"title":"Single Sign On with Kerberos","uri":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/"},{"categories":["Kerberos"],"content":"Keberos 流程關係 消息 A：使用 Client/User 的秘密密鑰加密的 Client/TGS Session Key。 消息 B：使用 TGS 的密鑰加密的票證授予票證。 消息 C：由消息 B 的 TGT 和所請求服務的 ID 組成。 消息 D：使用 Client/TGS 會話密鑰加密的身份驗證器。 消息 E：使用服務的秘密密鑰加密的 Client 到 Server 票證。 消息 F：使用 Client/TGS Session Key 加密的 Client/Server Session Key。 消息 G：一個新的身份驗證器，其中包括 Client ID，時間戳記，並使用 Client/Server Session Key 進行了加密。 消息 H：在 Client 的身份驗證器中找到的時間戳已使用 Client/Server Session Key 進行了加密。 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/:1:7","tags":["Kerberos"],"title":"Single Sign On with Kerberos","uri":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/"},{"categories":["Kerberos"],"content":"名詞解釋 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/:2:0","tags":["Kerberos"],"title":"Single Sign On with Kerberos","uri":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/"},{"categories":["Kerberos"],"content":"Principal Kerberos principal（又稱為主體）用於在 kerberos 加密系統中標記一個唯一的身份 主體可以是用戶（如 louis）或服務（如 namenode 或 hive） 根據約定，主體名稱分為三個部分： 主名稱、實例和領域。 例如，典型的 Kerberos 主體可以是 louis/admin@EXAMPLE.COM ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/:2:1","tags":["Kerberos"],"title":"Single Sign On with Kerberos","uri":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/"},{"categories":["Kerberos"],"content":"keytab keytab 是包含 principals 和加密 principal key 的文件 \u003e keytab 用於將 SSO 帶到未加入 AD domain 的應用程序 keytab 文件對於每個 host 是唯一的，因為 key 中包含 hostname keytab 文件用於不需要人工交互和保存純文本密碼，實現到 kerberos 上驗證一個主機上的 principal 因為 Server 上可以訪問 keytab 文件即可以以 principal 的身份通過 kerberos 的認證，所以，keytab 文件應該被妥善保存，應該只有少數的用戶可以訪問 如何產生 Keytab? 使用實用程序 KTPASS.EXE 它是 RSAT 的一部分，如果啟用了 Active Directory 目錄服務工具將顯示在 RSAT 中 ktpass /out app1.keytab /princ http/app1.verenatex.com@verenatex.com /mapuser app1 /crypto AES256-SHA1 /ptype KRB5_NT_PRINCIPAL /pass Password2 /target vdc01.verenatex.com /out 指定輸出文件的名稱，如 app1.keytab /princ 指定 userPrincipalName 以及將其添加到對映帳戶的 servicePrincipalName 的值 /mapuser 是將為其生成 Keytab 的帳戶 /crypto 是用於 Keytab 的加密類型，此處為 AES256-SHA1 /ptype 通常應使用 KRB5_NT_PRINCIPAL，除非應用程序文檔另有說明 /pass 是對應帳戶的新密碼（默認情況下，它將執行密碼重置操作） /target 用於指示將查詢哪個 domain 控制器(it is optional, but can be useful if you have more than one domain in your forest) ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/:2:2","tags":["Kerberos"],"title":"Single Sign On with Kerberos","uri":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/"},{"categories":["Kerberos"],"content":"Single Sign-On (SSO) 單一登錄（SSO）協議（Kerberos，SAML，OpenID 等）允許用戶使用單個 ID 和密碼來訪問不同的應用程序。用戶登錄以獲得對連接系統的訪問權限，或者使用輕型目錄訪問協議（LDAP）和（目錄）服務器上存儲的 LDAP 數據庫來完成訪問。 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/:3:0","tags":["Kerberos"],"title":"Single Sign On with Kerberos","uri":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/"},{"categories":["Kerberos"],"content":"SPNEGO SPNEGO 代表\"簡單和受保護的 GSS_API 協商機制\"，用於擴展基於 Kerberos 的 SSO 環境以用於 Web Application，因為 SPNEGO 被設計用於 Client Server 桌面環境，通常不用於 Web Application 或簡易 Client 環境 Spnego 是一種與身份驗證器協商使用哪種安全協議的機制 例如 Kerberos，NTLM，摘要或 Basic.5t6 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/:4:0","tags":["Kerberos"],"title":"Single Sign On with Kerberos","uri":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/"},{"categories":["Kerberos"],"content":"SPN(Service Principal Names) 服務主體名稱 (SPN) 是服務實例的唯一標識符 Kerberos 身份驗證使用 SPN 將服務實例與服務登錄帳戶關聯 這允許用戶端應用程式請求服務對帳戶進行身份驗證，即使客戶端沒有帳戶名稱 如果在整個林中的電腦上安裝多個服務實例，則每個實例必須有自己的 SPN 如果用戶端可能使用多個名稱進行身份驗證，則給定的服務實例可以有多個 SPN 例如，SPN 始終包含運行服務實例的主機的名稱，因此服務實例可能會為其主機的每個名稱或別名註冊 SPN 在 Kerberos 身份驗證服務可以使用 SPN 對服務進行身份驗證之前，必須在服務實例用於登錄的帳戶物件上註冊 SPN 給定的 SPN 只能在一個帳戶上註冊 對於 Win32 服務，服務安裝程式在安裝服務實例時指定登錄帳戶 然後，安裝程式組成 SPN，並將它們作為活動目錄域服務中的帳戶物件的屬性編寫 如果服務實例的登錄帳戶發生更改，則必須在新帳戶下重新註冊 SPN 當用戶端想要連接到服務時，它會查找服務的實例，為該實例編寫 SPN，連接到該服務，並顯示用於服務的 SPN 進行身份驗證 Client 上的 Application（例如 Browser）嘗試訪問 Web Server 上的受保護頁面 Server 響應要求授權 Application 從 Kerberos KDC 請求 Service ticket 獲得 ticket 後，Application 將其包裝為 SPNEGO 格式的請求，然後通過 Browser 將其發送回 Web Application 執行已部署的 Web Application 的 web container（Tomcat、JBoss EAP 等）對請求進行解包並驗證 ticket 認證成功後，將授予訪問權限 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/:5:0","tags":["Kerberos"],"title":"Single Sign On with Kerberos","uri":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/"},{"categories":["Kerberos"],"content":"Browser 如何透過 Kerberos 進行身分驗證 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/:6:0","tags":["Kerberos"],"title":"Single Sign On with Kerberos","uri":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/"},{"categories":["Kerberos"],"content":"循序圖 User 登錄 Windows，並通過 KDC 進行了身份驗證(對於 Windows，KDC 將是主域控制器) OS 為 User 接收一個 TGT token 當 User 嘗試連接到 Tomcat 服務器(或其他 web container)時，將協商身份驗證機制(紅字原文: the authentication mechanism is negotiated) User 的 token 被傳遞給 Tomcat，然後 Tomcat 通過 KDC 對其進行驗證 驗證 User 身份後，Tomcat 隨後從 LDAP 服務器中檢索其角色（在 Windows 中為 Active Directory，這是一種專門處理諸如用戶名和密碼之類的身份信息的數據庫） 並確定他是否有權訪問（Response 200 OK）他在服務器上請求的資源。 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/:6:1","tags":["Kerberos"],"title":"Single Sign On with Kerberos","uri":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/"},{"categories":["Kerberos"],"content":"參考資料 Setting up Kerberos Authentication for a Website in IIS Single Sign On with Kerberos Kerberos Wikipedia 鳥哥的 Linux 私房菜 看完您如果還不明白 Kerberos 原理，算我輸 翻轉工作室-資訊與網路安全技術：第十四章 Kerberos 認證系統 The Secret Security Wiki Kerberos.NET Guide To Setup Kerberos Single Sign-On (SSO) 瞭解 keytab 需求 宅學習 如何使用 Spn，當您在 [網際網路資訊服務上設定 裝載的 Web 應用程式] Microsoft Developer-Service Principal Names 瞭解 keytab 需求 All you need to know about Keytab files ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/:7:0","tags":["Kerberos"],"title":"Single Sign On with Kerberos","uri":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/"},{"categories":["C#","Maintain","Asp.Net"],"content":"Filter Filter 的作用是在 Action 執行前或執行後做一些加工處理 Authorization Filter： Authorization 是五種 Filter 中優先序最高的，通常用於驗證 Request 合不合法，不合法後面就直接跳過。 Resource Filter： Resource 是第二優先，會在 Authorization 之後，Model Binding 之前執行。通常會是需要對 Model 加工處裡才用。 Action Filter： 最容易使用的 Filter，封包進出都會經過它，使用上沒什麼需要特別注意的。跟 Resource Filter 很類似，但並不會經過 Model Binding。 Exception Filter： 異常處理的 Exception。 Result Filter： 當 Action 完成後，最終會經過的 Filter。 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/mvc5_meta/:1:0","tags":["Asp.Net MVC"],"title":"MVC 5 filter","uri":"https://loulazynote.github.io/posts/mvc5_meta/"},{"categories":["C#","Maintain","Asp.Net"],"content":"運作方式 ASP .NET Core 的每個 Request 都會先經過已註冊的 Middleware 接著才會執行 Filter，除了會依照上述的順序外，同類型的 Filter 預設都會以先進後出的方式處裡封包。 Response 在某些 Filter 並不會做處理，會值接 Bypass。Request 及 Response 的運作流程如下圖： 黃色箭頭是正常情況流程 灰色箭頭是異常處理流程 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/mvc5_meta/:1:1","tags":["Asp.Net MVC"],"title":"MVC 5 filter","uri":"https://loulazynote.github.io/posts/mvc5_meta/"},{"categories":["C#","Maintain","Asp.Net"],"content":"參考資料 John Wu’s [鐵人賽 Day14] ASP.NET Core 2 系列 - Filters ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/mvc5_meta/:2:0","tags":["Asp.Net MVC"],"title":"MVC 5 filter","uri":"https://loulazynote.github.io/posts/mvc5_meta/"},{"categories":["Learning"],"content":"位於索引中的檔案 : Tracked files(追蹤的檔案) 不再索引內的檔案 : Untracked files(未被追蹤的檔案) working tree 是工作目錄 只要 被索引中的檔案內容 跟 工作目錄中的檔案內容一致 就會被稱為一個 “Stage“狀態 只要 被索引中的檔案內容 跟 工作目錄中的檔案內容不一致 就會被稱為一個 “Unstage“狀態 ","date":"2022-06-08","objectID":"https://loulazynote.github.io/posts/git-learning/:0:0","tags":["Git"],"title":"Git 學習筆記","uri":"https://loulazynote.github.io/posts/git-learning/"},{"categories":["Learning"],"content":"Git 指令 Command: git -m = message init = 建立 add = 加入 GIT 索引 rm = 刪除 status = 看目前狀態 ","date":"2022-06-08","objectID":"https://loulazynote.github.io/posts/git-learning/:1:0","tags":["Git"],"title":"Git 學習筆記","uri":"https://loulazynote.github.io/posts/git-learning/"},{"categories":["Learning"],"content":"git diff 顯示差異 HEAD = 比對變更與目前最新版的變更差異 -cached = 索引裡的變更與本地儲存庫最新的變更差異 --binary = 比對二進位檔案差異 --name-only = 比對工作目錄檔案,列出檔案名稱 --name-status = 列出工作目錄及索引之間有多少檔案是被異動的 git diff 'src-commit' 'tgt-commit' commit 與 commit 比較差異 git diff 'commit' 與目標 commit 差異 ","date":"2022-06-08","objectID":"https://loulazynote.github.io/posts/git-learning/:1:1","tags":["Git"],"title":"Git 學習筆記","uri":"https://loulazynote.github.io/posts/git-learning/"},{"categories":["Learning"],"content":"git reset 重置索引 -p = 選取索引中的那些變更有哪些內容要從索引中移除 HEAD = 重置索引及分支(加 ~1 是恢復前一版本,以此類推) --mixed = 重置 HEAD 及索引(預設值) --hard = 重置 HEAD,索引及工作目錄 --hard ORIG_HEAD = 回復前版本(永遠回復 reset 之前的版本) ","date":"2022-06-08","objectID":"https://loulazynote.github.io/posts/git-learning/:1:2","tags":["Git"],"title":"Git 學習筆記","uri":"https://loulazynote.github.io/posts/git-learning/"},{"categories":["Learning"],"content":"git revert 還原歷史上的版本，做相反的 commit -h = help 列出功能 --abort = 取消 --continue = 繼續 --quit = 停止 ","date":"2022-06-08","objectID":"https://loulazynote.github.io/posts/git-learning/:1:3","tags":["Git"],"title":"Git 學習筆記","uri":"https://loulazynote.github.io/posts/git-learning/"},{"categories":["Learning"],"content":"git clone 下載遠端儲存庫 git clone --no-checkout 'URL' 'Filename' 會以 filename 為主並且不做 checkout git clone --bare 'url' 把儲存庫的本身下載下來 ","date":"2022-06-08","objectID":"https://loulazynote.github.io/posts/git-learning/:1:4","tags":["Git"],"title":"Git 學習筆記","uri":"https://loulazynote.github.io/posts/git-learning/"},{"categories":["Learning"],"content":"git log 看紀錄 --oneline = 短的 log 版本 --oneline --graph = log 版本+線圖可加 “-數字” 以顯示筆數 git log --oneline --graph --all -10 全部的歷史資料取 10 筆 ","date":"2022-06-08","objectID":"https://loulazynote.github.io/posts/git-learning/:1:5","tags":["Git"],"title":"Git 學習筆記","uri":"https://loulazynote.github.io/posts/git-learning/"},{"categories":["Learning"],"content":"git reflog 會記錄工作目錄底下做過的每一次的版控紀錄 ","date":"2022-06-08","objectID":"https://loulazynote.github.io/posts/git-learning/:1:6","tags":["Git"],"title":"Git 學習筆記","uri":"https://loulazynote.github.io/posts/git-learning/"},{"categories":["Learning"],"content":"git checkout 取出/取回 -- 'name' = 從索引裡面把 name 檔案的內容整個複製回工作目錄 --orphan = 建立全新分支且沒有 parents checkout -b \"Filename\" 可以新增分支後切換 ","date":"2022-06-08","objectID":"https://loulazynote.github.io/posts/git-learning/:1:7","tags":["Git"],"title":"Git 學習筆記","uri":"https://loulazynote.github.io/posts/git-learning/"},{"categories":["Learning"],"content":"git switch 切換分支 ","date":"2022-06-08","objectID":"https://loulazynote.github.io/posts/git-learning/:1:8","tags":["Git"],"title":"Git 學習筆記","uri":"https://loulazynote.github.io/posts/git-learning/"},{"categories":["Learning"],"content":"git clean 清除工作目錄 -f = 強制刪除 -d = 刪除整個工作目錄 -x = 執行清除任務,並忽略.gitignore 設定 -n = 看那些檔案會被清除 ","date":"2022-06-08","objectID":"https://loulazynote.github.io/posts/git-learning/:1:9","tags":["Git"],"title":"Git 學習筆記","uri":"https://loulazynote.github.io/posts/git-learning/"},{"categories":["Learning"],"content":"git stash 暫存工作目錄的變更 save 'message' = 暫存 pop = 取回暫存 ","date":"2022-06-08","objectID":"https://loulazynote.github.io/posts/git-learning/:1:10","tags":["Git"],"title":"Git 學習筆記","uri":"https://loulazynote.github.io/posts/git-learning/"},{"categories":["Learning"],"content":"git branch 查看分支/新增分支 -d = 刪除分支(只能刪除已經合併的分支) -D = 強制刪除分支 -r = 列出所有遠端追蹤分支 -a = 列出所有遠端+本地分支 git branch --merged 列出所有已合併過的分支 git branch --no-merged 列出所有未合併過的分支 git branch --merged | egrep -v \"(^\\*|master|develop)\" | xargs git branch -d 刪除所有已合併過的分支(CMD/Powershell 不可用) ","date":"2022-06-08","objectID":"https://loulazynote.github.io/posts/git-learning/:1:11","tags":["Git"],"title":"Git 學習筆記","uri":"https://loulazynote.github.io/posts/git-learning/"},{"categories":["Learning"],"content":"git merge 合併分支 --ff = 快轉合併(預設) --no-ff = 非快轉合併 --ff-only = 僅有快轉合併 --no-commit = 不提交的合併 --abort = 放棄合併 --squash = 壓縮後合併(不可以與關閉快轉機制一起使用,且不會有合併線圖出現) git merge --no-ff --no-commit 'branchName' 合併可以不 commit ","date":"2022-06-08","objectID":"https://loulazynote.github.io/posts/git-learning/:1:12","tags":["Git"],"title":"Git 學習筆記","uri":"https://loulazynote.github.io/posts/git-learning/"},{"categories":["Learning"],"content":"git rebase 'commit_id' 重訂基底合併 -i --continue = 繼續 --skip = 跳過 --abort = 取消 ","date":"2022-06-08","objectID":"https://loulazynote.github.io/posts/git-learning/:1:13","tags":["Git"],"title":"Git 學習筆記","uri":"https://loulazynote.github.io/posts/git-learning/"},{"categories":["Learning"],"content":"git cherry-pick 正向挑選合併 --continue = 繼續 --quit = 停止 --abort = 取消 ","date":"2022-06-08","objectID":"https://loulazynote.github.io/posts/git-learning/:1:14","tags":["Git"],"title":"Git 學習筆記","uri":"https://loulazynote.github.io/posts/git-learning/"},{"categories":["Learning"],"content":"git push 推送至遠端 --all = 全部分支推送 git push -u origin master 將本地分支(master)與遠端分支(origin)建立連結 git push origin --delete ‘branchName’ 刪除遠端分支(要先把本地刪除) ","date":"2022-06-08","objectID":"https://loulazynote.github.io/posts/git-learning/:1:15","tags":["Git"],"title":"Git 學習筆記","uri":"https://loulazynote.github.io/posts/git-learning/"},{"categories":["Learning"],"content":"git fetch 將遠端儲存庫的變更下載回來 --prune 將遠端已刪除的分支剪除 ","date":"2022-06-08","objectID":"https://loulazynote.github.io/posts/git-learning/:1:16","tags":["Git"],"title":"Git 學習筆記","uri":"https://loulazynote.github.io/posts/git-learning/"},{"categories":["Learning"],"content":"git pull 將遠端儲存庫拉下來 pull = git fetch + git merge git pull --rebase = git fetch + git rebase ","date":"2022-06-08","objectID":"https://loulazynote.github.io/posts/git-learning/:1:17","tags":["Git"],"title":"Git 學習筆記","uri":"https://loulazynote.github.io/posts/git-learning/"},{"categories":["Learning"],"content":"git remote 遠端 -v = 列出網址 -h = remote 的 help set-url = 更改網址 git remote set-url origin 'new url' 將舊網址改成新網址 ","date":"2022-06-08","objectID":"https://loulazynote.github.io/posts/git-learning/:1:18","tags":["Git"],"title":"Git 學習筆記","uri":"https://loulazynote.github.io/posts/git-learning/"},{"categories":["Learning"],"content":"git commit 建立版本 ","date":"2022-06-08","objectID":"https://loulazynote.github.io/posts/git-learning/:1:19","tags":["Git"],"title":"Git 學習筆記","uri":"https://loulazynote.github.io/posts/git-learning/"},{"categories":["Learning"],"content":"git apply 套用版本(進版) --check = 確認檔案 --reverse = 退版(簡寫-R) ","date":"2022-06-08","objectID":"https://loulazynote.github.io/posts/git-learning/:1:20","tags":["Git"],"title":"Git 學習筆記","uri":"https://loulazynote.github.io/posts/git-learning/"},{"categories":["Learning"],"content":"git config GIT 的設定 加上 --global 可以設定 core.quotepath = 改 false 可顯示中文 core.editor = 查看目前編輯器 git 只能顯示 ASCII 的字元 git bash 以外的環境要改中文 set LC_ALL=C.UTF-8 更改環境變數 (永久儲存) setx LC_ALL C.UTF-8 MAC/Linux export LC_ALL=C.UTF-8 ","date":"2022-06-08","objectID":"https://loulazynote.github.io/posts/git-learning/:1:21","tags":["Git"],"title":"Git 學習筆記","uri":"https://loulazynote.github.io/posts/git-learning/"},{"categories":["Learning"],"content":"衝突問題 顯示訊息: content = 內容衝突 建議用手動合併 ","date":"2022-06-08","objectID":"https://loulazynote.github.io/posts/git-learning/:2:0","tags":["Git"],"title":"Git 學習筆記","uri":"https://loulazynote.github.io/posts/git-learning/"},{"categories":["Learning"],"content":"參考資料 為自己學 GIT-另一種合併方式（使用 rebase） ","date":"2022-06-08","objectID":"https://loulazynote.github.io/posts/git-learning/:3:0","tags":["Git"],"title":"Git 學習筆記","uri":"https://loulazynote.github.io/posts/git-learning/"}]