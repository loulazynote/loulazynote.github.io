[{"categories":["C＃","Learning"],"content":"型別系統 概觀 ❗ 是強型別語言, 每個變數和常數都有型別 ❗ 在 C# bool 中無法轉換成 int 儲存在類型中的資訊可以包含下列 型別的變數需要的儲存空間 它可以代表的最大值和最小值 它所包含的成員 (方法、欄位、事件等等) 它繼承自的基底型別 interface (實作) 允許的作業類型 編譯器會將型別資訊視為中繼資料內嵌至可執行檔 通用語言執行平台 (CLR) 會在執行階段使用該中繼資料，以在它配置和回收記憶體時，進一步保證型別安全 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/csharpbasicpart1/:1:0","tags":["Basic Level","C＃"],"title":"C# 基礎複習Note(型別系統)","uri":"https://loulazynote.github.io/posts/csharpbasicpart1/"},{"categories":["C＃","Learning"],"content":"變數宣告中指定類型 ❗ 程式中宣告變數或常數時 必須指定其類型 ❗ 也能使用var關鍵字來讓編譯器推斷類型 // Declaration only string name; int studentId; AClass aclass; // Declaration with initializers (four examples) string studentName = \"Lou\"; string [] ClassList = {\"Elaine\",\"Louis\",\"Kyber\", \"Peter\",\"Jeff\",\"Mary\"} // 型別推斷 var query = ClassList.Where(q =\u003e q == studentName).First(); ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/csharpbasicpart1/:1:1","tags":["Basic Level","C＃"],"title":"C# 基礎複習Note(型別系統)","uri":"https://loulazynote.github.io/posts/csharpbasicpart1/"},{"categories":["C＃","Learning"],"content":"內建類型 C# 提供一組標準內建類型 整數 浮點值 布林運算式 文字字元 十進位值 string object ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/csharpbasicpart1/:1:2","tags":["Basic Level","C＃"],"title":"C# 基礎複習Note(型別系統)","uri":"https://loulazynote.github.io/posts/csharpbasicpart1/"},{"categories":["C＃","Learning"],"content":"自訂類型 可以使用 結構類型(struct)、 類別(Class) 、 interface(interface)、列舉 (enum) 和 記錄(record) 建構來建立您自己的自訂類型 當明確將專案參考新增至定義這些專案的元件時，其他專案才可用 編譯器在有該組件的參考之後，您可以針對在原始程式碼的那個組件中宣告的型別宣告變數 (或常數) .NET 類別庫本身是自訂類型的集合，可以在應用程式中使用 根據預設，類別庫中最常使用的型別可用於任何 C# 程式 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/csharpbasicpart1/:1:3","tags":["Basic Level","C＃"],"title":"C# 基礎複習Note(型別系統)","uri":"https://loulazynote.github.io/posts/csharpbasicpart1/"},{"categories":["C＃","Learning"],"content":"一般型別系統(CTS) 支援繼承原則 型別可以衍生自稱為「基底型別」的其他型別, 而衍生的型別會繼承 (有部份限制) 基底型別的方法、屬性和其他成員 基底型別同樣可以衍生自一些其他型別，所衍生的型別會繼承其繼承階層架構中兩個基底型別的成員 所有類型 最終衍生自單一基底類型，即 System.Object (C# 關鍵字：object) 這種統一型別階層架構稱為一般型別系統 (CTS) 一般型別系統 (CTS)中的每個型別都會定義為「實值型別」或「參考型別」 包括 .NET 類別庫中的所有自訂類型 使用者定義型別 使用 結構類型(struct) 關鍵字定義的類型為實值型別，所有內建的數數值型別都是 結構類型(struct) 使用 類別(class) 或 記錄(record) 關鍵字定義的類型是參考型別 參考型別和實值型別有不同的編譯時期規則和不同的執行階段行為 C# 9.0 新增 記錄型別 資料和行為是類別、結構或記錄 的成員 類別、結構或記錄宣告就像是用來在執行時間建立實例或物件的藍圖 //p 為 Person 的物件或執行個體 Person p = new Person(){ Name = \"Lou\", Age = 18 }; // 可以建立多個相同 Person 型別的執行個體，且每個執行個體在其屬性與欄位中都可以有不同的值 Person p2 = new Person(){ Name = \"Elaine\", Age = 18 }; // Person 的類別、結構 public class Person{ public string Name { get; set; } public int Age { get; set; } } 類別是參考型別 建立型別的物件時，指派物件的變數只會保留該記憶體的參考 當物件參考指派至新的變數時，新的變數會參考到原始物件 透過某個變數所做的變更會反映在其他變數中，因為它們都參考相同的資料 結構是實值型別 建立結構時，結構指派的變數會保留結構的實際資料 當結構指派給新的變數時，就會複製它 新的變數和原始變數會各自包含一份相同的資料，對一個複本所做的變更不會影響另一個複本 記錄類型可以是參考型別(record class)或實值型別(record struct) 類別 是用來建立更複雜的行為模型 類別通常會儲存在建立類別物件之後要修改的資料 結構 最適合小型資料結構 結構通常會儲存在建立結構之後不打算修改的資料 記錄類型 是具有其他編譯器合成成員的資料結構 記錄通常會儲存在建立物件之後不打算修改的資料 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/csharpbasicpart1/:1:4","tags":["Basic Level","C＃"],"title":"C# 基礎複習Note(型別系統)","uri":"https://loulazynote.github.io/posts/csharpbasicpart1/"},{"categories":["C＃","Learning"],"content":"值類型 實值型別衍生自 System.ValueType，該型別又衍生自 System.Object 實數值型別變數會直接包含其值 結構記憶體會內嵌配置於變數所宣告的任何內容中，實數值型別變數沒有個別的堆積配置或垃圾收集額外負荷 實值型別有兩種類別 實值型別為 密封, 無法從任何實值型別衍生型別 結構類型(struct) 列舉 (enum) // 內建的數數值型別是結構，而且其具有您可以存取的欄位和方法 // constant field on type byte. byte b = byte.MaxValue; // 宣告並指派值給它們，就像是簡單的非匯總類型 byte num = 0xA; int i = 5; char c = 'Z'; 使用 結構類型 來建立自訂實值型別: public struct Coords { public int x, y; public Coords(int p1, int p2) { x = p1; y = p2; } } 實值型別的另一個類別是 enum: // 列舉會定義一組具名的整數常數 public enum FileMode { CreateNew = 1, Create = 2, Open = 3, OpenOrCreate = 4, Truncate = 5, Append = 6, } ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/csharpbasicpart1/:1:5","tags":["Basic Level","C＃"],"title":"C# 基礎複習Note(型別系統)","uri":"https://loulazynote.github.io/posts/csharpbasicpart1/"},{"categories":["C＃","Learning"],"content":"參考型別 其定義為 類別(class), 記錄(record), 委派(delegate), 陣列(array)或 interface(interface)的類型是參考型別 參考型別完全支援繼承 當您建立類別時，可以繼承自未定義為 密封的任何其他interface或類別 其他類別可以繼承自您的類別，並覆寫您的虛擬方法 類別的建立和指派 Example: // 建立 MyClass myClass = new MyClass(); // 指派 MyClass myClass2 = myClass; interface(interface) 無法使用new 運算子直接具現化，請建立並指派實作 interface之類別的實例 Example: // 建立 MyClass myClass = new MyClass(); // 用現值宣告及賦值 IMyInterface myInterface = myClass; // 或 建立並賦值 給`interface` IMyInterface myInterface2 = new MyClass(); 所有陣列都是參考型別，即使其元素都是實值型別 陣列會隱含衍生自System.Array 類別，可以宣告並使用 搭配 C# 提供的簡化語法 // 宣告並初始化一個數字陣列 int[] nums = { 1, 2, 3, 4, 5 }; // 訪問 System.Array 的實例屬性 int len = nums.Length; ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/csharpbasicpart1/:1:6","tags":["Basic Level","C＃"],"title":"C# 基礎複習Note(型別系統)","uri":"https://loulazynote.github.io/posts/csharpbasicpart1/"},{"categories":["C＃","Learning"],"content":"泛型類型 類型可以使用一或多個 類型參數 來宣告，做為實際型別的預留位置 建立 類型的實例時，可以指定清單將包含的物件類型，例如 string： // \u003c\u003e即為泛型,此處為 包含string型別的清單 List\u003cstring\u003e stringList = new List\u003cstring\u003e(); stringList.Add(\"String example\"); // compile time error adding a type other than a string: stringList.Add(4); 使用型別參數(\u003cT\u003e)讓您能夠重複使用相同的類別來保存任何元素型別，而不需要將每個元素都轉換成 object 泛型集合類別稱為 強型別集合 ，因為編譯器知道集合元素的特定類型 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/csharpbasicpart1/:1:7","tags":["Basic Level","C＃"],"title":"C# 基礎複習Note(型別系統)","uri":"https://loulazynote.github.io/posts/csharpbasicpart1/"},{"categories":["C＃","Learning"],"content":"隱含型別、匿名型別和可為 Null 的實值型別 隱含型別 : 可以使用 var 隱含輸入區域變數（但不能輸入類別成員），其變數還是會在編譯時期收到型別，但其是由編譯器所提供的型別 匿名型別 : 針對不想要在外部方法 儲存或傳遞的簡單相關值集合，建立具名類型可能很不方便，為此，可以建立「匿名型別」 可為 Null 的實值型別 : 一般實值型別不能有 null 的值, 在類別後附加?後，允許建立可為 Null 的實值型別，例如， int? 是一種 int 類型，也可以有 值 null 可為 Null 的實值型別是泛型結構類型的 System.Nullable\u003cT\u003e 實例。 當您將資料傳入資料庫時，可為 Null 的實值型別特別有用，其中數值可能是 null ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/csharpbasicpart1/:1:8","tags":["Basic Level","C＃"],"title":"C# 基礎複習Note(型別系統)","uri":"https://loulazynote.github.io/posts/csharpbasicpart1/"},{"categories":["C＃","Learning"],"content":"編譯時間類型和執行時間類型 變數可以有不同的編譯時間和執行時間類型 編譯時間類型是原始程式碼中變數的宣告或推斷類型 執行時間類型是該變數所參考之實例的類型 這兩種類型通常相同,Example: string message = \"This is a string of characters\"; 在其他情況下，編譯時間類型不同,Example: // 編譯時間類型位於 object, 執行時間類型為 string object anotherMessage = \"This is another string of characters\"; // 編譯時間類型位於 IEnumerable\u003cchar\u003e, 執行時間類型為 string IEnumerable\u003cchar\u003e someCharacters =\"abcdefghijklmnopqrstuvwxyz\"; 變數的兩種類型不同，請務必瞭解編譯時間類型和執行時間類型套用的時間，而編譯時間類型會決定編譯器所採取的所有動作 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/csharpbasicpart1/:1:9","tags":["Basic Level","C＃"],"title":"C# 基礎複習Note(型別系統)","uri":"https://loulazynote.github.io/posts/csharpbasicpart1/"},{"categories":["C＃","Learning"],"content":"命名空間(宣告命名空間以組織類型) C# 程式設計大量使用命名空間的原因有兩個 .NET 會使用命名空間來組織其許多類別 // System 是命名空間，而 Console 是該命名空間中的類別 System.Console.WriteLine(\"Hello World!\"); // using關鍵字可用來讓完整名稱不需要 using System; Console.WriteLine(\"Hello World!\"); 宣告您自己的命名空間，將有助於在較大型的程式設計專案中控制類別和方法名稱的範圍 // 使用 namespace 關鍵字宣告命名空間 namespace SampleNamespace { class SampleClass { public void SampleMethod() { System.Console.WriteLine( \"SampleMethod inside SampleNamespace\"); } } } 命名空間的名稱必須是有效的 C# 識別碼名稱 // 從 C# 10 開始，您可以針對該檔案中定義的所有類型宣告命名空間 namespace SampleNamespace; class AnotherSampleClass { public void AnotherSampleMethod() { System.Console.WriteLine( \"SampleMethod inside SampleNamespace\"); } } ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/csharpbasicpart1/:2:0","tags":["Basic Level","C＃"],"title":"C# 基礎複習Note(型別系統)","uri":"https://loulazynote.github.io/posts/csharpbasicpart1/"},{"categories":["C＃","Learning"],"content":"命名空間概觀 命名空間具有下列屬性： 命名空間可組織大型程式碼專案 它們會使用.運算子來分隔 using 指示詞讓其不需要指定每個類別的命名空間名稱 global 命名空間是 “root” 命名空間：global::System 一律會參考 .NET System 命名空間 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/csharpbasicpart1/:2:1","tags":["Basic Level","C＃"],"title":"C# 基礎複習Note(型別系統)","uri":"https://loulazynote.github.io/posts/csharpbasicpart1/"},{"categories":["C＃","Learning"],"content":"類別 參考型別 : 定義為類別(Class)的類型是參考型別 執行時間，當宣告參考型別的變數時，該變數會包含值 null ，直到使用 new 運算子明確建立類別的實例，或指派可能已在其他地方建立之相容型別的物件 //Declaring an object of type MyClass. MyClass mc = new MyClass(); //Declaring another object of the same type, assigning it the value of the first object. MyClass mc2 = mc; 宣告類別 : 類別是使用 class 關鍵字來宣告，後面接著唯一識別碼 // class 關鍵字的前面會加上存取層級(public) // [access modifier] - [class] - [identifier] public class Customer { // 類別上的欄位、屬性、方法和事件統稱為「類別成員」 // Fields, properties, methods and events go here... } 建立物件 : 物件是根據類別的具體實體，而且有時稱為類別的執行個體 類別會定義一種類型的物件，但不是物件本身 // 使用 new 關鍵字來建立物件 // object1 是根據 Customer 之物件的參考 Customer object1 = new Customer(); // 可以建立物件參考，而根本不需要建立物件 Customer object2; 建立物件參考，如未參考上一個物件參考，嘗試透過這類參考來存取物件將會在執行時間失敗 //可以藉由建立新的物件，或為其指派現有的物件，來參考物件 Customer object3 = new Customer(); Customer object4 = object3; 類別繼承 : 類別完全支援「繼承」，這是物件導向程式設計的基礎特性 建立類別時，可以繼承自任何其他未定義為 sealed 的類別，而其他類別可以繼承自您的類別，並覆寫類別虛擬方法，且可以執行一或多個interface 使用「衍生」可完成繼承，這表示使用從中繼承資料和行為的「基底類別」來宣告類別。 附加冒號以及接著衍生類別名稱後面的基底類別名稱，以指定基底類別 類別宣告基底類別時，會繼承基底類別的所有成員，但建構函式除外 public class Manager : Employee { // Employee fields, properties, methods and events are inherited // New Manager fields, properties, methods and events go here... } 可用abstract 宣告類別 抽象類別包含具有簽章定義但沒有實作的抽象方法， 無法具現化抽象類別 它們僅用於實作抽象方法的衍生類別 與sealed類別相反，sealed不允許從它衍生其他類別 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/csharpbasicpart1/:3:0","tags":["Basic Level","C＃"],"title":"C# 基礎複習Note(型別系統)","uri":"https://loulazynote.github.io/posts/csharpbasicpart1/"},{"categories":["C＃","Learning"],"content":"記錄 C# 中的 記錄 是一種 類別 或 結構 ，可提供使用資料模型的特殊語法和行為 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/csharpbasicpart1/:4:0","tags":["Basic Level","C＃"],"title":"C# 基礎複習Note(型別系統)","uri":"https://loulazynote.github.io/posts/csharpbasicpart1/"},{"categories":["C＃","Learning"],"content":"使用記錄的時機 您想要定義相依于\"值相等“的資料模型 您想要定義物件為”不可變“的類型 實值相等 對於記錄而言，值相等表示如果類型相符且所有屬性和域值相符，則記錄類型的兩個變數會相等 對於其他參考型別（例如類別），相等表示 參考相等 並非所有資料模型都能搭配值相等來運作， 例如 : Entity Framework Core 取決於參考是否相等，以確保它只針對概念為一個實體的實體類型使用一個實例 ， 基於這個理由，記錄類型不適合用來做為 Entity Framework Core 中的實體類型 不變性 不可變的型別是一種可防止在物件具現化之後，變更該物件的任何屬性或域值 需要型別必須是安全線程，或者您是根據雜湊表中剩餘的雜湊碼而定時，永久性可能很有用(JWTToken、EnycrptPassword) 記錄提供簡潔的語法來建立和使用不可變的類型 永久性並不適用于所有資料案例， 例如 : Entity Framework Core不支援使用不可變的實體類型進行更新 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/csharpbasicpart1/:4:1","tags":["Basic Level","C＃"],"title":"C# 基礎複習Note(型別系統)","uri":"https://loulazynote.github.io/posts/csharpbasicpart1/"},{"categories":["C＃","Learning"],"content":"記錄與類別和結構有何不同 宣告和具現化類別或結構的相同語法可用於記錄 只需以關鍵字取代 class ，或使用 record struct 取代 struct record 同樣地，記錄類別也支援用來表示繼承關聯性的相同語法 記錄與類別的差異如下： 您可以使用 位置參數 ，利用不可變的屬性來建立和具現化型別 在類別中指出參考相等或不相等的相同方法和運算子 (例如 Object.Equals(Object) 和 ==) ，表示記錄中的 Object.Equals(Object) 不相等 可以用 Object.Equals(Object)檢測是否相等 您可以使用 運算式來建立不可變物件的複本，並在選取的屬性中包含新的值 記錄的 ToString方法會建立格式化的字串，以顯示物件的類型名稱以及其所有公用屬性的名稱和值 記錄可以 繼承自另一個記錄， 記錄無法繼承自類別，而且類別無法繼承自記錄 記錄結構與結構的不同之處在於 編譯器合成了相等的方法和 ToString 編譯器為位置記錄結構合成 Deconstruct 方法 Example // 定義公開記錄 public record Person(string FirstName, string LastName); public static void Main() { // 使用位置參數來宣告和具現化記錄 Person person = new(\"Nancy\", \"Davolio\"); // 列印類型名稱和屬性值 Console.WriteLine(person); // output: Person { FirstName = Nancy, LastName = Davolio } } // 定義公開記錄 public record Person(string FirstName, string LastName, string[] PhoneNumbers); public static void Main() { var phoneNumbers = new string[2]; // 使用位置參數來宣告和具現化記錄 Person person1 = new(\"Nancy\", \"Davolio\", phoneNumbers); Person person2 = new(\"Nancy\", \"Davolio\", phoneNumbers); Console.WriteLine(person1 == person2); // output: True person1.PhoneNumbers[0] = \"555-1234\"; // 位置及長度相同 Console.WriteLine(person1 == person2); // output: True // 不同的執行個體也不為 null Console.WriteLine(ReferenceEquals(person1, person2)); // output: False } // 定義公開記錄 public record Person(string FirstName, string LastName) { public string[] PhoneNumbers { get; init; } } public static void Main() { Person person1 = new(\"Nancy\", \"Davolio\") { PhoneNumbers = new string[1] }; Console.WriteLine(person1); // output: Person { FirstName = Nancy, LastName = Davolio, PhoneNumbers = System.String[] } // 使用 with 運算式來複製不可變的物件，並變更其中一個屬性 Person person2 = person1 with { FirstName = \"John\" }; Console.WriteLine(person2); // output: Person { FirstName = John, LastName = Davolio, PhoneNumbers = System.String[] } Console.WriteLine(person1 == person2); // output: False person2 = person1 with { PhoneNumbers = new string[1] }; Console.WriteLine(person2); // output: Person { FirstName = Nancy, LastName = Davolio, PhoneNumbers = System.String[] } Console.WriteLine(person1 == person2); // output: False // 因 new string[1]是一個新的object與原object不相同 person2 = person1 with { }; Console.WriteLine(person1 == person2); // output: True // 因複製了卻無改變其值 } ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/csharpbasicpart1/:4:2","tags":["Basic Level","C＃"],"title":"C# 基礎複習Note(型別系統)","uri":"https://loulazynote.github.io/posts/csharpbasicpart1/"},{"categories":["C＃","Learning"],"content":"介面(定義多個類型的行為) interface包含非抽象 類別(class) 或 結構(struct) 必須實作之相關功能群組的定義 interface可以定義 靜態(static) 必須具有實作的方法 從 C# 8.0 開始，interface可能會定義成員的預設實作 可以藉由使用interface，在類別中包含多個來源的行為(這項功能在 C# 中是很重要的，因為語言不支援類別的多重繼承) 如果要模擬結構繼承，則必須使用interface，因為它們實際上無法繼承自另一個結構或類別 使用 interface 關鍵字來定義interface: interface IEquatable\u003cT\u003e { bool Equals(T obj); } // 任何實作 IEquatable\u003cT\u003e `interface`的類別或結構，必須包含 Equals 方法的定義，該方法符合`interface`指定的簽章 interface的名稱必須是有效的 C# 識別碼名稱(依慣例，interface名稱以大寫字母 I 開頭) IEquatable\u003cT\u003e的定義沒有提供 Equals的實作 類別 或 結構 可以實現多個interface，但 類別 只能繼承自 單一類別 interface可以包含實作方法、屬性、事件、索引子，或這四個成員類型的任何組合 interface可能包含靜態建構函式、欄位、常數或運算子 C# 11 開始，不是欄位的interface成員可能是 static abstract interface不能包含實例欄位、實例建構函式或完成項(interface是無法被實例化的) interface成員預設為公用，而且可以明確指定協助工具修飾詞，EX: public 、 protected 、 internal 、 private 、 protected internal Or private protected 成員 private 必須具有預設實作 若要實作interface成員，實作類別的對應成員必須是公用、非靜態，且具有與interface成員相同的名稱和簽章 ❗ 當interface宣告靜態成員時，實作該interface的類型也可能宣告具有相同簽章的靜態成員， 這些是宣告成員的型別有所區別且是唯一識別的， 在型別中宣告的靜態成員 不會覆寫 interface中所宣告的靜態成員 ❗ class/struct繼承了interface必須實作該interface的所有成員，而不需要interface提供預設實作 如果基底類別實作interface，則衍生自基底類別的任何class/struct都會繼承該實作 interface也能繼承interface(一或多個) class/struct繼承了interface,而此interface如有繼承其他interface,則該class/struct必須實作出所有繼承鏈中所有interface的成員 該class/struct可能會隱含轉換成衍生interface或其任何基底interface class/struct可能透過基底類別包含interface多次，繼承或透過其他interface繼承的interface 只有在類別將interface宣告為類別 (class ClassName : InterfaceName) 定義的一部分時，類別只能提供interface實作一次 Example // 類別的屬性與索引子可以針對`interface`中定義的屬性或索引子定義額外的存取子 public class Car : IEquatable\u003cCar\u003e { // 實作`interface`的類別可以宣告具有 get 和 set 存取子的相同屬性 public string? Make { get; set; } public string? Model { get; set; } public string? Year { get; set; } // 屬性或索引子使用明確的實作，則存取子必須相符 // Implementation of IEquatable\u003cT\u003e interface public bool Equals(Car? car) { return (this.Make, this.Model, this.Year) == (car?.Make, car?.Model, car?.Year); } } 如果類別實作兩個具有相同簽章成員的介面，則在類別上實作該成員會造成這兩個介面都使用該成員進行實作 public interface IControl { void Paint(); } public interface ISurface { void Paint(); } public class SampleClass : IControl, ISurface { // Both ISurface.Paint and IControl.Paint call this method. public void Paint() { Console.WriteLine(\"Paint method in SampleClass\"); } } SampleClass sample = new SampleClass(); IControl control = sample; ISurface surface = sample; // The following lines all call the same method. sample.Paint(); control.Paint(); surface.Paint(); // Output: // Paint method in SampleClass // Paint method in SampleClass // Paint method in SampleClass 若要根據使用中的介面來呼叫不同的執行，可以明確地執行介面成員，明確的介面實作為僅透過指定介面呼叫的類別成員: public class SampleClass : IControl, ISurface { void IControl.Paint() { System.Console.WriteLine(\"IControl.Paint\"); } void ISurface.Paint() { System.Console.WriteLine(\"ISurface.Paint\"); } } 類別成員 IControl.Paint 只能透過 IControl 介面取得，ISurface.Paint 只能透過 ISurface 取得(這兩種方法都是分開的，而且不會直接在類別上使用) SampleClass sample = new SampleClass(); IControl control = sample; ISurface surface = sample; // The following lines all call the same method. //sample.Paint(); // Compiler error. control.Paint(); // Calls IControl.Paint on SampleClass. surface.Paint(); // Calls ISurface.Paint on SampleClass. // Output: // IControl.Paint // ISurface.Paint 若要同時執行這兩個介面，類別必須使用明確的實作為屬性 P 或方法 P （或兩者），以避免編譯器錯誤 interface ILeft { int P { get;} } interface IRight { int P(); } class Middle : ILeft, IRight { public int P() { return 0; } int ILeft.P { get { return 0; } } } 從 c # 8.0開始，可以為介面中所宣告的成員定義實作為 如果類別從介面繼承方法執行，則只能透過介面類別型的參考來存取該方法，繼承的成員不會顯示為公用介面的一部分 public interface IControl { void Paint() =\u003e Console.WriteLine(\"Default Paint method\"); } public class SampleClass : IControl { // Paint() is inherited from IControl. } var sample = new SampleClass(); //sample.Paint();// \"Paint\" isn't accessible. var control = sample as IControl; control.Paint(); // 任何實介面的類別 IControl 都可以覆寫預設 Paint 方法，例如公用方法，或做為明確的介面執行 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/csharpbasicpart1/:5:0","tags":["Basic Level","C＃"],"title":"C# 基礎複習Note(型別系統)","uri":"https://loulazynote.github.io/posts/csharpbasicpart1/"},{"categories":["C＃","Learning"],"content":"泛型 泛型會將型別參數的概念引進 .NET，讓您能夠設計類別和方法來延遲一或多個型別的規格，直到用戶端程式代碼宣告並具現化類別或方法為止 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/csharpbasicpart1/:6:0","tags":["Basic Level","C＃"],"title":"C# 基礎複習Note(型別系統)","uri":"https://loulazynote.github.io/posts/csharpbasicpart1/"},{"categories":["C＃","Learning"],"content":"藉由使用泛型型別參數 T ，您可以撰寫可供其他用戶端程式代碼使用的單一類別，而不會產生執行時間轉換或裝箱作業的成本或風險 // Declare the generic class. public class GenericList\u003cT\u003e { public void Add(T input) { } } class TestGenericList { private class ExampleClass { } static void Main() { // Declare a list of type int. GenericList\u003cint\u003e list1 = new GenericList\u003cint\u003e(); list1.Add(1); // Declare a list of type string. GenericList\u003cstring\u003e list2 = new GenericList\u003cstring\u003e(); list2.Add(\"\"); // Declare a list of type ExampleClass. GenericList\u003cExampleClass\u003e list3 = new GenericList\u003cExampleClass\u003e(); list3.Add(new ExampleClass()); } } 泛型類別和方法結合了重複使用性、型別安全和效率 泛型最常搭配在其上操作的集合和方法使用 System.Collections.Generic命名空間包含數個以泛型為基礎的集合類別 非泛型集合（例如 ArrayList ）不建議使用 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/csharpbasicpart1/:6:1","tags":["Basic Level","C＃"],"title":"C# 基礎複習Note(型別系統)","uri":"https://loulazynote.github.io/posts/csharpbasicpart1/"},{"categories":["C＃","Learning"],"content":"建立自訂的泛型型別和方法，簡單的泛型類別 當 GenericArray\u003cT\u003e 以具象類型具現化時 (例如具現化為 GenericArray\u003cint\u003e)，所出現的每個 T 都會以 int 取代 public class GenericArray\u003cT\u003e { private T[] array; public GenericArray(int size) { array = new T[size + 1]; } public T getItem(int index) { return array[index]; } public void setItem(int index, T value) { array[index] = value; } } 使用泛型 GenericArray 類別並輸出結果: class Tester { static void Main(string[] args) { //declaring an int array MyGenericArray\u003cint\u003e intArray = new MyGenericArray\u003cint\u003e(5); //setting values for (int c = 0; c \u003c 5; c++) { intArray.setItem(c, c*5); } //retrieving the values for (int c = 0; c \u003c 5; c++) { Console.Write(intArray.getItem(c) + \" \"); } Console.WriteLine(); //declaring a character array MyGenericArray\u003cchar\u003e charArray = new MyGenericArray\u003cchar\u003e(5); //setting values for (int c = 0; c \u003c 5; c++) { charArray.setItem(c, (char)(c+97)); } //retrieving the values for (int c = 0; c\u003c 5; c++) { Console.Write(charArray.getItem(c) + \" \"); } Console.WriteLine(); Console.ReadKey(); } } //OutPut: //0 5 10 15 20 //a b c d e 泛型方法 Example 2: class Program { static void Swap\u003cT\u003e(ref T lhs, ref T rhs) { T temp; temp = lhs; lhs = rhs; rhs = temp; } static void Main(string[] args) { int a, b; char c, d; a = 10; b = 20; c = 'I'; d = 'V'; //display values before swap: Console.WriteLine(\"Int values before calling swap:\"); Console.WriteLine(\"a = {0}, b = {1}\", a, b); Console.WriteLine(\"Char values before calling swap:\"); Console.WriteLine(\"c = {0}, d = {1}\", c, d); //call swap Swap\u003cint\u003e(ref a, ref b); Swap\u003cchar\u003e(ref c, ref d); //display values after swap: Console.WriteLine(\"Int values after calling swap:\"); Console.WriteLine(\"a = {0}, b = {1}\", a, b); Console.WriteLine(\"Char values after calling swap:\"); Console.WriteLine(\"c = {0}, d = {1}\", c, d); Console.ReadKey(); } } /// OutPut: /// Int values before calling swap: /// a = 10, b = 20 /// Char values before calling swap: /// c = I, d = V /// Int values after calling swap: /// a = 20, b = 10 /// Char values after calling swap: /// c = V, d = I ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/csharpbasicpart1/:6:2","tags":["Basic Level","C＃"],"title":"C# 基礎複習Note(型別系統)","uri":"https://loulazynote.github.io/posts/csharpbasicpart1/"},{"categories":["C＃","Learning"],"content":"泛型總覽 使用泛型型別以最佳化程式碼重複使用、型別安全和效能 泛型的最常見用法是建立集合類別 .NET 類別庫包含命名空間中 System.Collections.Generic 有數個泛型集合類別，應該盡可能使用泛型集合，而不是命名空間中 System.Collections 的類別 ArrayList 可以建立自己的泛型介面、類別、方法、事件和委派 泛型類別可限制為允許存取特定資料類型上的方法 泛型資料類型中所使用的類型相關資訊，可在執行階段透過反映取得 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/csharpbasicpart1/:6:3","tags":["Basic Level","C＃"],"title":"C# 基礎複習Note(型別系統)","uri":"https://loulazynote.github.io/posts/csharpbasicpart1/"},{"categories":["C＃","Learning"],"content":"匿名類型 匿名類型提供一個便利的方法，將一組唯讀屬性封裝成一個物件，而不需要事先明確定義類型 類型名稱會由編譯器產生，並且無法在原始程式碼層級使用 每個屬性的類型會由編譯器推斷 // 以兩個名為 Amount 和 Message 的屬性初始化的匿名類型 var v = new { Amount = 108, Message = \"Hello\" }; // Rest the mouse pointer over v.Amount and v.Message in the following // statement to verify that their inferred types are int and string. Console.WriteLine(v.Amount + v.Message); 匿名型別通常用於查詢運算式的select子句中 ，以從來源序列中的每個物件傳回屬性的子集 匿名類型包含一個或多個公用唯讀屬性 其他類型的類別成員 (例如方法或事件) 則無效 用於初始化屬性的運算式不可以是 null、匿名函式或指標類型 var productQuery = from prod in products select new { prod.Color, prod.Price }; foreach (var v in productQuery) { Console.WriteLine(\"Color={0}, Price={1}\", v.Color, v.Price); } 可以使用 var 將變數宣告為隱含型別區域變數， 由於只有編譯器可以存取匿名類型的基本名稱，因此無法在變數宣告中指定類型名稱 // 合併隱含類型區域變數和隱含類型陣列，以建立匿名類型項目的陣列 var anonArray = new[] { new { name = \"apple\", diam = 4 }, new { name = \"grape\", diam = 1 }}; 匿名型別是class衍生自object的型別，而且不能轉換成除了object以外的任何類型 如果組件中有兩個或多個匿名物件初始設定式，指定了順序相同並具有相同名稱和類型的屬性序列，編譯器會將這些物件視為相同類型的執行個體 這些物件會共用編譯器產生的相同類型資訊 匿名型別以 運算式的形式支援非破壞性變化，這可建立匿名型別的新實例，其中一或多個屬性具有新的值 var apple = new { Item = \"apples\", Price = 1.35 }; var onSale = apple with { Price = 0.79 }; Console.WriteLine(apple); Console.WriteLine(onSale); 無法將欄位、屬性、事件或方法的傳回類型，宣告為具有匿名類型 無法將方法、屬性、建構函式或索引子的型式參數宣告為具有匿名類型 若要傳遞匿名型別或包含匿名型別的集合，做為方法的引數，可以將參數宣告為類型 object ❗ 針對匿名型別使用 object 會破壞強型別的目的 ❗ 如果必須在方法界限外儲存或傳遞查詢結果，請考慮使用一般具名結構或類別來取代匿名類型 匿名類型上的 Equals 和 GetHashCode 方法會以屬性的 Equals 和 GetHashCode 方法來定義，相同匿名類型的兩個執行個體僅在其所有屬性都相等時，這兩個執行個體才相等 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/csharpbasicpart1/:7:0","tags":["Basic Level","C＃"],"title":"C# 基礎複習Note(型別系統)","uri":"https://loulazynote.github.io/posts/csharpbasicpart1/"},{"categories":["C＃","Learning"],"content":"參考資料 MSDN - C# 文件 Gitbook - C#教學 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/csharpbasicpart1/:8:0","tags":["Basic Level","C＃"],"title":"C# 基礎複習Note(型別系統)","uri":"https://loulazynote.github.io/posts/csharpbasicpart1/"},{"categories":["Kerberos"],"content":"Keberos 概述 Kerberos 是一種計算機網絡認證協議 它允許某實體在非安全網絡環境下通信 向另一個實體以一種安全的方式證明自己的身份 Kerberos 伺服器本身稱為鑰匙分配中心或 KDC 一般來說，KDC 除了發放票據與金鑰之外，同時也負責身份驗證的功能 (Authentication Server, AS) Kerberos 使用 Needham-Schroeder 協議作為基礎 它使用一個由兩個獨立的邏輯部分： 認證伺服器 票據授權伺服器 組成\"可信賴的第三方\" Kerberos 工作在用於證明用戶身份的\"票據\"基礎上 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/:1:0","tags":["Kerberos"],"title":"Single Sign On with Kerberos","uri":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/"},{"categories":["Kerberos"],"content":"Needham-Schroeder Needham 與 Schroeder 於 1978 年提出一種『多重盤問與回應』的認證協定，它不但可以避免重播攻擊，也可以解決相互認證的問題。 而協議的安全主要依賴於參加者對時間的鬆散同步和短周期的叫做 Kerberos 票據的認證聲明 下面為 Kerberos 內容名詞縮寫及解釋： AS（Authentication Server）: 認證伺服器 KDC（Key Distribution Center）: 鑰匙分配中心 TGS（Ticket Granting Server）: 票據授權伺服器 TGT（Ticket Granting Ticket）: 票據授權票據，票據的票據 ST（Service Ticket）: 服務門票 SS（Service Server）: 特定服務提供端 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/:1:1","tags":["Kerberos"],"title":"Single Sign On with Kerberos","uri":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/"},{"categories":["Kerberos"],"content":"認證伺服器（Authentication Server/AS） 相當於『鑰匙分配中心』（KDC） 管理每一個使用者的主密鑰（或稱共享密鑰） 欲加入的使用者都必須向 AS 伺服器申請帳戶並取得主密鑰 網路上任何一個使用者登入系統時，都會向認證中心取得通行證（Pass Book 或 TGT 票），有了通行證便可以在網路上索取所要的資源 簡單來說就是 驗證 Client 端的身份（確定你是身份證上的本人） 驗證通過就會給一張票證授予票證（Ticket Granting Ticket/TGT）給 Client ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/:1:2","tags":["Kerberos"],"title":"Single Sign On with Kerberos","uri":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/"},{"categories":["Kerberos"],"content":"鑰匙分配中心(Key Distribution Center/KDC) KDC 是一台伺服器，它與每位註冊的使用者分享不同的的私密對稱金鑰，當使用者第一次使用註冊時，這支金鑰可以利用人工輸入到伺服器 KDC 知道每位使用者的私密金鑰，而每位使用者可以使用此金鑰與 KDC 進行安全通訊 以 Star 星狀方式配置，從中心集中管理對外分散的 Key 採用 KDC 的管理方式可以減少 Key 的數量，它將所有的 Key 集中到一個中心點因此降降低了 Key 的數目，n 個 node 只需要 n 把 Key 即可，以 5 個點的拓樸系統來看只需要 5 把 Key，因此大大的降低系統對 Key 的需求 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/:1:3","tags":["Kerberos"],"title":"Single Sign On with Kerberos","uri":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/"},{"categories":["Kerberos"],"content":"票據授權伺服器（Ticket Granting Server/TGS） TGS 管理網路上所有服務伺服器，並紀錄所有服務伺服器的秘密鑰匙 當有新的伺服器加入或退出時，都必須向 TGS 伺服器申請 而且某一秘密鑰匙也只有 TGS 伺服器和該服務伺服器兩者所擁有，因此 TGS 伺服器必須管理網路上所有伺服器的秘密鑰匙 使用者如要存取服務伺服器上資源時，必須向 TGS 提出它的身份證明，即 TGT 門票。 TGT 門票是經過 TGS 伺服器的秘密鑰匙加密，因此只有 TGS 伺服器能觀察門票的內容，別人無法仿冒 TGS 伺服器驗證完使用者的通行證後，再發給使用者有關使用者本身和所欲要求的服務伺服器的『服務門票』（Service Ticket, ST） 有了 ST 門票之後，使用者才可以到服務伺服器上存取資源，ST 門票同時包含了會議鑰匙 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/:1:4","tags":["Kerberos"],"title":"Single Sign On with Kerberos","uri":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/"},{"categories":["Kerberos"],"content":"票據授權票據，票據的票據（Ticket Granting Ticket/TGT） 此票是由 AS 伺服器發給客戶端的身分證明使用；使用者可以持此票向 TGS 伺服器申請通往某一伺服器的請求 Kerberos 協議將 TGT 的使用設計成可以避免經常向用戶詢問密碼（Kerberos 用來派生主密鑰的密碼）或將主密鑰存儲在工作站上 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/:1:5","tags":["Kerberos"],"title":"Single Sign On with Kerberos","uri":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/"},{"categories":["Kerberos"],"content":"服務門票（Service Ticket/ST） 當使用者出示 TGT 門票，向 TGS 伺服器要求前往某一伺服器 如果 TGS 伺服器同意其要求時，則發給所要求伺服器的 ST 門票給使用者，使用者持此票即可要求該伺服器提供服務 ST（Service Ticket）也有資料稱為 TGS Ticket ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/:1:6","tags":["Kerberos"],"title":"Single Sign On with Kerberos","uri":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/"},{"categories":["Kerberos"],"content":"Keberos 流程關係 消息 A：使用 Client/User 的秘密密鑰加密的 Client/TGS Session Key。 消息 B：使用 TGS 的密鑰加密的票證授予票證。 消息 C：由消息 B 的 TGT 和所請求服務的 ID 組成。 消息 D：使用 Client/TGS 會話密鑰加密的身份驗證器。 消息 E：使用服務的秘密密鑰加密的 Client 到 Server 票證。 消息 F：使用 Client/TGS Session Key 加密的 Client/Server Session Key。 消息 G：一個新的身份驗證器，其中包括 Client ID，時間戳記，並使用 Client/Server Session Key 進行了加密。 消息 H：在 Client 的身份驗證器中找到的時間戳已使用 Client/Server Session Key 進行了加密。 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/:1:7","tags":["Kerberos"],"title":"Single Sign On with Kerberos","uri":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/"},{"categories":["Kerberos"],"content":"名詞解釋 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/:2:0","tags":["Kerberos"],"title":"Single Sign On with Kerberos","uri":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/"},{"categories":["Kerberos"],"content":"Principal Kerberos principal（又稱為主體）用於在 kerberos 加密系統中標記一個唯一的身份 主體可以是用戶（如 louis）或服務（如 namenode 或 hive） 根據約定，主體名稱分為三個部分： 主名稱、實例和領域。 例如，典型的 Kerberos 主體可以是 louis/admin@EXAMPLE.COM ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/:2:1","tags":["Kerberos"],"title":"Single Sign On with Kerberos","uri":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/"},{"categories":["Kerberos"],"content":"keytab keytab 是包含 principals 和加密 principal key 的文件 \u003e keytab 用於將 SSO 帶到未加入 AD domain 的應用程序 keytab 文件對於每個 host 是唯一的，因為 key 中包含 hostname keytab 文件用於不需要人工交互和保存純文本密碼，實現到 kerberos 上驗證一個主機上的 principal 因為 Server 上可以訪問 keytab 文件即可以以 principal 的身份通過 kerberos 的認證，所以，keytab 文件應該被妥善保存，應該只有少數的用戶可以訪問 如何產生 Keytab? 使用實用程序 KTPASS.EXE 它是 RSAT 的一部分，如果啟用了 Active Directory 目錄服務工具將顯示在 RSAT 中 ktpass /out app1.keytab /princ http/app1.verenatex.com@verenatex.com /mapuser app1 /crypto AES256-SHA1 /ptype KRB5_NT_PRINCIPAL /pass Password2 /target vdc01.verenatex.com /out 指定輸出文件的名稱，如 app1.keytab /princ 指定 userPrincipalName 以及將其添加到對映帳戶的 servicePrincipalName 的值 /mapuser 是將為其生成 Keytab 的帳戶 /crypto 是用於 Keytab 的加密類型，此處為 AES256-SHA1 /ptype 通常應使用 KRB5_NT_PRINCIPAL，除非應用程序文檔另有說明 /pass 是對應帳戶的新密碼（默認情況下，它將執行密碼重置操作） /target 用於指示將查詢哪個 domain 控制器(it is optional, but can be useful if you have more than one domain in your forest) ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/:2:2","tags":["Kerberos"],"title":"Single Sign On with Kerberos","uri":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/"},{"categories":["Kerberos"],"content":"Single Sign-On (SSO) 單一登錄（SSO）協議（Kerberos，SAML，OpenID 等）允許用戶使用單個 ID 和密碼來訪問不同的應用程序。用戶登錄以獲得對連接系統的訪問權限，或者使用輕型目錄訪問協議（LDAP）和（目錄）服務器上存儲的 LDAP 數據庫來完成訪問。 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/:3:0","tags":["Kerberos"],"title":"Single Sign On with Kerberos","uri":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/"},{"categories":["Kerberos"],"content":"SPNEGO SPNEGO 代表\"簡單和受保護的 GSS_API 協商機制\"，用於擴展基於 Kerberos 的 SSO 環境以用於 Web Application，因為 SPNEGO 被設計用於 Client Server 桌面環境，通常不用於 Web Application 或簡易 Client 環境 Spnego 是一種與身份驗證器協商使用哪種安全協議的機制 例如 Kerberos，NTLM，摘要或 Basic.5t6 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/:4:0","tags":["Kerberos"],"title":"Single Sign On with Kerberos","uri":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/"},{"categories":["Kerberos"],"content":"SPN(Service Principal Names) 服務主體名稱 (SPN) 是服務實例的唯一標識符 Kerberos 身份驗證使用 SPN 將服務實例與服務登錄帳戶關聯 這允許用戶端應用程式請求服務對帳戶進行身份驗證，即使客戶端沒有帳戶名稱 如果在整個林中的電腦上安裝多個服務實例，則每個實例必須有自己的 SPN 如果用戶端可能使用多個名稱進行身份驗證，則給定的服務實例可以有多個 SPN 例如，SPN 始終包含運行服務實例的主機的名稱，因此服務實例可能會為其主機的每個名稱或別名註冊 SPN 在 Kerberos 身份驗證服務可以使用 SPN 對服務進行身份驗證之前，必須在服務實例用於登錄的帳戶物件上註冊 SPN 給定的 SPN 只能在一個帳戶上註冊 對於 Win32 服務，服務安裝程式在安裝服務實例時指定登錄帳戶 然後，安裝程式組成 SPN，並將它們作為活動目錄域服務中的帳戶物件的屬性編寫 如果服務實例的登錄帳戶發生更改，則必須在新帳戶下重新註冊 SPN 當用戶端想要連接到服務時，它會查找服務的實例，為該實例編寫 SPN，連接到該服務，並顯示用於服務的 SPN 進行身份驗證 Client 上的 Application（例如 Browser）嘗試訪問 Web Server 上的受保護頁面 Server 響應要求授權 Application 從 Kerberos KDC 請求 Service ticket 獲得 ticket 後，Application 將其包裝為 SPNEGO 格式的請求，然後通過 Browser 將其發送回 Web Application 執行已部署的 Web Application 的 web container（Tomcat、JBoss EAP 等）對請求進行解包並驗證 ticket 認證成功後，將授予訪問權限 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/:5:0","tags":["Kerberos"],"title":"Single Sign On with Kerberos","uri":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/"},{"categories":["Kerberos"],"content":"Browser 如何透過 Kerberos 進行身分驗證 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/:6:0","tags":["Kerberos"],"title":"Single Sign On with Kerberos","uri":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/"},{"categories":["Kerberos"],"content":"循序圖 User 登錄 Windows，並通過 KDC 進行了身份驗證(對於 Windows，KDC 將是主域控制器) OS 為 User 接收一個 TGT token 當 User 嘗試連接到 Tomcat 服務器(或其他 web container)時，將協商身份驗證機制(紅字原文: the authentication mechanism is negotiated) User 的 token 被傳遞給 Tomcat，然後 Tomcat 通過 KDC 對其進行驗證 驗證 User 身份後，Tomcat 隨後從 LDAP 服務器中檢索其角色（在 Windows 中為 Active Directory，這是一種專門處理諸如用戶名和密碼之類的身份信息的數據庫） 並確定他是否有權訪問（Response 200 OK）他在服務器上請求的資源。 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/:6:1","tags":["Kerberos"],"title":"Single Sign On with Kerberos","uri":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/"},{"categories":["Kerberos"],"content":"參考資料 Setting up Kerberos Authentication for a Website in IIS Single Sign On with Kerberos Kerberos Wikipedia 鳥哥的 Linux 私房菜 看完您如果還不明白 Kerberos 原理，算我輸 翻轉工作室-資訊與網路安全技術：第十四章 Kerberos 認證系統 The Secret Security Wiki Kerberos.NET Guide To Setup Kerberos Single Sign-On (SSO) 瞭解 keytab 需求 宅學習 如何使用 Spn，當您在 [網際網路資訊服務上設定 裝載的 Web 應用程式] Microsoft Developer-Service Principal Names 瞭解 keytab 需求 All you need to know about Keytab files ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/:7:0","tags":["Kerberos"],"title":"Single Sign On with Kerberos","uri":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/"},{"categories":["C＃","Maintain","Asp.Net"],"content":"Filter Filter 的作用是在 Action 執行前或執行後做一些加工處理 Authorization Filter： Authorization 是五種 Filter 中優先序最高的，通常用於驗證 Request 合不合法，不合法後面就直接跳過。 Resource Filter： Resource 是第二優先，會在 Authorization 之後，Model Binding 之前執行。通常會是需要對 Model 加工處裡才用。 Action Filter： 最容易使用的 Filter，封包進出都會經過它，使用上沒什麼需要特別注意的。跟 Resource Filter 很類似，但並不會經過 Model Binding。 Exception Filter： 異常處理的 Exception。 Result Filter： 當 Action 完成後，最終會經過的 Filter。 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/mvc5_meta/:1:0","tags":["Asp.Net MVC"],"title":"MVC 5 filter","uri":"https://loulazynote.github.io/posts/mvc5_meta/"},{"categories":["C＃","Maintain","Asp.Net"],"content":"運作方式 ASP .NET Core 的每個 Request 都會先經過已註冊的 Middleware 接著才會執行 Filter，除了會依照上述的順序外，同類型的 Filter 預設都會以先進後出的方式處裡封包。 Response 在某些 Filter 並不會做處理，會值接 Bypass。Request 及 Response 的運作流程如下圖： 黃色箭頭是正常情況流程 灰色箭頭是異常處理流程 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/mvc5_meta/:1:1","tags":["Asp.Net MVC"],"title":"MVC 5 filter","uri":"https://loulazynote.github.io/posts/mvc5_meta/"},{"categories":["C＃","Maintain","Asp.Net"],"content":"參考資料 John Wu’s [鐵人賽 Day14] ASP.NET Core 2 系列 - Filters ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/mvc5_meta/:2:0","tags":["Asp.Net MVC"],"title":"MVC 5 filter","uri":"https://loulazynote.github.io/posts/mvc5_meta/"},{"categories":["Learning"],"content":"位於索引中的檔案 : Tracked files(追蹤的檔案) 不再索引內的檔案 : Untracked files(未被追蹤的檔案) working tree 是工作目錄 只要 被索引中的檔案內容 跟 工作目錄中的檔案內容一致 就會被稱為一個 “Stage“狀態 只要 被索引中的檔案內容 跟 工作目錄中的檔案內容不一致 就會被稱為一個 “Unstage“狀態 ","date":"2022-06-08","objectID":"https://loulazynote.github.io/posts/git-learning/:0:0","tags":["Git"],"title":"Git 學習筆記","uri":"https://loulazynote.github.io/posts/git-learning/"},{"categories":["Learning"],"content":"Git 指令 Command: git -m = message init = 建立 add = 加入 GIT 索引 rm = 刪除 status = 看目前狀態 ","date":"2022-06-08","objectID":"https://loulazynote.github.io/posts/git-learning/:1:0","tags":["Git"],"title":"Git 學習筆記","uri":"https://loulazynote.github.io/posts/git-learning/"},{"categories":["Learning"],"content":"git diff 顯示差異 HEAD = 比對變更與目前最新版的變更差異 -cached = 索引裡的變更與本地儲存庫最新的變更差異 --binary = 比對二進位檔案差異 --name-only = 比對工作目錄檔案,列出檔案名稱 --name-status = 列出工作目錄及索引之間有多少檔案是被異動的 git diff 'src-commit' 'tgt-commit' commit 與 commit 比較差異 git diff 'commit' 與目標 commit 差異 ","date":"2022-06-08","objectID":"https://loulazynote.github.io/posts/git-learning/:1:1","tags":["Git"],"title":"Git 學習筆記","uri":"https://loulazynote.github.io/posts/git-learning/"},{"categories":["Learning"],"content":"git reset 重置索引 -p = 選取索引中的那些變更有哪些內容要從索引中移除 HEAD = 重置索引及分支(加 ~1 是恢復前一版本,以此類推) --mixed = 重置 HEAD 及索引(預設值) --hard = 重置 HEAD,索引及工作目錄 --hard ORIG_HEAD = 回復前版本(永遠回復 reset 之前的版本) ","date":"2022-06-08","objectID":"https://loulazynote.github.io/posts/git-learning/:1:2","tags":["Git"],"title":"Git 學習筆記","uri":"https://loulazynote.github.io/posts/git-learning/"},{"categories":["Learning"],"content":"git revert 還原歷史上的版本，做相反的 commit -h = help 列出功能 --abort = 取消 --continue = 繼續 --quit = 停止 ","date":"2022-06-08","objectID":"https://loulazynote.github.io/posts/git-learning/:1:3","tags":["Git"],"title":"Git 學習筆記","uri":"https://loulazynote.github.io/posts/git-learning/"},{"categories":["Learning"],"content":"git clone 下載遠端儲存庫 git clone --no-checkout 'URL' 'Filename' 會以 filename 為主並且不做 checkout git clone --bare 'url' 把儲存庫的本身下載下來 ","date":"2022-06-08","objectID":"https://loulazynote.github.io/posts/git-learning/:1:4","tags":["Git"],"title":"Git 學習筆記","uri":"https://loulazynote.github.io/posts/git-learning/"},{"categories":["Learning"],"content":"git log 看紀錄 --oneline = 短的 log 版本 --oneline --graph = log 版本+線圖可加 “-數字” 以顯示筆數 git log --oneline --graph --all -10 全部的歷史資料取 10 筆 ","date":"2022-06-08","objectID":"https://loulazynote.github.io/posts/git-learning/:1:5","tags":["Git"],"title":"Git 學習筆記","uri":"https://loulazynote.github.io/posts/git-learning/"},{"categories":["Learning"],"content":"git reflog 會記錄工作目錄底下做過的每一次的版控紀錄 ","date":"2022-06-08","objectID":"https://loulazynote.github.io/posts/git-learning/:1:6","tags":["Git"],"title":"Git 學習筆記","uri":"https://loulazynote.github.io/posts/git-learning/"},{"categories":["Learning"],"content":"git checkout 取出/取回 -- 'name' = 從索引裡面把 name 檔案的內容整個複製回工作目錄 --orphan = 建立全新分支且沒有 parents checkout -b \"Filename\" 可以新增分支後切換 ","date":"2022-06-08","objectID":"https://loulazynote.github.io/posts/git-learning/:1:7","tags":["Git"],"title":"Git 學習筆記","uri":"https://loulazynote.github.io/posts/git-learning/"},{"categories":["Learning"],"content":"git switch 切換分支 ","date":"2022-06-08","objectID":"https://loulazynote.github.io/posts/git-learning/:1:8","tags":["Git"],"title":"Git 學習筆記","uri":"https://loulazynote.github.io/posts/git-learning/"},{"categories":["Learning"],"content":"git clean 清除工作目錄 -f = 強制刪除 -d = 刪除整個工作目錄 -x = 執行清除任務,並忽略.gitignore 設定 -n = 看那些檔案會被清除 ","date":"2022-06-08","objectID":"https://loulazynote.github.io/posts/git-learning/:1:9","tags":["Git"],"title":"Git 學習筆記","uri":"https://loulazynote.github.io/posts/git-learning/"},{"categories":["Learning"],"content":"git stash 暫存工作目錄的變更 save 'message' = 暫存 pop = 取回暫存 ","date":"2022-06-08","objectID":"https://loulazynote.github.io/posts/git-learning/:1:10","tags":["Git"],"title":"Git 學習筆記","uri":"https://loulazynote.github.io/posts/git-learning/"},{"categories":["Learning"],"content":"git branch 查看分支/新增分支 -d = 刪除分支(只能刪除已經合併的分支) -D = 強制刪除分支 -r = 列出所有遠端追蹤分支 -a = 列出所有遠端+本地分支 git branch --merged 列出所有已合併過的分支 git branch --no-merged 列出所有未合併過的分支 git branch --merged | egrep -v \"(^\\*|master|develop)\" | xargs git branch -d 刪除所有已合併過的分支(CMD/Powershell 不可用) ","date":"2022-06-08","objectID":"https://loulazynote.github.io/posts/git-learning/:1:11","tags":["Git"],"title":"Git 學習筆記","uri":"https://loulazynote.github.io/posts/git-learning/"},{"categories":["Learning"],"content":"git merge 合併分支 --ff = 快轉合併(預設) --no-ff = 非快轉合併 --ff-only = 僅有快轉合併 --no-commit = 不提交的合併 --abort = 放棄合併 --squash = 壓縮後合併(不可以與關閉快轉機制一起使用,且不會有合併線圖出現) git merge --no-ff --no-commit 'branchName' 合併可以不 commit ","date":"2022-06-08","objectID":"https://loulazynote.github.io/posts/git-learning/:1:12","tags":["Git"],"title":"Git 學習筆記","uri":"https://loulazynote.github.io/posts/git-learning/"},{"categories":["Learning"],"content":"git rebase 'commit_id' 重訂基底合併 -i --continue = 繼續 --skip = --abort = 取消 ","date":"2022-06-08","objectID":"https://loulazynote.github.io/posts/git-learning/:1:13","tags":["Git"],"title":"Git 學習筆記","uri":"https://loulazynote.github.io/posts/git-learning/"},{"categories":["Learning"],"content":"git cherry-pick 正向挑選合併 --continue = 繼續 --quit = 停止 --abort = 取消 ","date":"2022-06-08","objectID":"https://loulazynote.github.io/posts/git-learning/:1:14","tags":["Git"],"title":"Git 學習筆記","uri":"https://loulazynote.github.io/posts/git-learning/"},{"categories":["Learning"],"content":"git push 推送至遠端 --all = 全部分支推送 git push -u origin master 將本地分支(master)與遠端分支(origin)建立連結 git push origin --delete ‘branchName’ 刪除遠端分支(要先把本地刪除) ","date":"2022-06-08","objectID":"https://loulazynote.github.io/posts/git-learning/:1:15","tags":["Git"],"title":"Git 學習筆記","uri":"https://loulazynote.github.io/posts/git-learning/"},{"categories":["Learning"],"content":"git fetch 將遠端儲存庫的變更下載回來 --prune 將遠端已刪除的分支剪除 ","date":"2022-06-08","objectID":"https://loulazynote.github.io/posts/git-learning/:1:16","tags":["Git"],"title":"Git 學習筆記","uri":"https://loulazynote.github.io/posts/git-learning/"},{"categories":["Learning"],"content":"git pull 將遠端儲存庫拉下來 pull = git fetch + git merge git pull --rebase = git fetch + git rebase ","date":"2022-06-08","objectID":"https://loulazynote.github.io/posts/git-learning/:1:17","tags":["Git"],"title":"Git 學習筆記","uri":"https://loulazynote.github.io/posts/git-learning/"},{"categories":["Learning"],"content":"git remote 遠端 -v = 列出網址 -h = remote 的 help set-url = 更改網址 git remote set-url origin 'new url' 將舊網址改成新網址 ","date":"2022-06-08","objectID":"https://loulazynote.github.io/posts/git-learning/:1:18","tags":["Git"],"title":"Git 學習筆記","uri":"https://loulazynote.github.io/posts/git-learning/"},{"categories":["Learning"],"content":"git commit 建立版本 ","date":"2022-06-08","objectID":"https://loulazynote.github.io/posts/git-learning/:1:19","tags":["Git"],"title":"Git 學習筆記","uri":"https://loulazynote.github.io/posts/git-learning/"},{"categories":["Learning"],"content":"git apply 套用版本(進版) --check = 確認檔案 --reverse = 退版(簡寫-R) ","date":"2022-06-08","objectID":"https://loulazynote.github.io/posts/git-learning/:1:20","tags":["Git"],"title":"Git 學習筆記","uri":"https://loulazynote.github.io/posts/git-learning/"},{"categories":["Learning"],"content":"git config GIT 的設定 加上 --global 可以設定 core.quotepath = 改 false 可顯示中文 core.editor = 查看目前編輯器 git 只能顯示 ASCII 的字元 git bash 以外的環境要改中文 set LC_ALL=C.UTF-8 更改環境變數 (永久儲存) setx LC_ALL C.UTF-8 MAC/Linux export LC_ALL=C.UTF-8 ","date":"2022-06-08","objectID":"https://loulazynote.github.io/posts/git-learning/:1:21","tags":["Git"],"title":"Git 學習筆記","uri":"https://loulazynote.github.io/posts/git-learning/"},{"categories":["Learning"],"content":"衝突問題 顯示訊息: content = 內容衝突 建議用手動合併 ","date":"2022-06-08","objectID":"https://loulazynote.github.io/posts/git-learning/:2:0","tags":["Git"],"title":"Git 學習筆記","uri":"https://loulazynote.github.io/posts/git-learning/"},{"categories":["Learning"],"content":"參考資料 為自己學 GIT-另一種合併方式（使用 rebase） ","date":"2022-06-08","objectID":"https://loulazynote.github.io/posts/git-learning/:3:0","tags":["Git"],"title":"Git 學習筆記","uri":"https://loulazynote.github.io/posts/git-learning/"}]