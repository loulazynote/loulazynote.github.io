[{"categories":[""],"content":"1. 簡介 AZ-900 Azure 基礎知識測驗 評分規則及配重 考試規則: 測驗時間 : 60 分鐘 考題類型 : 選擇題(無實作) 比重如下圖 2. Azure 雲端概念(Cloud Concepts) ","date":"2022-06-10","objectID":"https://loulazynote.github.io/note/20220104_azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/:0:0","tags":["Azure"],"title":"MircoSoft Azure Fundamentals 認證課程(AZ-900)","uri":"https://loulazynote.github.io/note/20220104_azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/"},{"categories":[""],"content":"2.1. 雲端模型(Cloud Models) 公有, 私有 及 混合式雲端(Public, Private, and Hybrid cloud) 什麼是雲端運算(What is Cloud Computing) 雲端運算是 通過網絡提供計算服務, 更快的實現創新、靈活的資源和規模經濟 規模經濟(economies of scale) : 當廠商生產能力與產量增加時，由於大量採購原料使成本降低，產品每單位製造成本隨產量的擴大而下降所帶來的效益，稱為規模經濟 它是隨選存取自一個共用運算資源池, 通常位於世界各地, 這些資源可以是任何東西, 從伺服器、網絡、儲存體、資料庫、應用程式等, 使用的資源可以預配並以最少的力氣釋放 公有雲(Public Cloud) 由雲端服務供應商亦或是主機服務供應商所擁有 提供資源及服務給多個組織與使用者 使用者通常使用網路訪問服務(通常經由網路,透過安全連線訪問 typically over the internet) 相關服務通常是開放給所有人使用 私有雲(Private Cloud) 組織或公司建立的雲端環境在他們的資料中心, 不過它不僅限於組織中 組織或公司需要負擔所有責任, 負責運營其提供的服務(實際購買硬體.更新.到網路和安全性等等) 通常不提供組織以外的使用者訪問他們的資源, 通常是私有的 混合雲(Hybrid Cloud) 結合公有及私有雲, 並由組織決定允許那些資源在公開雲端及那些資源保存在私人雲端中 需擁有深厚的技術技能以維護私人雲端並確保兩種雲端模式能夠高效的一起運行且具備彈性 他們可以滿足任何有關安全性的法規合規性 三種模式差異(Compare and contrast the three different cloud models) 公有雲 : 無需資本支出即可擴大規模 應用可以快速的配置和取消配置 組織或公司 使用多少就付多少費用 它是向所有人開放的 私有雲 : 實體設備(硬體)是由企業或組織的購置或實際運作雲端者來買單 企業或組織需要深厚的技術以維護和更新私人雲端 企業或組織通常有對於資源的完整控制權並禁止公用讀取 混合雲 : 是三種模型中有最大的彈性 企業或組織決定運作那部分應用和資源,以滿足任何資料的要求 企業或組織控制安全以及法規遵循上符合那些要求 ","date":"2022-06-10","objectID":"https://loulazynote.github.io/note/20220104_azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/:1:0","tags":["Azure"],"title":"MircoSoft Azure Fundamentals 認證課程(AZ-900)","uri":"https://loulazynote.github.io/note/20220104_azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/"},{"categories":[""],"content":"2.2. 雲端的優點及相關問題考量(Cloud Benefits and Considerations) 雲端的優點 雲端的相關問題選擇 雲端的優點: 高可用性(High availability) : 維持資源的能力,保持長時間運轉不中斷,且很少停機 容錯(Fault tolerance) : 如元件或服務出現問題或停止作業的狀況,確保能保持正常運作 可延展性(Scalability) : 水平擴展(Scaling Out):增加更多資源或服務或虛擬機器 垂直擴展(Scaling Up):在現有資源增加更多的 CPU、RAM 彈性(Elasticity) : 類似擴展性,自動增加的能力或根據需要減少資源 全球觸及(Global reach) : 可以存取的資源,將其存放世界各地 客戶延遲能力(Customer lantency capabailities) : 在存取資源時為客戶降低延遲 靈活度(Agility) : 可以快速回應工作負載需求(如突然飆升的流量需要分配更多資源,相反亦是) 預測成本(Predictive cost considerations) : 可以預先確定在雲端中有哪些支出的實際成本 比較支出模式: CapEx 資本支出(Capital Expenditure) 預先支出資金在實體基礎結構上 資本支出的成本會隨著時間的推移而降低 OpEx 業務支出(Operational Expenditure) 根據需要對服務或產品進行支出和計費 費用在同一年扣除(每月或每年支付相關費用) 使用量基礎模式(Consumption-based model) 雲服務提供者以基於業務支出模式運作，這表示最終使用者只為他們所使用的資源付費 更好的成本預測 提供個別資源和服務的價格 計費以實際使用方式為準 ","date":"2022-06-10","objectID":"https://loulazynote.github.io/note/20220104_azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/:2:0","tags":["Azure"],"title":"MircoSoft Azure Fundamentals 認證課程(AZ-900)","uri":"https://loulazynote.github.io/note/20220104_azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/"},{"categories":[""],"content":"2.3. 雲端服務(Cloud Services) IaaS, PaaS, and SaaS 介紹 共同責任(Sharing Responsibility) 雲端服務 laaS 基礎結構即服務（Infrastructure-as-a-Service）: 像在 Azure 中可以裝載虛擬機器的模式 通過租用伺服器、虛擬機、存儲、來自雲供應商的網路和操作系統 只要根據實際使用的內容付費 基本上是為你所需要的資源付費 PaaS 平臺即服務（Platform-as-a-Service）: 像是在 Azure 可以使用 SQL 資料庫來儲存資料的模式 在此模型中,雲端解決方案供應商會負責一切,除了使用者自己的應用,雲端解決方案供應商需要負責,如 管理伺服器、基礎結構、作業系統、網路甚至服務配置 此模型提供了一個環境予以建置、測試、採用軟體應用程式且不必擔心相關基礎結構 SaaS 軟體即服務（Software-as-a-Service）: 像是 office 365 的模式 提供構建、測試和部署軟體應用程式的環境;沒有專注於管理底層基礎架構 使用者通常使用網路連接並使用基於雲端的應用程式(EX: Office 365) 基本上是租用該軟體,每月或每年 基於此雲端解決方案供應商會照顧一切 根據用例識別服務類型(Cloud service comparison) IaaS : 最靈活的雲端服務 | 在使用者的應用程式下運作配置和管理硬體(EX: 虛擬機器) PaaS : 專注於應用發展 | 平臺管理是由雲端解決方案供應商管理(EX: Azure Server 或 Containers) SaaS : 即用即付定價型 | 用戶為他們在訂閱上使用的軟體付費(EX: 訂閱 office 365) 分擔責任模式(Shared responsibility model) 私有雲(Private Cloud) : 圖示最左側的部分是客戶所有需要負責的 laaS 基礎結構即服務（Infrastructure-as-a-Service） : 微軟管理運算、網絡、儲存體(皆為物理硬體) 客戶管理 他們的資料、應用程式、執行時期、作業系統、虛擬機器 PaaS 平臺即服務（Platform-as-a-Service）: 客戶專注於 應用程式及資料 其餘由微軟管理 SaaS 軟體即服務（Software-as-a-Service）: 客戶管理 他們的資料及存取 剩下皆由微軟管理 所有雲端模型 使用者皆有責任保護自己的資料和身份安全性及內部部署資源以及自己所管控因服務類型而異的 任何雲端元件 無伺服器運算 (Serverless Computing) == FaaS 功能即服務（Function-as-a-Service） Azure Functions : 它創造了基於事件的基礎結構, 是運行服務的代碼,而不是底層平臺或基礎架構 Azure Logic Apps : 是一項雲端服務,當您需要集成應用程式、資料、系統和服務時, 可説明你自動執行和編排任務、業務流程和工作流 借助無伺服器計算應用程式，雲服務提供者自動調配、擴展和管理所需的基礎架構以運行代碼。 3. 核心 Azure 服務(Core Azure Services) ","date":"2022-06-10","objectID":"https://loulazynote.github.io/note/20220104_azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/:3:0","tags":["Azure"],"title":"MircoSoft Azure Fundamentals 認證課程(AZ-900)","uri":"https://loulazynote.github.io/note/20220104_azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/"},{"categories":[""],"content":"3.1. Azure 體系結構元件(Azure Architectural Components) 區域和可用性區域 地區 藍點區域代表 Azure 區域 Azure 有超過 60 個地區, 位於全球代表了 140 多個國家 藍點表是資料中心的集合, 它可以來自一個到最多 16 個資料中心 這些地區幫助企業或組織滿足他們對資料落地權的要求 選擇地區時, 為了低延遲儘量選擇離用戶最近的區域 並不是所有地區內含相同功能, 因為他們建立並建構於不同時期 區域配對 同一地理中的兩藍點相隔至少距離 300 英里(角色分離), 以保護資料 自動區域配對, 自動複製某些服務 在發生如 Azure 中斷問題情況時每個配對中的一個區域將被優先考慮以幫助減少時間來還原資料及應用程式 為了最大幅度降低 停機時間和應用程式中斷的風險, 更新會排程推出 可用性區域(最多 3 個) 建立旨在防止停機,起因為伺服器故障 提供保護 針對如一個可用性區域碰巧中斷導致資料中心的停機, 以避免故障(Zone1 中斷 則 Zone2 and Zone3 不影響,因為各自獨立) 並非所有地區都具有相同的可用性 , 需要在部署資源前確保它們有你需要的結構 在 物理上將資料中心分隔在同一地區 每個資料中心都配備了獨立電源、冷卻系統和網路 通過專用光纖連接網路, 降低延遲 可用性選項 SLA 服務級別協定(service-level agreement) : 是服務提供商與客戶之間定義的正式承諾, 服務提供商與受服務使用者之間具體達成了承諾的服務指標——品質、可用性、責任 一台具有 99.9% SLA 的虛擬機器 及 進階儲存體 一樣有一台虛擬機器 但 SLA 等級 為 99.99%, 因為正在橫跨可用性區域分發那台虛擬機器並為它備份, 各可用性區域內的電源及冷卻系統和網路是獨立的 分散虛擬機器橫跨數個區域, 會得到更高的 SLA, 因為分散了風險,最右側圖示 區域配對, 區域及區域間隔了至少 300 英哩 訂閱及資源群組 Azure 資源(Azure Resources) 資源群組(Resource Groups) 資源群組是要管理容器並將資源整合到單個單元中 資源群組是依照某種邏輯組別分組, 它可以按照計劃類型、專案週期(較常見)..等 當不在需要這些資源時, 可以將這些從雲端中解除分配 資源只能存在於一個資源群組中 資源可以存在於不同的區域 資源可以移動到不同的資源群組 應用程式可以利用多種資源群組 Azure 資源管理員(Azure Resource Manager) Azure 資源管理員（ARM） 在 Azure 訂閱中提供了一個管理層使您能夠創建、更新和刪除資源 優點 : 它可以自動部署及設定資源, 使用不同的自動化工具/腳本工具(EX: Azure PowerShell、Azure CLI、CMD) 自動建立資源 保持一致性 和 整個部署的標準 有可使用的 ARM 範本 Azure 訂閱帳戶 Azure 訂閱為你提供經過身份驗證和授權對 Azure 帳戶的授權訪問許可權 計費邊界： 生成單獨的計費每個訂閱的報表和發票, 依照每個訂閱自動計費範圍, 同時也是存取控制範圍 訪問控制邊界： 管理和控制對資源的訪問,用戶可以使用特定訂閱進行預配(一個帳戶可以有多個訂閱) ","date":"2022-06-10","objectID":"https://loulazynote.github.io/note/20220104_azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/:4:0","tags":["Azure"],"title":"MircoSoft Azure Fundamentals 認證課程(AZ-900)","uri":"https://loulazynote.github.io/note/20220104_azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/"},{"categories":[""],"content":"3.2. 核心 Azure 資源(Core Azure Resources) 計算(Compute) Azure 計算服務(Azure compute Services) Azure 計算是一種隨選的計算服務, 提供計算磁碟、處理器、記憶體、網路和操作系統等資源 虛擬機器(Azure Virtual Machines) Azure 虛擬機器（VM）是實體電腦的軟體模擬 包括虛擬處理器、記憶體、存儲和網路 屬於 IaaS 的一種產品，提供完全控制和客製化 虛擬機器擴展集, 虛擬機器提供自動管理波動及工作負載 Azure App Services Azure 應用服務是一個完全託管的平臺, 用於構建、快速部署和擴展 Web 應用和 API 適用於.Net、.Net Core、Node.js、Java、Python或php 具有企業級性能、安全性的 PaaS 產品和合規性要求 Azure容器服務(Azure Container Services) Azure 容器是一種輕量級的虛擬化環境, 不需要操作系統管理, 並可按需求回應更改 Aci(Azure Container Instances): 在 Azuer 中運行容器的 PaaS 產品/服務，無需管理虛擬機器或其他服務 負責為使用者管理基礎結構, 可稱為 Aci端點 可透過Aci 以事件為導向, 也能長期運行, 可運行 幾小時、幾天、幾週、幾個月 基本上它們是容器, 可以根據需要來部署(EX: 公用/私用Docker的映射) AKS(Azure Kubernetes Service): 適用於具有分散式架構和大量容器的編排服務(EX: 使用AKS用於在執行多個容器與複雜的協調流程/管理、滾動升級、自動排程及自動擴展) WVD虛擬桌面(Windows Virtual Desktop) Windows 虛擬桌面是在雲端中運行的桌面和應用虛擬化, 支援 windows Server、Linux、SQL Server、Oracle、IBM、SAP等以及其他， 所有的虛擬桌面內含的負載平衡和自動擴展是完全免費的 創建完整的桌面虛擬化環境, 而無需運行其他閘道伺服器 host pools 無限發佈以適應各種工作負載 利用 pooled、多 session 資源降低成本 網路(Networking) Azure網路服務(Azure networking services) Azure虛擬網路(Azure Virtual Network(VNet)):允許他人透過網路及本地網路連結Azure資源(EX:虛擬網路的作用範圍是單一區域,而多個虛擬網路來自不同地區,可以使用虛擬網路對等互相連結在一起) 虛擬私人網路閘道(vitual Privae Network Gateway(VPN)):在 VNet 及本地網路之間通過公開網路位置發送加密流量 Azure快速路由(Azure Express Route): 本地網路由私人連接自內部佈署位置通過專用連結到 Azure 中(需透過連結供應商進行設定) 示例中,使用兩台 VM 在同一資源群組內互相 ping 對方確認是否能連線,這裡要注意將 ICMP 開啟允許,否則會被 windows 內建防火牆擋住 Allow ICMP for PowerShell CommandLine: New-NetFirewallRule -DisplayName \"Allow ICMPv4-In\" -Protocol ICMPv4 存儲(Storage) Azure儲存體服務(Azure storage services) 儲存體容器(Container storage(blob)): 針對儲存大量非結構化資料進行優化, 非結構化資料是未遵循特定資料模型或定義的資料, 例如文字或二進位資料 硬碟儲存體(Disk storage): 為虛擬機器、應用程式以及其他要訪問和使用提供硬碟儲存的服務 Azure檔案共用(Azure Files): 完全管理的雲端檔案共用, 可透過產業標準伺服器訊息區塊 (SMB) 通訊協定或網路檔案系統 (NFS) 通訊協定來共用 Azure儲存體訪問層(Azure storage access tiers) Hot : 針對存儲經常訪問的資料進行優化 Cool : 針對存儲不常訪問且存儲至少 30 天的資料進行優化 Archive : 針對存儲很少訪問和存儲至少 180 天的資料進行優化，具有靈活的延遲要求 資料庫(Databases) Azure資料庫服務(Azure database services) Azure Cosmos資料庫(Azure Cosmos Database): 是一種全域散發式資料庫服務, 這可以彈性和獨立擴展傳輸量和儲存體跨越多個Azure地理區域(是一個非 SQL 的資料庫, EX: Cassandra、Mongo DB、Gremlin等, 是第一個也是唯一提供 59s SLA 的服務) Azure SQL資料庫(Azure SQL Database): 是一種關係資料庫服務（DaaS）, 基於 Microsoft SQL Server 的最新穩定版本資料庫引擎 MySQL資料庫(Azure Database for MySQL): 是一個完全託管的 sequel關係 資料庫為應用程式開發人員提供服務, 基於 MySQL 社群版 PostgreSQL資料庫(Azure Database for postgreSQL): 是一種關係資料庫服務基於開源 Postgres 資料庫引擎 Azure資料庫轉移服務(Azure Database Migration): 資料庫轉移服務是完全受控服務, 旨在實現無縫遷移停機時間最短, 可從多個資料庫源到Azure Azure SQL 受控執行個體(Azure SQL Managed Instance) 允許現有的 SQL Server 客戶將其本地應用程式提升並轉移到應用程式和資料庫最少更改的雲 它有一個 99.9 作業時間(point uptime)及一個 99.99 奇偶選性(Parity) Azure SQL Managed Instance 結合最廣泛的 SQL 伺服器資料庫引擎相容性 完全託管和常青平臺作為服務 保留所有 PaaS 功能（自動修補和版本更新、自動備份和高可用性以及 TCO ） 在 SQL 上以現有許可證換成折扣價 使用Azure 混合權益的託管實例 次模組(Explore Azure Marketplace) 允許客戶查找, 試用、購買和預配來自數百家領先服務提供者的應用程式和服務, 這些應用程式和服務都經過認證, 可在 Azure 上運行 開源容器平臺 虛擬機和資料庫映像 應用程式構建和部署軟體 開發人員工具 還有更多，有 10000 多個來源 4. Azure 解決方案和管理工具(Core Solutions and Management Tools) ","date":"2022-06-10","objectID":"https://loulazynote.github.io/note/20220104_azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/:5:0","tags":["Azure"],"title":"MircoSoft Azure Fundamentals 認證課程(AZ-900)","uri":"https://loulazynote.github.io/note/20220104_azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/"},{"categories":[""],"content":"4.1. Azure 解決方案(Core Solutions) Azure 網路(Azure Internet of Things) 是設備獲取中繼資訊以進行資料分析的能力 Azure IoT中心(Azure IoT Central): 是一套完全受控的全球IoT SaaS解決方案，使您的大規模 IoT 資產在連接、監控和管理網路變得容易 Azure IoT中樞(Azure IoT Hub): 是託管在雲中的託管服務, 充當 IoT 應用程式與其管理的設備之間雙向通信的中央訊息中樞 Azure Sphere : 是一個全面的 IoT 安全的高階應用程式平台, 其配備適用於網際網路連線裝置的內建通訊及安全性功能, 它包含硬體、操作系統及雲端元件, 還包括 Azure Sphere 認證晶片、作業系統及安全服務 Azure 巨量資料及分析(Big Data and analytics) Azure Synapse 資料總管(Azure Synapse Analytics): 基於雲端的企業資料倉庫 Azure HDInsight : 一個完全受控的企業開源分析服務 Databricks 資料科學\u0026工程(Azure Databricks): 基於 Apache Spark的分析服務, 其支援 Python、Scala、R、Java、SQL以及資料科學框架, 還有 函式庫, 其包括 TensorFlow、Pytorch、Second Learn 人工智慧及機器學習(Artificial Intelligence \u0026 Machine Learning) Azure機器學習(Azure Machine Learning): 基於雲端開發、訓練、佈署機器學習模組 Azure認知服務(Cognitive Services): 快速啟用應用程式看、聽、說, 理解和解釋使用者的需求 Azure機器人服務(Azure Bot Service): 開發專業的企業級機器人 Azure DevOps服務 Azure DevOps: Pipelines包含開發者協作工具及基於雲端的自動化負載測試 GitHub: 託管軟體開發者的原始碼管理及版本控制還有 Bug/Task 管理 GitHub Actions for Azure: 自動化軟體工作流程, 以使用 Github 建置、測試、佈署 Azure DevTest Labs: 快速在Azure建立開發使用可重用範本進行測試階段, 可預先建立 通過配額和政策最大限度地減少浪費及控制成本 ","date":"2022-06-10","objectID":"https://loulazynote.github.io/note/20220104_azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/:6:0","tags":["Azure"],"title":"MircoSoft Azure Fundamentals 認證課程(AZ-900)","uri":"https://loulazynote.github.io/note/20220104_azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/"},{"categories":[""],"content":"4.2. Azure管理工具(Azure management tools) Azure Portal: 入口網站 Azure PowerShell: 是一套指令, 讓其管理Azure資源 Azure Mobile APP: 可以快速診斷及修復問題, 且可執行命令以管理Azure資源, 也能執行臨時Azure CLI或PowerShell命令直接在行動應用程式中 Command-Line Interface(CLI): CLI是一個跨平台命令行應用程式連接Azure並執行管理命令Azure資源 Azure Cloud Shell: 是基於瀏覽器的Azure入口網站中的腳本環境(有PowerShell及Bash可選) 首次登入需要設定 記憶體 Azure Resource Manager(ARM): 允許自動建立使用不同自動化的資源及腳本工具(EX: PowerShell、CLI、入口網站、REST API及客戶端開發套件) 範本是 JavaScript 物件表示法 （JSON） 檔可用於創建和部署 Azure 基礎結構，而無需編寫程式命令 聲明性語法(Declarative syntax) 可重複的結果(Repeatable results) 編排(Orchestration) 模組化檔(Modular files) 內建驗證(Built-in validation) 可匯出原始碼(Exportable code) Azure 顧問(Azure Advisor) 分析已部署的 Azure 資源，並根據最佳做法提出建議以優化 Azure 部署 可靠性(Reliability) 安全(Security) 性能(Performance) 成本(Cost) 卓越運營(Operational Excellence) Azure監視器(Azure Monitor) 最大限度地提高應用程式的可用性和性能，以及通過收集、分析和處理來自雲端和本地的遙測資料來提供服務環境 應用洞察(Application Insights) 日誌分析(Log Analytics) 智慧警報(Smart Alerts) 自動化操作(Automation Actions) 自定義儀錶板(Customized Dashboards) Azure服務健康狀況(Azure Service Health) 有關中斷的通訊 計劃內維護 其他健康建議 評估的影響 Azure 服務問題個性化指導和支援、通知和問題解決方法更新 提供 Azure 服務的運行狀況和正在使用的區域的個人化檢視 5. Azure 安全性和網路安全性(General Security and Network Security) ","date":"2022-06-10","objectID":"https://loulazynote.github.io/note/20220104_azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/:7:0","tags":["Azure"],"title":"MircoSoft Azure Fundamentals 認證課程(AZ-900)","uri":"https://loulazynote.github.io/note/20220104_azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/"},{"categories":[""],"content":"5.1. 安全性工具及功能(Security tools and features) Azure資訊安全中心(Azure Security Center) Azure 安全中心是一項監控服務，可在 Azure 和本地資料中心兩者之間提供威脅防護(橫跨所有設備的威脅防護) 所有安全相關的都會在此中心 提供安全建議 檢測和阻止惡意軟件 分析和識別潛在的攻擊 連接埠的即時存取控制 免費層(Free Tier) : 自動包含在Azure訂用帳戶中, 對您的Azure資源僅提供評估及建議 標準層(Standard Tier) : 提供一組完整套件與安全有關的服務, 這其中包含持續監控威脅偵測..等, 可以連接至內部部署環境 原則合規性(Policy Compliance) :提供訂用帳戶跨管理組運行策略 持續評估(Continuous Assessments) :評估新的和已部署的資源確保正確配置它們 量身定做的建議(Tailored Recommeendations) :基於現有的建議工作量, 並說明如何實施它們 威脅防護(Threat Protection) :通過警報分析嘗試的威脅和受影響的資源報告 Azure Sentinel 橫跨整個企業的鳥瞰圖, 可實施 威脅偵測 及 透過人工智慧來進行 回應, 藉此 即可不必維護任何類型的基礎架構設定及安全性 是安全資訊管理 （SIEM） 和安全自動化回應 （SOAR） 解決方案，提供橫跨整個企業的安全分析和威脅情報 是極具彈性且是自動的, 所以可以自行彈性調整規模以滿足安全性需求, 同時關注成本 且在某方面來降低成本 它內建 AI 其建構在調查及檢測階段, 在當中查詢可疑的活動, 之後透過自動保護提供回應 連接工具及整合： Office 365 Azure Active Director Azure 進階威脅保護(Azure Advanced Threat Protection) 微軟雲端應用程式安全性(Microsoft Cloud App Security) Azure金鑰保存庫(Azure Key Vault) 將應用程式機密存儲在集中的雲端位置，以便安全地控制存取許可權和存取日誌記錄 可以透過記錄檔看到誰存取檔案及何時存取 機密管理 金鑰管理 憑證管理 儲存由硬體安全性支援的機密模組 （HSM） Azure專用主機(Azure Dedicated Host) 提供託管一個或多個 Azure 虛擬機的實體伺服器，這些虛擬機僅適用於單一 Azure 訂用帳戶 屬於公有雲實體基礎結構的一部分 不支援 虛擬技能集(Virtual Skill Set) 優點 針對實體伺服器級別的硬體隔離 控制維護工作(即表示可以不用親自維護) 可用自己的憑證去使用 Azure 混合使用權益(Azure Hybrid Benefit) 使用 Hybrid Benefit 可以節省成本, 並可以讓你透過現有的Windows及SQL授權帶進Azure 使用 ","date":"2022-06-10","objectID":"https://loulazynote.github.io/note/20220104_azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/:8:0","tags":["Azure"],"title":"MircoSoft Azure Fundamentals 認證課程(AZ-900)","uri":"https://loulazynote.github.io/note/20220104_azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/"},{"categories":[""],"content":"5.2. 網路連接安全性(Security Network Connectivity) ","date":"2022-06-10","objectID":"https://loulazynote.github.io/note/20220104_azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/:9:0","tags":["Azure"],"title":"MircoSoft Azure Fundamentals 認證課程(AZ-900)","uri":"https://loulazynote.github.io/note/20220104_azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/"},{"categories":[""],"content":"5.2.1. 深度防禦(Dfense in depth) 什麼是深度防禦, 它是一種策略, 它採用一系列機制, 是設計來減緩那些未經授權存取你的資訊、資料、資源的攻擊 即每一層都提供保護, 即使此層遭到破壞, 在它下方還有一層保護來幫助防止任何進一步的攻擊接觸 安全性是共同的責任 保護計算機系統的分層方法 提供多級保護 針對一層的攻擊與後續層隔離 結合網路安全解決方案: 具有 Azure 防火牆的 NSG，可實現縱深防禦 週邊層使用 Azure DDoS 保護和 Azure 防火牆保護網路邊界 網路層僅允許流量在具有網路安全群組(NSG)入站和出站規則的網路資源之間傳遞 參照圖表會發現不論何種服務或部署類型, 用戶都會擁有自己的資料及自己的身份, 用戶有責任協助保護這些資料及身份, 且需負責資料、端點、帳戶管理的安全 內部部署資料中心(圖表最左側) : 所有工作都需要用戶負責, 從實體資料中心到資料及管理 基礎設施即服務(IaaS) : 用戶需負責維護 作業系統及軟體的安全, 也需要負責進行設定來確保網路是安全的, Azure負責保護實體主機、實體網路、實體資料中心, 除此之外都需要用戶負責 平台即服務(PaaS) : Azure負責保護的是作業系統、實體主機、實體網路、實體資料中心及大部分的基礎軟體(EX: 資料庫管理系統), 用戶除卻 共同責任的部分外(應用程式的安全性、網路控制、身份識別)皆需要自行維護其餘項目, 甚至可以與存取控制的 _Azure Active Directory_進行整合 軟體即服務(SaaS) : 在 _PaaS_基礎上 Azure更加了負責保護的部分, 像是應用程式的安全性、網路控制, 用戶也有 共同責任 來負責身份識別以及目錄基礎結構, 其餘皆需用戶負責 共同安全性(Shared Security) 從客戶控制的資料中心遷移到基於雲端的資料中心會轉移安全責任 安全性成為雲端供應商和客戶共同關注的問題 網路安全性群組NSG(Network Security Groups) : Network Level 篩選 Azure 虛擬網路上與 Azure 資源之間的往來網路流量, 可以自行選擇在多個不同級別上進行篩選入站及出站規則 設置入站和出站規則以按源和目標 IP 位址、埠和協定 根據需要在訂閱限制內添加多個規則 Azure 將預設的基線安全規則應用於新的 NSG 使用新的、優先順序更高的規則覆蓋預設規則 Azure防火牆(Azure Firewall) : Perimeter Level 此層級會保護任何入站/出站流量 一種有狀態的託管防火牆即服務 (FaaS)，它根據原始 IP 地址授予/拒絕服務器存取權限, 以保護網絡資源 完全受管的並基於雲端的網路安全服務, 用來保護虛擬網路資源, 且它已經連接到Azure, 所以所有的報告都會從防火牆直接進入Azure監視器(Azure Monitor) 應用入站和出站流量篩選規則 內建高可用性 不受限制的雲端可擴充性 使用 Azure監視器(Azure Monitor) 紀錄記錄 Azure應用程式閘道(Azure Application Gateway) : Azure 應用程式閘道還提供防火牆，即 Web 應用程式防火牆(WAF), WAF 為您的 Web 應用程式提供集中式入站保護 這是一個負載平衡器, 其中包括 Web 應用程式及 Web 應用程式防火牆, 它提供可以防止網站上的常見漏洞的保護 Azure 分散式阻斷服務(DDoS)保護(Azure Distributed Denial of Service (DDoS) protection) : Perimeter Level DDoS 攻擊使網絡資源不堪重負，導致應用程式變慢或無回應, 也就是利用 龐大的流量發送到你的Azure網路或資源中時, 使其資源超載, 並且變慢或完全癱瘓資源 在不需要的網路流量影響服務可用性之前對其進行清理 在 Azure 中自動啟用基本服務層 標準服務層添加了經過優化以保護 Azure 虛擬網路資源的緩解功能(非自動包含在Azure內, 是屬於額外的成本, 此功能收取金額稍高, 建議使用在關鍵的商務應用程式) 6. 身分識別、治理、隱私和合規性(Identity, Governance, Privacy and Compliance) ","date":"2022-06-10","objectID":"https://loulazynote.github.io/note/20220104_azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/:9:1","tags":["Azure"],"title":"MircoSoft Azure Fundamentals 認證課程(AZ-900)","uri":"https://loulazynote.github.io/note/20220104_azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/"},{"categories":[""],"content":"6.1. 核心身份識別服務(Core Azure identity services) ","date":"2022-06-10","objectID":"https://loulazynote.github.io/note/20220104_azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/:10:0","tags":["Azure"],"title":"MircoSoft Azure Fundamentals 認證課程(AZ-900)","uri":"https://loulazynote.github.io/note/20220104_azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/"},{"categories":[""],"content":"6.1.1. 比較驗證及授權(Compare Authentication and Authorization) 驗證(Authentication) 標識尋求存取資源的人員或服務 請求合法的存取憑證 創建安全身份和存取控制原則的基礎 授權(Authorization) 確定經過身份驗證的人員或服務的存取級別 定義他們可以存取哪些資料, 以及他們可以用這些資料做什麼 ","date":"2022-06-10","objectID":"https://loulazynote.github.io/note/20220104_azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/:10:1","tags":["Azure"],"title":"MircoSoft Azure Fundamentals 認證課程(AZ-900)","uri":"https://loulazynote.github.io/note/20220104_azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/"},{"categories":[""],"content":"6.1.2. 多重要素驗證(Azure Multi-Factor Authentication) 透過要求兩個或更多元素進行完全身份驗證以確認你的身份 它限制了可公開的憑證數量 你知道的東西(EX: 帳號密碼、安全問題) 你擁有的東西(EX: 授權 APP、權杖產生裝置) 是你本人的要素(EX: 生物識別、指紋掃描、人臉辨識) 還未支援屬於你的生物辨識 ","date":"2022-06-10","objectID":"https://loulazynote.github.io/note/20220104_azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/:10:2","tags":["Azure"],"title":"MircoSoft Azure Fundamentals 認證課程(AZ-900)","uri":"https://loulazynote.github.io/note/20220104_azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/"},{"categories":[""],"content":"6.1.3. Azure活動目錄(Azure Active Directory(AAD)) 可視為常規活動目錄的額外目錄, 是微軟Azure 基於雲端的身份識別和存取管理服務, 也能使用於外部資源如 Office 365 、Azure Portal或其他 軟體即服務(SaaS)應用程式 可自助密碼重置、多重要素驗證、自定義禁用密碼清單 身份驗證(員工登錄以存取資源) 單一登入(SSO) : 只需記憶一組帳號密碼 應用程式管理 : 可協助管理所有的應用程式, 不論存在 雲端中 或 內建佈署 的應用程式 企業對企業(B2B) : 企業對客戶(B2C)身份服務 : 可以管理訪客或客戶去如何存取你的公司資料, 如果是為供應商或客戶, 可控制他們如何登入、註冊或如何透過你的應用程式服務來管理他們的個人資料 設備管理 : 可管理雲端或內部部署設備存取公司資料的方式 ","date":"2022-06-10","objectID":"https://loulazynote.github.io/note/20220104_azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/:10:3","tags":["Azure"],"title":"MircoSoft Azure Fundamentals 認證課程(AZ-900)","uri":"https://loulazynote.github.io/note/20220104_azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/"},{"categories":[""],"content":"6.1.4. 條件式存取(Conditional Access) 是與 AAD 一起使用的, 可以讓組織具有不同的身份識別來確定那些應用程序、資料, 是使用者可以存取的, 並且要取決於 使用者是那種類型, 其隸屬的團隊成員身份為何, 在何位置、使用何種設備、何種應用程式 存取使用 Azure Active Directory、是根據組織策略來決定 用戶或組成員身份 IP 位置 設備 應用 風險檢測 ","date":"2022-06-10","objectID":"https://loulazynote.github.io/note/20220104_azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/:10:4","tags":["Azure"],"title":"MircoSoft Azure Fundamentals 認證課程(AZ-900)","uri":"https://loulazynote.github.io/note/20220104_azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/"},{"categories":[""],"content":"6.2. 治理方法(Azure Governance Methodologies) ","date":"2022-06-10","objectID":"https://loulazynote.github.io/note/20220104_azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/:11:0","tags":["Azure"],"title":"MircoSoft Azure Fundamentals 認證課程(AZ-900)","uri":"https://loulazynote.github.io/note/20220104_azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/"},{"categories":[""],"content":"6.2.1. 角色型存取控制(Explore Role-based access control (RBAC)) 此功能包含在所有 Azure訂用帳戶內, 不需支付額外的費用 可使用在 訂用帳戶層級、管理群組層級、資源群組層級或個別資源上 _IAM_內也能自定角色 微調存取管理 在團隊中劃分職責, 僅向使用者授予執行其工作所需的存取許可權 啟用對 Azure Portal的存取並控制對資源的存取 ","date":"2022-06-10","objectID":"https://loulazynote.github.io/note/20220104_azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/:11:1","tags":["Azure"],"title":"MircoSoft Azure Fundamentals 認證課程(AZ-900)","uri":"https://loulazynote.github.io/note/20220104_azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/"},{"categories":[""],"content":"6.2.2. 資源鎖(Resource locks) 保護 Azure 資源免遭意外刪除或修改 在 Azure Portal 中管理訂閱、資源組或個別資源級別的鎖 ","date":"2022-06-10","objectID":"https://loulazynote.github.io/note/20220104_azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/:11:2","tags":["Azure"],"title":"MircoSoft Azure Fundamentals 認證課程(AZ-900)","uri":"https://loulazynote.github.io/note/20220104_azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/"},{"categories":[""],"content":"6.2.3. 標籤(Tags) 牽涉到報表或帳單時, 是個可以明確標註分類的工具 標籤不具有父子繼承關係, 如資源群組設定了標籤, 其底下的所有項目都不會有這些標籤 將後設資料新增到 Azure 資源中 後設資料(metadata)又稱詮釋資料、中介資料、中繼資料、後設資料等, 為描述其他資料資訊的資料 以邏輯方式將資源組織到分類中 由名稱-值組成一對 對於匯總帳單資訊非常有用 ","date":"2022-06-10","objectID":"https://loulazynote.github.io/note/20220104_azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/:11:3","tags":["Azure"],"title":"MircoSoft Azure Fundamentals 認證課程(AZ-900)","uri":"https://loulazynote.github.io/note/20220104_azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/"},{"categories":[""],"content":"6.2.4. Azure原則(Azure Policy) 有助於執行組織標準並大規模評估合規性(可設定你的組織標準是什麼, 而這些原則將自動在整個訂用帳戶中強制執行) 通過法規遵從性、安全性、成本和管理提供治理和資源一致性 也能設定只讓特定的人進行佈署並允許虛擬機 SKUS 存貨單位(Stock-keeping-Uni):也翻譯為庫存單元, 是一個會計學名詞 評估和識別不符合您的策略的 Azure 資源 在存儲、網絡、計算、安全中心和監控等類別下提供內置策略和計劃定義 ","date":"2022-06-10","objectID":"https://loulazynote.github.io/note/20220104_azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/:11:4","tags":["Azure"],"title":"MircoSoft Azure Fundamentals 認證課程(AZ-900)","uri":"https://loulazynote.github.io/note/20220104_azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/"},{"categories":[""],"content":"6.2.5. Azure藍圖(Azure Blueprints) 使開發團隊能夠快速構建和建立新環境 開發團隊可以通過組織對一組內置元件（如網路）的合規性來快速建立信任, 以加快開發和交付速度 角色分配 策略分配 Azure資源管理器範本 ARM範本佈署時, 佈署的資源和佈署的來源 沒有關係, 但透過 Azure藍圖佈署, 每個佈署將會綁定在藍圖套組中, 所以佈署就會與資源產生關係, 且即使在佈署之後也會持續進行維護 資源群組 ","date":"2022-06-10","objectID":"https://loulazynote.github.io/note/20220104_azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/:11:5","tags":["Azure"],"title":"MircoSoft Azure Fundamentals 認證課程(AZ-900)","uri":"https://loulazynote.github.io/note/20220104_azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/"},{"categories":[""],"content":"6.2.6. 雲端採用架構(Cloud Adoption Framework) 建議可從此入手來設定Azure環境 Microsoft 實現 Azure 雲端的方法 來自 Microsoft 員工、合作夥伴和客戶的最佳實踐 戰略和成果的工具、指導和敘述 ","date":"2022-06-10","objectID":"https://loulazynote.github.io/note/20220104_azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/:11:6","tags":["Azure"],"title":"MircoSoft Azure Fundamentals 認證課程(AZ-900)","uri":"https://loulazynote.github.io/note/20220104_azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/"},{"categories":[""],"content":"6.3. 合規性、隱私權及資料保護標準(Privacy, compliance, and data protection standards) ","date":"2022-06-10","objectID":"https://loulazynote.github.io/note/20220104_azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/:12:0","tags":["Azure"],"title":"MircoSoft Azure Fundamentals 認證課程(AZ-900)","uri":"https://loulazynote.github.io/note/20220104_azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/"},{"categories":[""],"content":"6.3.1. 合規性、隱私權及合規性(Security, Privacy, and Compliance) 是微軟所做的一切基礎 安全性(Security) : 安全設計, 借助內置的智慧安全性, Microsoft 使用自動化和人工智慧説明防範已知和未知的網路威脅, 安全性是開發過程的一部分 隱私權(Privacy) : 我們致力於履行對你的合約義務以及達到透明化, 並提供使用者控制來確保組織的隱私 微軟隱私權聲明(Microsoft privacy statement) 微軟隱私聲明提供了有關微軟如何處理從其產品和服務中收集的用戶資料的開放性和誠實性 微軟隱私聲明解釋： 微軟處理哪些資料 微軟如何處理它 資料的用途 線上服務條款及資料保護增訂版(Online Services Terms and Data Protection Addendum) 全適用於所有的Microsoft程式或所購買的軟體 線上服務條款(Online Services Terms) : 許可條款定義了您通過 Microsoft 批量許可計劃購買的產品和線上服務的條款和條件 資料保護增訂版(Data Protection Addendum(DPA)) : DPA 規定了與線上服務相關的客戶資料和個人資料的處理和安全方面的義務 合規性(Compliance) : 我們尊重當地法律法規, 並提供全面的合規產品 合規條款和要求(Compliance Terms and Requirements) Microsoft提供任何雲端服務並提供者最全面的合規性產品/服務(包括認證和證明), 一些合規性產品包括在內 當要與任何一個雲端提供者合作時, 需提出幾個必要的問題 當涉及到處理敏感資料時, 雲端提供者的合規性如何? 當涉及合規性時, 雲端提供者提供了那些服務? 可以如何部署自己的雲端式解決方案, 且仍保持合規性? Azure 合規性文件(Azure Compliance Documentation) Microsoft 提供了一套全面的合規性產品, 可幫助您的組織遵守管理資料收集和使用的國家、地區和行業特定要求 ","date":"2022-06-10","objectID":"https://loulazynote.github.io/note/20220104_azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/:12:1","tags":["Azure"],"title":"MircoSoft Azure Fundamentals 認證課程(AZ-900)","uri":"https://loulazynote.github.io/note/20220104_azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/"},{"categories":[""],"content":"6.3.2. 信任中心(Trust Center) 了解 Microsoft 雲端產品的安全性、隱私、合規性、策略、功能及實作 記載著一切與隱私信任及合規性有關的內容 信託中心網站提供： 深入的專家信息 推薦資源的精選列表, 按主題排列 針對經理角色、管理角色、工程師、風險工作角色、隱私官和法律事物人員角色的特定角色信息 ","date":"2022-06-10","objectID":"https://loulazynote.github.io/note/20220104_azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/:12:2","tags":["Azure"],"title":"MircoSoft Azure Fundamentals 認證課程(AZ-900)","uri":"https://loulazynote.github.io/note/20220104_azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/"},{"categories":[""],"content":"6.3.3. Azure 主權區域（美國政府服務）(Azure Sovereign Regions (US Government services)) 兩個完全獨立的Azure的實體執行個體其一 滿足美國聯邦機構、州和地方政府及其解決方案提供商的安全性和合規性需求 相容標準示例：FedRAMP，NIST 800.171（DIB），ITER，IRS 1075，DoD L2，L4 和 L5 以及 CJIS Azure Government： Azure 的單獨實例(沒有連接任何其他的資料中心) 物理上與非美國政府部署隔離 只有經過篩選的授權人員才能存取 ","date":"2022-06-10","objectID":"https://loulazynote.github.io/note/20220104_azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/:12:3","tags":["Azure"],"title":"MircoSoft Azure Fundamentals 認證課程(AZ-900)","uri":"https://loulazynote.github.io/note/20220104_azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/"},{"categories":[""],"content":"6.3.4. Azure 主權區域（中國政府服務）(Azure Sovereign Regions (Azure China)) 兩個完全獨立的Azure的實體執行個體其二 微軟是中國第一家符合政府法規的外國公共雲端服務提供者 Azure 中國功能： 由 21Vianet 操作的 Azure 雲端服務的物理分離實例 所有資料都保留在中國境內, 以確保合規性 7. Azure 定價和生活方式(Azure cost management and Service Level Agreements) ","date":"2022-06-10","objectID":"https://loulazynote.github.io/note/20220104_azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/:12:4","tags":["Azure"],"title":"MircoSoft Azure Fundamentals 認證課程(AZ-900)","uri":"https://loulazynote.github.io/note/20220104_azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/"},{"categories":[""],"content":"7.1. 規劃及管理成本(Planning and Cost Management) ","date":"2022-06-10","objectID":"https://loulazynote.github.io/note/20220104_azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/:13:0","tags":["Azure"],"title":"MircoSoft Azure Fundamentals 認證課程(AZ-900)","uri":"https://loulazynote.github.io/note/20220104_azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/"},{"categories":[""],"content":"7.1.1. 影響成本的因素(Factors affecting costs) 影響成本 6 要素 資源類型(Resource Type) : 成本是特定於資源的, 因此計量跟蹤的使用方式以及與資源關聯的使用計量取決於資源類型 服務(Services) : Azure 使用率和計費週期可能因企業(Enterprise)、Web Direct和雲端解決方案供應商客戶而異 Web Direct : 通常是沒有任何相關的折扣類型, 是以使用流量計價, 一般是按月計費 企業(Enterprise) : 通常是已與 Azure簽約約一年一次, 由於此金額夠大通常會提供一個折扣, 一般是按年計費 雲端解決方案供應商(CSP Customers) : 通常是第三方合作夥伴, 它將直接與客戶合作來設定客戶端的Azure帳戶, 因此在帳單上不僅要支付Azure服務的費用, 還需為 雲端解決方案供應商的 時間及勞動付費, 所以帳單不會透過 Azure提供會直接由雲端解決方案供應商來處理 位置(Location) : Azure 基礎結構分佈在全球, 使用成本可能因提供 Azure 產品、服務和資源的位置而異, Azure擁有 60 多個地區 140 個國家, 每個國家都有不同的成本(EX: 瑞士國家地區的營運資料中心的成本確實較高, 因此在瑞士或澳洲運作資源確實會花費更多的成本) 頻寬(Bandwidth) : 按區域計費, 不同的地區或地域會被組織成區域 某些入站資料傳輸(InBound)是免費的(EX:進入 Azure 資料中心的資料) 對於出站資料傳輸(OutBound)(EX:從 Azure 資料中心傳出的資料, 如果在美西部署了資源, 從美西傳輸資料到澳洲, 那出站費用將從美國到澳洲計算) 預付執行個體(Reserved Instances) : 使用 Azure 保留項目, 你承諾為多個產品購買一年或三年計劃, 預訂可以顯著降低您的資源成本, 最高可達即用即付價格的 72% Azure 混合使用權益(Azure Hybrid Use Benefit) : 對於具有軟體保障的客戶, Azure 混合權益允許你以更低的成本在 Azure 上使用本地許可證 定價計算機(Pricing Calculator) : 定價計算機是一種工具，可説明你估算 Azure 產品的成本, 您可以在定價計算機中配置的選項因產品而異，但基本配置選項包括以下內容 地區 等級 計費選項 支援選項 計劃和優惠 Azure 開發/測試定價 總擁有成本計算機(Total Cost of Ownership Calculator) 一種工具, 用於估算通過遷移到 Azure 可以實現的成本節約 報表將本地基礎結構的成本與在雲端中使用 Azure 產品和服務的成本進行比較 Azure 成本管理工具(Azure Cost Management) 報告 : 帳單報告 如果使用 標籤工具 可以更深入的研究 資料擴充 預算 : 設置支出預算 警報 : 當成本超過限制時或接近預算時 建議(Recommendation) : 成本建議 成本最小化(Minimizing costs) : 依序往下 動作 說明 執行(Perform) 執行成本分析, 使用 Azure 定價(Azure Pricing)和 TCO 計算機(TCO calculators) 監視器(Monitor) 使用 Azure 顧問監視使用(Monitor usage)方式並實施建議(Azure Advisor) 使用(Use) 使用支出限制(spending limits), 通過免費試用客戶和一些基於信用額度的 Azure 訂閱使用 使用(Use) 使用 Azure Reservations 和 Azure Hybrid Benefit(HUB) 選擇(Choose) 選擇低成本位置和區域(low-cost locations), 如果可能, 請使用低成本位置 保持(Keep) 即時瞭解(Keep up-to-date)最新的 Azure 客戶和訂閱產品/服務 適用(Apply) 應用標記以標識成本擁有者, 使用標記標識使用擁有者(cost owners) ","date":"2022-06-10","objectID":"https://loulazynote.github.io/note/20220104_azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/:13:1","tags":["Azure"],"title":"MircoSoft Azure Fundamentals 認證課程(AZ-900)","uri":"https://loulazynote.github.io/note/20220104_azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/"},{"categories":[""],"content":"7.2. 服務等級協定及Azure服務生命週期(Azure SLAs and service lifecycles) ","date":"2022-06-10","objectID":"https://loulazynote.github.io/note/20220104_azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/:14:0","tags":["Azure"],"title":"MircoSoft Azure Fundamentals 認證課程(AZ-900)","uri":"https://loulazynote.github.io/note/20220104_azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/"},{"categories":[""],"content":"7.2.1. 服務層級協定(Service Level Agreements (SLAs)) 服務級別協定(SLAs)描述了 Microsoft 對正常運行時間和連接性的承諾 服務等級協定是一項合約義務, 讓微軟承諾該特定服務的啟動及執行時間, 需達到每月的最短時數 每一項服務都有自己相關的 SLAs(不會只有一個通用的 SLA) 關於所提供服務的詳細協定，以及 SLA 的任何例外情況 免費和預覽功能/服務不提供 SLAs ","date":"2022-06-10","objectID":"https://loulazynote.github.io/note/20220104_azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/:14:1","tags":["Azure"],"title":"MircoSoft Azure Fundamentals 認證課程(AZ-900)","uri":"https://loulazynote.github.io/note/20220104_azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/"},{"categories":[""],"content":"7.2.2. Azure 產品和服務的 SLAs(SLAs for Azure products and services) 性能目標表示為正常運行時間和連接保證 有效目標範圍從 99%到 99.999% 如果服務未能滿足保證, 則可以記入每月服務費的一定百分比 SLA 值越高, 每月遇到的停機時間越短, 如圖顯示在 SLA 值 99.9%部分, 每月最大停機時間為 43 分 49 秒, 這不代表每個月會停機停滿 43 分 49 秒, 那只意味著 只要 微軟 每月停機不超過 43 分 49 秒 即正在履行其可用性的合約義務 7.2.2.1. 影響 SLAs 的操作(Actions that affect SLAs) 許多因素可能會提高或降低您的 SLA, 基於業務目標的設計決策將推動您的 SLA 目標 複合 SLA(Composite SLA) : 多個服務, 將第一個資源的 SLA 乘上第二個資源 降低您的 SLA 增加到解決方案中的服務越多, 因解決方案越複雜, SLA 也會隨之調降(因如果每項服務都是分數交互相乘後分數就會變的更小) 選擇免費或非 SLA 服務(免費服務不提供 SLA) 提高您的 SLA 可用性區域(是一種針對虛擬機器增加 SLA 的一種方式) 冗餘構建 7.2.2.2. Azure 預覽程式(Azure Preview Program) 不提供與之相關的 SLA 請不要把預覽功能放進執行環境中 預覽功能這些都是銷售任務的功能 使用 Azure 預覽功能, 使用者可以測試 Beta 版和其他預發佈功能、產品、服務、軟體和區域，以提供反饋 公共預覽版 : 所有 Azure 客戶都可以評估新功能 正式發佈(GA) : 完成公共預覽版后, 所有客戶都可以使用該功能, 並且區域可用性會有所不同 只要是預覽就沒有任何類型的 SLA 及相關的 SLA, 且不要把它投入到執行環境中 7.2.2.3. 監視服務和功能更新(Monitoring service and feature updates) 如想知道在預覽功能時的狀態可以使用此服務, 有一個Azure更新頁面 Azure 更新提供有關 Azure 產品、服務和功能的資訊, 以及產品路線圖和可用性 查看有關所有 Azure 更新及其狀態的詳細資訊 瀏覽和搜尋更新 訂閱 RSS 的 Azure 更新通知 ","date":"2022-06-10","objectID":"https://loulazynote.github.io/note/20220104_azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/:14:2","tags":["Azure"],"title":"MircoSoft Azure Fundamentals 認證課程(AZ-900)","uri":"https://loulazynote.github.io/note/20220104_azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/"},{"categories":[""],"content":" 簡介 Azure 雲端概念(Cloud Concepts) 2.1. 雲端模型(Cloud Models) 2.2. 雲端的優點及相關問題考量(Cloud Benefits and Considerations) 2.3. 雲端服務(Cloud Services) 核心 Azure 服務(Core Azure Services) 3.1. Azure 體系結構元件(Azure Architectural Components) 3.2. 核心 Azure 資源(Core Azure Resources) Azure 解決方案和管理工具(Core Solutions and Management Tools) 4.1. Azure 解決方案(Core Solutions) 4.2. Azure管理工具(Azure management tools) Azure 安全性和網路安全性(General Security and Network Security) 身分識別、治理、隱私和合規性(Identity, Governance, Privacy and Compliance) Azure 定價和生活方式(Azure cost management and Service Level Agreements) ","date":"2022-06-10","objectID":"https://loulazynote.github.io/note/20220104_azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98part_1/:0:0","tags":["Azure"],"title":"MircoSoft Azure Fundamentals 認證課程(AZ-900)","uri":"https://loulazynote.github.io/note/20220104_azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98part_1/"},{"categories":[""],"content":"1. 簡介 AZ-900 Azure 基礎知識測驗 評分規則及配重 考試規則: 測驗時間 : 60 分鐘 考題類型 : 選擇題(無實作) 比重如下圖 ","date":"2022-06-10","objectID":"https://loulazynote.github.io/note/20220104_azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98part_1/:1:0","tags":["Azure"],"title":"MircoSoft Azure Fundamentals 認證課程(AZ-900)","uri":"https://loulazynote.github.io/note/20220104_azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98part_1/"},{"categories":[""],"content":"2. Azure 雲端概念(Cloud Concepts) ","date":"2022-06-10","objectID":"https://loulazynote.github.io/note/20220104_azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98part_1/:2:0","tags":["Azure"],"title":"MircoSoft Azure Fundamentals 認證課程(AZ-900)","uri":"https://loulazynote.github.io/note/20220104_azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98part_1/"},{"categories":[""],"content":"2.1. 雲端模型(Cloud Models) 公有, 私有 及 混合式雲端(Public, Private, and Hybrid cloud) 什麼是雲端運算(What is Cloud Computing) 雲端運算是 通過網絡提供計算服務, 更快的實現創新、靈活的資源和規模經濟 規模經濟(economies of scale) : 當廠商生產能力與產量增加時，由於大量採購原料使成本降低，產品每單位製造成本隨產量的擴大而下降所帶來的效益，稱為規模經濟 它是隨選存取自一個共用運算資源池, 通常位於世界各地, 這些資源可以是任何東西, 從伺服器、網絡、儲存體、資料庫、應用程式等, 使用的資源可以預配並以最少的力氣釋放 公有雲(Public Cloud) 由雲端服務擁有亦或是主機服務供應商 提供資源及服務給多個組織與使用者 使用者通常使用網路訪問服務(通常經由網路,透過安全連線訪問 typically over the internet) 相關服務通常是開放給所有人使用 私有雲(Private Cloud) 組織或公司建立的雲環境在他們的資料中心, 不過它不僅限於組織中 組織或公司需要負擔所有責任, 負責運營其提供的服務(實際購買硬體.更新.到網路和安全性等等) 通常不提供組織以外的使用者訪問他們的資源, 通常是私有的 混合式雲(Hybrid Cloud) 結合公有及私有雲 ,並由組織決定允許那些資源在公開雲端及那些資源保存在私人雲端中 需擁有深厚的技術技能以維護私人雲端並確保兩種雲端模式能夠高效的一起運行且具備彈性 他們可以滿足任何有關安全性的法規合規性 三種模式差異(Compare and contrast the three different cloud models) 公有雲 : 無需資本支出即可擴大規模 應用可以快速的配置和取消配置 組織或公司 使用多少就付多少費用 它是向所有人開放的 私有雲 : 實體設備(硬體)是由企業或組織的購置或實際運作雲端者來買單 企業或組織需要深厚的技術以維護和更新私人雲端 企業或組織通常有對於資源的完整控制權並禁止公用讀取 混合式雲端 : 是三種模型中有最大的彈性 企業或組織決定運作那部分應用和資源,以滿足任何數據資料的要求 企業或組織控制安全以及法規遵循上符合那些要求 ","date":"2022-06-10","objectID":"https://loulazynote.github.io/note/20220104_azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98part_1/:2:1","tags":["Azure"],"title":"MircoSoft Azure Fundamentals 認證課程(AZ-900)","uri":"https://loulazynote.github.io/note/20220104_azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98part_1/"},{"categories":[""],"content":"2.2. 雲端的優點及相關問題考量(Cloud Benefits and Considerations) 雲端的優點 雲端的相關問題選擇 雲端的優點 - 範圍 確定雲計算的好處, 如高可用性、可擴充性, 彈性、靈活度和災難恢復 確定資本支出（CapEx）與運營之間的差異支出（OpEx） 描述基於消費的模型 雲端的優點: 高可用性 : 維持資源的能力,保持長時間運轉不中斷,且很少停機 容錯 : 如元件或服務出現問題或停止作業的狀況,確保能保持正常運作 可延展性 : 水平擴展(Scaling Out):增加更多資源或服務或虛擬機器 垂直擴展(Scaling Up):在現有資源增加更多的 CPU、RAM 彈性 : 類似擴展性,自動增加的能力或根據需要減少資源 全球觸及 : 可以存取的資源,將其存放世界各地 客戶延遲能力 : 在存取資源時為客戶降低延遲 靈活度 : 可以快速回應工作負載需求(如突然飆升的流量需要分配更多資源,相反亦是) 預測成本 : 可以預先確定在雲端中有哪些支出的實際成本 比較支出模式: CapEx 資本支出(Capital Expenditure) 預先支出資金在實體基礎結構上 資本支出的成本會隨著時間的推移而降低 OpEx 業務支出(Operational Expenditure) 根據需要對服務或產品進行支出和計費 費用在同一年扣除(每月或每年支付相關費用) 使用量基礎模式(Consumption-based model) 雲服務提供者以基於業務支出模式運作，這表示最終使用者只為他們所使用的資源付費 更好的成本預測 提供個別資源和服務的價格 計費以實際使用方式為準 ","date":"2022-06-10","objectID":"https://loulazynote.github.io/note/20220104_azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98part_1/:2:2","tags":["Azure"],"title":"MircoSoft Azure Fundamentals 認證課程(AZ-900)","uri":"https://loulazynote.github.io/note/20220104_azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98part_1/"},{"categories":[""],"content":"2.3. 雲端服務(Cloud Services) IaaS, PaaS, and SaaS 介紹 共同責任(Sharing Responsibility) 雲端服務 laaS 基礎結構即服務（Infrastructure-as-a-Service）: 像在 Azure 中可以裝載虛擬機器的模式 通過租用伺服器、虛擬機、存儲、來自雲供應商的網路和操作系統 只要根據實際使用的內容付費 基本上是為你所需要的資源付費 PaaS 平臺即服務（Platform-as-a-Service）: 像是在 Azure 可以使用 SQL 資料庫來儲存資料的模式 在此模型中,雲端解決方案供應商會負責一切,除了使用者自己的應用,雲端解決方案供應商需要負責,如 管理伺服器、基礎結構、作業系統、網路甚至服務配置 此模型提供了一個環境予以建置、測試、採用軟體應用程式且不必擔心相關基礎結構 SaaS 軟體即服務（Software-as-a-Service）: 像是 office 365 的模式 提供構建、測試和部署軟體應用程式的環境;沒有專注於管理底層基礎架構 使用者通常使用網路連接並使用基於雲端的應用程式(EX: Office 365) 基本上是租用該軟體,每月或每年 基於此雲端解決方案供應商會照顧一切 根據用例識別服務類型(Cloud service comparison) IaaS : 最靈活的雲端服務 | 在使用者的應用程式下運作配置和管理硬體(EX: 虛擬機器) PaaS : 專注於應用發展 | 平臺管理是由雲端解決方案供應商管理(EX: Azure Server 或 Containers) SaaS : 即用即付定價型 | 用戶為他們在訂閱上使用的軟體付費(EX: 訂閱 office 365) 分擔責任模式(Shared responsibility model) 私有雲(Private Cloud) : 圖示最左側的部分是客戶所有需要負責的 laaS 基礎結構即服務（Infrastructure-as-a-Service） : 微軟管理運算、網絡、儲存體(皆為物理硬體) 客戶管理 他們的資料數據、應用程式、執行時期、作業系統、虛擬機器 PaaS 平臺即服務（Platform-as-a-Service）: 客戶專注於 應用程式及資料 其餘由微軟管理 SaaS 軟體即服務（Software-as-a-Service）: 客戶管理 他們的數據資料及存取 剩下皆由微軟管理 所有雲端模型 使用者皆有責任保護自己的資料和身份安全性及內部部署資源以及自己所管控因服務類型而異的 任何雲端元件 無伺服器運算 (Serverless Computing) == FaaS 功能即服務（Function-as-a-Service） Azure Functions : 是運行服務的代碼,而不是底層平臺或基礎架構。它創造了基於事件的基礎結構 Azure Logic Apps : 是一項雲服務,可説明你自動執行和編排任務、業務流程和工作流,當您需要集成應用程式、數據、系統和服務 借助無伺服器計算應用程式，雲服務提供者自動調配、擴展和管理所需的基礎架構以運行代碼。 ","date":"2022-06-10","objectID":"https://loulazynote.github.io/note/20220104_azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98part_1/:2:3","tags":["Azure"],"title":"MircoSoft Azure Fundamentals 認證課程(AZ-900)","uri":"https://loulazynote.github.io/note/20220104_azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98part_1/"},{"categories":[""],"content":"3. 核心 Azure 服務(Core Azure Services) ","date":"2022-06-10","objectID":"https://loulazynote.github.io/note/20220104_azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98part_1/:3:0","tags":["Azure"],"title":"MircoSoft Azure Fundamentals 認證課程(AZ-900)","uri":"https://loulazynote.github.io/note/20220104_azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98part_1/"},{"categories":[""],"content":"3.1. Azure 體系結構元件(Azure Architectural Components) 區域和可用性區域 地區 藍點區域代表 Azure 區域 Azure 有超過 60 個地區, 位於全球代表了 140 多個國家 藍點表是資料中心的集合, 它可以來自一個到最多 16 個數據中心 這些地區幫助企業或組織滿足他們對資料落地權的要求 選擇地區時, 為了低延遲儘量選擇離用戶最近的區域 並不是所有地區內含相同功能, 因為他們建立並建構於不同時期 區域配對 同一地理中的兩藍點相隔至少距離 300 英里(角色分離), 以保護資料 自動區域配對, 自動複製某些服務 在發生如 Azure 中斷問題情況時每個配對中的一個區域將被優先考慮以幫助減少時間來還原資料及應用程式 為了最大幅度降低 停機時間和應用程式中斷的風險, 更新會排程推出 可用性區域(最多 3 個) 建立旨在防止停機,起因為伺服器故障 提供保護 針對如一個可用性區域碰巧中斷導致數據中心的停機, 以避免故障(Zone1 中斷 則 Zone2 and Zone3 不影響,因為各自獨立) 並非所有地區都具有相同的可用性 , 需要在部署資源前確保它們有你需要的結構 在 物理上將數據中心分隔在同一地區 每個數據中心都配備了獨立電源、冷卻系統和網路 通過專用光纖連接網路, 降低延遲 可用性選項 SLA 服務級別協定(service-level agreement) : 是服務提供商與客戶之間定義的正式承諾, 服務提供商與受服務使用者之間具體達成了承諾的服務指標——品質、可用性、責任 一台具有 99.9% SLA 的虛擬機器 及 進階儲存體 一樣有一台虛擬機器 但 SLA 等級 為 99.99%, 因為正在橫跨可用性區域分發那台虛擬機器並為它備份, 各可用性區域內的電源及冷卻系統和網路是獨立的 分散虛擬機器橫跨數個區域, 會得到更高的 SLA, 因為分散了風險,最右側圖示 區域配對, 區域及區域間隔了至少 300 英哩 訂閱及資源群組 Azure 資源(Azure Resources) 資源群組(Resource Groups) 資源群組是要管理容器並將資源整合到單個單元中 資源群組是依照某種邏輯組別分組, 它可以按照計劃類型、專案週期(較常見)..等 當不在需要這些資源時, 可以將這些從雲端中解除分配 資源只能存在於一個資源群組中 資源可以存在於不同的區域 資源可以移動到不同的資源群組 應用程式可以利用多種資源群組 Azure 資源管理員(Azure Resource Manager) Azure 資源管理員（ARM） 在 Azure 訂閱中提供了一個管理層使您能夠創建、更新和刪除資源 優點 : 它可以自動部署及設定資源, 使用不同的自動化工具/腳本工具(EX: Azure PowerShell、Azure CLI、CMD) 自動建立資源 保持一致性 和 整個部署的標準 有可使用的 ARM 範本 Azure 訂閱帳戶 Azure 訂閱為你提供經過身份驗證和授權對 Azure 帳戶的授權訪問許可權 計費邊界： 生成單獨的計費每個訂閱的報表和發票, 依照每個訂閱自動計費範圍, 同時也是存取控制範圍 訪問控制邊界： 管理和控制對資源的訪問,用戶可以使用特定訂閱進行預配(一個帳戶可以有多個訂閱) ","date":"2022-06-10","objectID":"https://loulazynote.github.io/note/20220104_azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98part_1/:3:1","tags":["Azure"],"title":"MircoSoft Azure Fundamentals 認證課程(AZ-900)","uri":"https://loulazynote.github.io/note/20220104_azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98part_1/"},{"categories":[""],"content":"3.2. 核心 Azure 資源(Core Azure Resources) 計算(Compute) Azure 計算服務(Azure compute Services) Azure 計算是一種隨選的計算服務, 提供計算磁碟、處理器、記憶體、網路和操作系統等資源 虛擬機器(Azure Virtual Machines) Azure 虛擬機器（VM）是實體電腦的軟體模擬 包括虛擬處理器、記憶體、存儲和網路 屬於 IaaS 的一種產品，提供完全控制和客製化 虛擬機器擴展集, 虛擬機器提供自動管理波動及工作負載 Azure App Services Azure 應用服務是一個完全託管的平臺, 用於構建、快速部署和擴展 Web 應用和 API 適用於.Net、.Net Core、Node.js、Java、Python或php 具有企業級性能、安全性的 PaaS 產品和合規性要求 Azure容器服務(Azure Container Services) Azure 容器是一種輕量級的虛擬化環境, 不需要操作系統管理, 並可按需求回應更改 Aci(Azure Container Instances): 在 Azuer 中運行容器的 PaaS 產品/服務，無需管理虛擬機器或其他服務 負責為使用者管理基礎結構, 可稱為 Aci端點 可透過Aci 以事件為導向, 也能長期運行, 可運行 幾小時、幾天、幾週、幾個月 基本上它們是容器, 可以根據需要來部署(EX: 公用/私用Docker的映射) AKS(Azure Kubernetes Service): 適用於具有分散式架構和大量容器的編排服務(EX: 使用AKS用於在執行多個容器與複雜的協調流程/管理、滾動升級、自動排程及自動擴展) WVD虛擬桌面(Windows Virtual Desktop) Windows 虛擬桌面是在雲端中運行的桌面和應用虛擬化, 支援 windows Server、Linux、SQL Server、Oracle、IBM、SAP等以及其他， 所有的虛擬桌面內含的負載平衡和自動擴展是完全免費的 創建完整的桌面虛擬化環境, 而無需運行其他閘道伺服器 host pools 無限發佈以適應各種工作負載 利用 pooled、多 session 資源降低成本 網路(Networking) Azure網路服務(Azure networking services) Azure虛擬網路(Azure Virtual Network(VNet)):允許他人透過網路及本地網路連結Azure資源(EX:虛擬網路的作用範圍是單一區域,而多個虛擬網路來自不同地區,可以使用虛擬網路對等互相連結在一起) 虛擬私人網路閘道(vitual Privae Network Gateway(VPN)):在 VNet 及本地網路之間通過公開網路位置發送加密流量 Azure快速路由(Azure Express Route): 本地網路由私人連接自內部佈署位置通過專用連結到 Azure 中(需透過連結供應商進行設定) 示例中,使用兩台 VM 在同一資源群組內互相 ping 對方確認是否能連線,這裡要注意將 ICMP 開啟允許,否則會被 windows 內建防火牆擋住 Allow ICMP for PowerShell CommandLine: New-NetFirewallRule -DisplayName \"Allow ICMPv4-In\" -Protocol ICMPv4 存儲(Storage) Azure儲存體服務(Azure storage services) 儲存體容器(Container storage(blob)): 針對儲存大量非結構化資料進行優化, 非結構化資料是未遵循特定資料模型或定義的資料, 例如文字或二進位資料 硬碟儲存體(Disk storage): 為虛擬機器、應用程式以及其他要訪問和使用提供硬碟儲存的服務 Azure檔案共用(Azure Files): 完全管理的雲端檔案共用, 可透過產業標準伺服器訊息區塊 (SMB) 通訊協定或網路檔案系統 (NFS) 通訊協定來共用 Azure儲存體訪問層(Azure storage access tiers) Hot : 針對存儲經常訪問的資料進行優化 Cool : 針對存儲不常訪問且存儲至少 30 天的數據進行優化 Archive : 針對存儲很少訪問和存儲至少 180 天的數據進行優化，具有靈活的延遲要求 資料庫(Databases) Azure資料庫服務(Azure database services) Azure Cosmos資料庫(Azure Cosmos Database): 是一種全域散發式資料庫服務, 這可以彈性和獨立擴展傳輸量和儲存體跨越多個Azure地理區域(是一個非 SQL 的資料庫, EX: Cassandra、Mongo DB、Gremlin等, 是第一個也是唯一提供 59s SLA 的服務) Azure SQL資料庫(Azure SQL Database): 是一種關係資料庫服務（DaaS）, 基於 Microsoft SQL Server 的最新穩定版本資料庫引擎 MySQL資料庫(Azure Database for MySQL): 是一個完全託管的 sequel關係 資料庫為應用程式開發人員提供服務, 基於 MySQL 社群版 PostgreSQL資料庫(Azure Database for postgreSQL): 是一種關係資料庫服務基於開源 Postgres 資料庫引擎 Azure資料庫轉移服務(Azure Database Migration): 資料庫轉移服務是完全受控服務, 旨在實現無縫遷移停機時間最短, 可從多個資料庫源到Azure Azure SQL 受控執行個體(Azure SQL Managed Instance) 允許現有的 SQL Server 客戶將其本地應用程式提升並轉移到應用程式和資料庫最少更改的雲 它有一個 99.9 作業時間(point uptime)及一個 99.99 奇偶選性(Parity) Azure SQL Managed Instance 結合最廣泛的 SQL 伺服器資料庫引擎相容性 完全託管和常青平臺作為服務 保留所有 PaaS 功能（自動修補和版本更新、自動備份和高可用性以及 TCO ） 在 SQL 上以現有許可證換成折扣價 使用Azure 混合權益的託管實例 次模組(Explore Azure Marketplace) 允許客戶查找, 試用、購買和預配來自數百家領先服務提供者的應用程式和服務, 這些應用程式和服務都經過認證, 可在 Azure 上運行 開源容器平臺 虛擬機和資料庫映像 應用程式構建和部署軟體 開發人員工具 還有更多，有 10000 多個來源 ","date":"2022-06-10","objectID":"https://loulazynote.github.io/note/20220104_azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98part_1/:3:2","tags":["Azure"],"title":"MircoSoft Azure Fundamentals 認證課程(AZ-900)","uri":"https://loulazynote.github.io/note/20220104_azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98part_1/"},{"categories":[""],"content":"4. Azure 解決方案和管理工具(Core Solutions and Management Tools) ","date":"2022-06-10","objectID":"https://loulazynote.github.io/note/20220104_azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98part_1/:4:0","tags":["Azure"],"title":"MircoSoft Azure Fundamentals 認證課程(AZ-900)","uri":"https://loulazynote.github.io/note/20220104_azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98part_1/"},{"categories":[""],"content":"4.1. Azure 解決方案(Core Solutions) Azure 網路(Azure Internet of Things) 是設備獲取中繼資訊以進行數據分析的能力 Azure IoT中心(Azure IoT Central): 是一套完全受控的全球IoT SaaS解決方案，使您的大規模 IoT 資產在連接、監控和管理網路變得容易 Azure IoT中樞(Azure IoT Hub): 是託管在雲中的託管服務, 充當 IoT 應用程式與其管理的設備之間雙向通信的中央訊息中樞 Azure Sphere : 是一個全面的 IoT 安全的高階應用程式平台, 其配備適用於網際網路連線裝置的內建通訊及安全性功能, 它包含硬體、操作系統及雲端元件, 還包括 Azure Sphere 認證晶片、作業系統及安全服務 Azure 巨量資料及分析(Big Data and analytics) Azure Synapse 資料總管(Azure Synapse Analytics): 基於雲端的企業資料倉庫 Azure HDInsight : 一個完全受控的企業開源分析服務 Databricks 資料科學\u0026工程(Azure Databricks): 基於 Apache Spark的分析服務, 其支援 Python、Scala、R、Java、SQL以及資料科學框架, 還有 函式庫, 其包括 TensorFlow、Pytorch、Second Learn 人工智慧及機器學習(Artificial Intelligence \u0026 Machine Learning) Azure機器學習(Azure Machine Learning): 基於雲端開發、訓練、佈署機器學習模組 Azure認知服務(Cognitive Services): 快速啟用應用程式看、聽、說, 理解和解釋使用者的需求 Azure機器人服務(Azure Bot Service): 開發專業的企業級機器人 Azure DevOps服務 Azure DevOps: Pipelines包含開發者協作工具及基於雲端的自動化負載測試 GitHub: 託管軟體開發者的原始碼管理及版本控制還有 Bug/Task 管理 GitHub Actions for Azure: 自動化軟體工作流程, 以使用 Github 建置、測試、佈署 Azure DevTest Labs: 快速在Azure建立開發使用可重用範本進行測試階段, 可預先建立 通過配額和政策最大限度地減少浪費及控制成本 ","date":"2022-06-10","objectID":"https://loulazynote.github.io/note/20220104_azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98part_1/:4:1","tags":["Azure"],"title":"MircoSoft Azure Fundamentals 認證課程(AZ-900)","uri":"https://loulazynote.github.io/note/20220104_azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98part_1/"},{"categories":[""],"content":"4.2. Azure管理工具(Azure management tools) Azure Portal: 入口網站 Azure PowerShell: 是一套指令, 讓其管理Azure資源 Azure Mobile APP: 可以快速診斷及修復問題, 且可執行命令以管理Azure資源, 也能執行臨時Azure CLI或PowerShell命令直接在行動應用程式中 Command-Line Interface(CLI): CLI是一個跨平台命令行應用程式連接Azure並執行管理命令Azure資源 Azure Cloud Shell: 是基於瀏覽器的Azure入口網站中的腳本環境(有PowerShell及Bash可選) 首次登入需要設定 記憶體 Azure Resource Manager(ARM): 允許自動建立使用不同自動化的資源及腳本工具(EX: PowerShell、CLI、入口網站、REST API及客戶端開發套件) 範本是 JavaScript 物件表示法 （JSON） 檔可用於創建和部署 Azure 基礎結構，而無需編寫程式命令 聲明性語法(Declarative syntax) 可重複的結果(Repeatable results) 編排(Orchestration) 模組化檔(Modular files) 內建驗證(Built-in validation) 可匯出原始碼(Exportable code) Azure 顧問(Azure Advisor) 分析已部署的 Azure 資源，並根據最佳做法提出建議以優化 Azure 部署 可靠性(Reliability) 安全(Security) 性能(Performance) 成本(Cost) 卓越運營(Operational Excellence) Azure監視器(Azure Monitor) 最大限度地提高應用程式的可用性和性能，以及通過收集、分析和處理來自雲端和本地的遙測數據來提供服務環境 應用洞察(Application Insights) 日誌分析(Log Analytics) 智慧警報(Smart Alerts) 自動化操作(Automation Actions) 自定義儀錶板(Customized Dashboards) Azure服務健康狀況(Azure Service Health) 評估的影響 Azure 服務問題個性化指導和支援、通知和問題解決方法更新 提供 Azure 服務的運行狀況和正在使用的區域的個人化檢視 有關中斷的通訊 計劃內維護 其他健康建議 ","date":"2022-06-10","objectID":"https://loulazynote.github.io/note/20220104_azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98part_1/:4:2","tags":["Azure"],"title":"MircoSoft Azure Fundamentals 認證課程(AZ-900)","uri":"https://loulazynote.github.io/note/20220104_azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98part_1/"},{"categories":[""],"content":"5. Azure 安全性和網路安全性(General Security and Network Security) ","date":"2022-06-10","objectID":"https://loulazynote.github.io/note/20220104_azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98part_1/:5:0","tags":["Azure"],"title":"MircoSoft Azure Fundamentals 認證課程(AZ-900)","uri":"https://loulazynote.github.io/note/20220104_azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98part_1/"},{"categories":[""],"content":"6. 身分識別、治理、隱私和合規性(Identity, Governance, Privacy and Compliance) ","date":"2022-06-10","objectID":"https://loulazynote.github.io/note/20220104_azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98part_1/:6:0","tags":["Azure"],"title":"MircoSoft Azure Fundamentals 認證課程(AZ-900)","uri":"https://loulazynote.github.io/note/20220104_azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98part_1/"},{"categories":[""],"content":"7. Azure 定價和生活方式(Azure cost management and Service Level Agreements) ","date":"2022-06-10","objectID":"https://loulazynote.github.io/note/20220104_azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98part_1/:7:0","tags":["Azure"],"title":"MircoSoft Azure Fundamentals 認證課程(AZ-900)","uri":"https://loulazynote.github.io/note/20220104_azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98/azure-%E9%9B%B2%E7%AB%AF%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98part_1/"},{"categories":[""],"content":"What is NFT Non-Fungible Token 非同值化代幣 NFT 社群喜用 Discord 為社群 一套 NFT 就是一套 智能合約 (跑在區塊鏈的程式) 部署智能合約只需要 一個私鑰 無聊猿的 SourceCode: // Mapping from token ID to owner address mappingg(uint256 =\u003e address) private _owners; NFT 可以是任何東西, 但本身就是一個程式 NFT 所屬的智能合約部署後就不能改動 proxy的智能合約可以已限制的狀況下可以改動 ","date":"2022-06-10","objectID":"https://loulazynote.github.io/note/20220604_%E5%8D%80%E5%A1%8A%E9%8F%88/20220604_nft/:1:0","tags":["NFT"],"title":"NFT基本概念","uri":"https://loulazynote.github.io/note/20220604_%E5%8D%80%E5%A1%8A%E9%8F%88/20220604_nft/"},{"categories":[""],"content":"Where is the value of NFT ? Like LV Brand Bag. ","date":"2022-06-10","objectID":"https://loulazynote.github.io/note/20220604_%E5%8D%80%E5%A1%8A%E9%8F%88/20220604_nft/:1:1","tags":["NFT"],"title":"NFT基本概念","uri":"https://loulazynote.github.io/note/20220604_%E5%8D%80%E5%A1%8A%E9%8F%88/20220604_nft/"},{"categories":[""],"content":"Use Opensea to deploy NFT ","date":"2022-06-10","objectID":"https://loulazynote.github.io/note/20220604_%E5%8D%80%E5%A1%8A%E9%8F%88/20220604_nft/:2:0","tags":["NFT"],"title":"NFT基本概念","uri":"https://loulazynote.github.io/note/20220604_%E5%8D%80%E5%A1%8A%E9%8F%88/20220604_nft/"},{"categories":[""],"content":"Step Use Metamask Sign in Opensea Click ","date":"2022-06-10","objectID":"https://loulazynote.github.io/note/20220604_%E5%8D%80%E5%A1%8A%E9%8F%88/20220604_nft/:2:1","tags":["NFT"],"title":"NFT基本概念","uri":"https://loulazynote.github.io/note/20220604_%E5%8D%80%E5%A1%8A%E9%8F%88/20220604_nft/"},{"categories":[""],"content":"What is Opensea NFT different? Opensea’s NFT 所有 Collection 共享一個智能合約 出了 Opensea 就沒有 Collection 的資訊 半中心化 mint 有鑄造的意思 真實 NFT 的發行三要素 工程 美術 行銷 WEB3 的行銷人員 會英文 約200美/週 不會 約300美/週 智能合約 關鍵字 hardhat ","date":"2022-06-10","objectID":"https://loulazynote.github.io/note/20220604_%E5%8D%80%E5%A1%8A%E9%8F%88/20220604_nft/:3:0","tags":["NFT"],"title":"NFT基本概念","uri":"https://loulazynote.github.io/note/20220604_%E5%8D%80%E5%A1%8A%E9%8F%88/20220604_nft/"},{"categories":["SQL","Database"],"content":"關聯式資料庫(RDBMS) 目前常用的資料庫,完全遵守 ACID 原則,在任何情況下(Atomicity)都可保持每個Transaction不成功則roll back,(Consistency)資料一致性,(Isolation)讀寫不互相干擾,(Duration)資料永久性(EX:SQL Server,PostgreSQL,MySQL…等) 且僅能支援垂直擴充,假設要應用在大量的資料的時候,只能透過硬體的升級(CPU 升級、加 HDD、增加 RAM…等) ","date":"2022-06-10","objectID":"https://loulazynote.github.io/note/database-knowledge/nosql-note/:1:0","tags":["SQL","NoSQL","RDBMS","MongoDB"],"title":"What is NoSQL","uri":"https://loulazynote.github.io/note/database-knowledge/nosql-note/"},{"categories":["SQL","Database"],"content":"非關聯式資料庫(NOSQL) NOSQL(Non-SQL,又為 Not only SQL) 稱為非關聯式資料庫,跟關聯式資料庫不一樣,不需要定義 schema且沒有關聯的關係(EX:MongoDB,Redis,MariaDB…) 非關聯式資料庫特點： 資料庫由 collection 組成 collection 中每筆資料為一份 document,document 的資料格式不需一致 以 CAP theorem 為概念設計 常用於分散式雲端系統 ","date":"2022-06-10","objectID":"https://loulazynote.github.io/note/database-knowledge/nosql-note/:2:0","tags":["SQL","NoSQL","RDBMS","MongoDB"],"title":"What is NoSQL","uri":"https://loulazynote.github.io/note/database-knowledge/nosql-note/"},{"categories":["SQL","Database"],"content":"NoSQL v.s RDBMS ","date":"2022-06-10","objectID":"https://loulazynote.github.io/note/database-knowledge/nosql-note/:3:0","tags":["SQL","NoSQL","RDBMS","MongoDB"],"title":"What is NoSQL","uri":"https://loulazynote.github.io/note/database-knowledge/nosql-note/"},{"categories":["SQL","Database"],"content":"RDBMS RDBMS 因具備 ACID 特性,且保證了資料的一致性,若資料需在任何情況下都穩定且一致,則推薦此類(EX: 金融系統) ","date":"2022-06-10","objectID":"https://loulazynote.github.io/note/database-knowledge/nosql-note/:3:1","tags":["SQL","NoSQL","RDBMS","MongoDB"],"title":"What is NoSQL","uri":"https://loulazynote.github.io/note/database-knowledge/nosql-note/"},{"categories":["SQL","Database"],"content":"NOSQL 由於 NOSQL 的 schema 不需要固定,且資料可以為任意結構,所以在 schema 需要頻繁變動或者是 schema 不固定的時候,NOSQL 提供更有彈性的開發 需要儲存大量資料,利用分散式系統以及雲端儲存的時候,由於 NOSQL 相較於 RDBMS 更容易做水平擴充 (horizontal scaling),且本身的設計就是分散式系統的設計,因此對於未來有大量擴充需求的系統,會更容易的去擴充,且擴充的成本也較低 具備水平擴充,較不會有Single Failed ","date":"2022-06-10","objectID":"https://loulazynote.github.io/note/database-knowledge/nosql-note/:3:2","tags":["SQL","NoSQL","RDBMS","MongoDB"],"title":"What is NoSQL","uri":"https://loulazynote.github.io/note/database-knowledge/nosql-note/"},{"categories":["SQL","Database"],"content":"NOSQL 類別 ","date":"2022-06-10","objectID":"https://loulazynote.github.io/note/database-knowledge/nosql-note/:4:0","tags":["SQL","NoSQL","RDBMS","MongoDB"],"title":"What is NoSQL","uri":"https://loulazynote.github.io/note/database-knowledge/nosql-note/"},{"categories":["SQL","Database"],"content":"1. 資料形態(粗略分類) Key-Value: Key-Value資料庫是 NoSQL 資料庫中最大宗的類型,這類資料最大的特色就是採用Key-Value資料架構,取消了原本關聯式資料庫中常用的欄位架構（Schema）,每筆資料各自獨立,所以,可以打造出分散式和高擴充能力的特性 例如: Google BigTable,Hadoop HBase,Amazon Dynamo,Cassandra,Hypertable,Redis,Firebase… Document: 也是一種key-value,限制 value 的結構為半結構化資料semi-structure,像是 JSON 等 將資訊存儲在文檔中的資料庫,旨在將資料儲存為類似 JSON 的文件並對其進行查詢 文件資料庫主要是用來儲存非結構性的文件,例如最常見的非結構化資料就是HTML網頁,一個HTML網頁結構不像一般表格那樣有固定的欄位,每個欄位有特定資料類型和大小,例如網頁裡有Head和Body結構,Body元素中可能會有10個段落,段落中會有文字、連結、圖片等,文件資料庫的資料結構往往是鬆散的樹狀結構 例如:MongoDB,CouchDB,Lotus Notes… Wide-column(圖學架構): 運用圖學架構來儲存節點間關係資料架構(基本的圖學資料包括了節點（Node）、關係（Relation）和屬性（Property）三種結構) 以多個raw、column進行存取,將資料拆成小資料再進行組合,之後可透過column key / row key 進行關聯查詢(可有效的壓縮資料及取用同級的資料集) 例如:Neo4j,InfoGrid,AllegroGrph,Sparksee… ","date":"2022-06-10","objectID":"https://loulazynote.github.io/note/database-knowledge/nosql-note/:4:1","tags":["SQL","NoSQL","RDBMS","MongoDB"],"title":"What is NoSQL","uri":"https://loulazynote.github.io/note/database-knowledge/nosql-note/"},{"categories":["SQL","Database"],"content":"2. CAP定理 (Consistency, Availability, Partition Tolerance) Consistency: 一致性,讀寫都會遵循 Atomicity 原則,等同於所有節點訪問同一份最新的資料副本 Availability: 可用性,每次請求都能獲取到非錯的響應,但是無法保證得到的資料為最新的 Partition Tolerance: 分區容錯性,電腦網路區分為相對獨立的子網,這些子網可以通過設計單獨優化,也可以是網絡設備的故障而導致,而分散式軟體必須設計成具有分區容錯性,也就是說,即使網路被分區後,仍然可以正常工作 根據定理,分散式系統只能滿足三項中的兩項而不可能滿足全部三項,因為在Available的情況下,Consistency與Partition Tolerance是互相矛盾的,因此大致的分類有 AP、CA、CP AP: 只要節點可用就能持續運作 CA: 在沒有任何的例外下,都是可用並保證資料的一致性 CP: 在節點不穩定的時候不接受 request ","date":"2022-06-10","objectID":"https://loulazynote.github.io/note/database-knowledge/nosql-note/:4:2","tags":["SQL","NoSQL","RDBMS","MongoDB"],"title":"What is NoSQL","uri":"https://loulazynote.github.io/note/database-knowledge/nosql-note/"},{"categories":["SQL","Database"],"content":"參考資料 NoSQL | wikipedia.org 什麼是 NoSQL？| AWS 快速認識4類主流NoSQL資料庫 | iThome [淺談]-NoSQL資料庫怎麼選？ | ZiXiang-Blog RDBMS vs. NOSQL - 關聯式資料庫 vs. 非關聯式資料庫 | Hs-medium 結構、半結構、非結構式資料是啥意思？ | Kevin的MongoDB工作筆記 ","date":"2022-06-10","objectID":"https://loulazynote.github.io/note/database-knowledge/nosql-note/:5:0","tags":["SQL","NoSQL","RDBMS","MongoDB"],"title":"What is NoSQL","uri":"https://loulazynote.github.io/note/database-knowledge/nosql-note/"},{"categories":["WSL","Docker"],"content":"❗這個設定檔很重要❗ ❗這個設定檔很重要❗ ❗這個設定檔很重要❗ 為什麼這麼說呢? 在前陣子我的電腦重灌後就遺忘了設定檔這件事，這幾天突然發現我的RAM的使用率大飆升,每天電腦都像飛機要起飛一樣，且導致電腦變的很慢。 查看工作管理員 才想到 我的 WSL 裝好後都沒有設定它，所以這裡記錄一下該設定的設定檔內容。 ","date":"2022-06-10","objectID":"https://loulazynote.github.io/posts/wsl2-config-note/:0:0","tags":["WSL","Docker","Windows"],"title":"關於WSL的設定檔 - 不可不知的眉角","uri":"https://loulazynote.github.io/posts/wsl2-config-note/"},{"categories":["WSL","Docker"],"content":"WSL 2 的 .wslconfig 設定檔 編輯 %UserProfile%\\.wslconfig 檔案 code %UserProfile%\\.wslconfig 沒有此檔案的話，可以自行建立一個在%UserProfile% 根目錄下 設定內容說明 [wsl2] kernel=\u003cpath\u003e # 自定義 Linux 的絕對路徑 memory=\u003csize\u003e # 給予 WSL2 虛擬機的記憶體大小 processors=\u003cnumber\u003e # 給 WSL2 虛擬機分配的處理核心數 swap=\u003csize\u003e # 給 WSL2 虛擬機分配的交換空間 (設定 0 的話表示沒有給予交換空間) swapFile=\u003cpath\u003e # 自定義交換虛擬硬碟vhd的絕對路徑 localhostForwarding=\u003cbool\u003e # 允許 WSL2 的port轉發至本地主機 (default true). # \u003cpath\u003e 必須是反斜線的絕對路徑, for example: C:\\\\Users\\\\Ben\\\\kernel # \u003csize\u003e 必須在數字後加上單位, for example: 8GB or 512MB 參數 參數類型 預設值 說明 kernel string 微軟預設提供的 WSL 核心 連接自定義 Linux 的絕對路徑 memory size Windows 全部記憶體的 80% 給予 WSL2 虛擬機的記憶體大小 processors number 相同於Windows 本地主機的處理器核心 給 WSL2 虛擬機分配的處理核心數 localhostForwarding boolean TRUE 是否應可通過 localhost:port 指定綁定到 WSL2 VM 中的通配符或本地主機的埠連接到本地主機的布林值 (允許 WSL2 的port轉發至本地主機) kernelCommandLine string none 額外的核心命令列參數 swap size Windows 上所有記憶體的的 25% 給 WSL2 虛擬機分配的交換空間，設定 0 的話表示沒有給予交換空間 swapFile string %USERPROFILE%\\AppData\\Local\\Temp\\swap.vhdx 交換虛擬硬碟vhd的絕對路徑 ","date":"2022-06-10","objectID":"https://loulazynote.github.io/posts/wsl2-config-note/:1:0","tags":["WSL","Docker","Windows"],"title":"關於WSL的設定檔 - 不可不知的眉角","uri":"https://loulazynote.github.io/posts/wsl2-config-note/"},{"categories":["WSL","Docker"],"content":"參考資料 Release Notes for Windows Subsystem for Linux | Microsoft Docs - Build 18945 WSL 中的進階設定組態 Dev on Windows with WSL - 配置 WSL 2 全局设置 ","date":"2022-06-10","objectID":"https://loulazynote.github.io/posts/wsl2-config-note/:2:0","tags":["WSL","Docker","Windows"],"title":"關於WSL的設定檔 - 不可不知的眉角","uri":"https://loulazynote.github.io/posts/wsl2-config-note/"},{"categories":["C＃","Learning"],"content":"型別系統 概觀 ❗ 是強型別語言, 每個變數和常數都有型別 ❗ 在 C# bool 中無法轉換成 int 儲存在類型中的資訊可以包含下列 型別的變數需要的儲存空間 它可以代表的最大值和最小值 它所包含的成員 (方法、欄位、事件等等) 它繼承自的基底型別 interface (實作) 允許的作業類型 編譯器會將型別資訊視為中繼資料內嵌至可執行檔 通用語言執行平台 (CLR) 會在執行階段使用該中繼資料，以在它配置和回收記憶體時，進一步保證型別安全 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/note/c#-%E5%9F%BA%E7%A4%8E%E8%A4%87%E7%BF%92/csharpbasicpart1/:1:0","tags":["Basic Level","C＃"],"title":"C# 基礎複習Note(型別系統)","uri":"https://loulazynote.github.io/note/c#-%E5%9F%BA%E7%A4%8E%E8%A4%87%E7%BF%92/csharpbasicpart1/"},{"categories":["C＃","Learning"],"content":"變數宣告中指定類型 ❗ 程式中宣告變數或常數時 必須指定其類型 ❗ 也能使用var關鍵字來讓編譯器推斷類型 // Declaration only string name; int studentId; AClass aclass; // Declaration with initializers (four examples) string studentName = \"Lou\"; string [] ClassList = {\"Elaine\",\"Louis\",\"Kyber\", \"Peter\",\"Jeff\",\"Mary\"} // 型別推斷 var query = ClassList.Where(q =\u003e q == studentName).First(); ","date":"2022-06-09","objectID":"https://loulazynote.github.io/note/c#-%E5%9F%BA%E7%A4%8E%E8%A4%87%E7%BF%92/csharpbasicpart1/:1:1","tags":["Basic Level","C＃"],"title":"C# 基礎複習Note(型別系統)","uri":"https://loulazynote.github.io/note/c#-%E5%9F%BA%E7%A4%8E%E8%A4%87%E7%BF%92/csharpbasicpart1/"},{"categories":["C＃","Learning"],"content":"內建類型 C# 提供一組標準內建類型 整數 浮點值 布林運算式 文字字元 十進位值 string object ","date":"2022-06-09","objectID":"https://loulazynote.github.io/note/c#-%E5%9F%BA%E7%A4%8E%E8%A4%87%E7%BF%92/csharpbasicpart1/:1:2","tags":["Basic Level","C＃"],"title":"C# 基礎複習Note(型別系統)","uri":"https://loulazynote.github.io/note/c#-%E5%9F%BA%E7%A4%8E%E8%A4%87%E7%BF%92/csharpbasicpart1/"},{"categories":["C＃","Learning"],"content":"自訂類型 可以使用 結構類型(struct)、 類別(Class) 、 interface(interface)、列舉 (enum) 和 記錄(record) 建構來建立您自己的自訂類型 當明確將專案參考新增至定義這些專案的元件時，其他專案才可用 編譯器在有該組件的參考之後，您可以針對在原始程式碼的那個組件中宣告的型別宣告變數 (或常數) .NET 類別庫本身是自訂類型的集合，可以在應用程式中使用 根據預設，類別庫中最常使用的型別可用於任何 C# 程式 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/note/c#-%E5%9F%BA%E7%A4%8E%E8%A4%87%E7%BF%92/csharpbasicpart1/:1:3","tags":["Basic Level","C＃"],"title":"C# 基礎複習Note(型別系統)","uri":"https://loulazynote.github.io/note/c#-%E5%9F%BA%E7%A4%8E%E8%A4%87%E7%BF%92/csharpbasicpart1/"},{"categories":["C＃","Learning"],"content":"一般型別系統(CTS) 支援繼承原則 型別可以衍生自稱為「基底型別」的其他型別, 而衍生的型別會繼承 (有部份限制) 基底型別的方法、屬性和其他成員 基底型別同樣可以衍生自一些其他型別，所衍生的型別會繼承其繼承階層架構中兩個基底型別的成員 所有類型 最終衍生自單一基底類型，即 System.Object (C# 關鍵字：object) 這種統一型別階層架構稱為一般型別系統 (CTS) 一般型別系統 (CTS)中的每個型別都會定義為「實值型別」或「參考型別」 包括 .NET 類別庫中的所有自訂類型 使用者定義型別 使用 結構類型(struct) 關鍵字定義的類型為實值型別，所有內建的數數值型別都是 結構類型(struct) 使用 類別(class) 或 記錄(record) 關鍵字定義的類型是參考型別 參考型別和實值型別有不同的編譯時期規則和不同的執行階段行為 C# 9.0 新增 記錄型別 資料和行為是類別、結構或記錄 的成員 類別、結構或記錄宣告就像是用來在執行時間建立實例或物件的藍圖 //p 為 Person 的物件或執行個體 Person p = new Person(){ Name = \"Lou\", Age = 18 }; // 可以建立多個相同 Person 型別的執行個體，且每個執行個體在其屬性與欄位中都可以有不同的值 Person p2 = new Person(){ Name = \"Elaine\", Age = 18 }; // Person 的類別、結構 public class Person{ public string Name { get; set; } public int Age { get; set; } } 類別是參考型別 建立型別的物件時，指派物件的變數只會保留該記憶體的參考 當物件參考指派至新的變數時，新的變數會參考到原始物件 透過某個變數所做的變更會反映在其他變數中，因為它們都參考相同的資料 結構是實值型別 建立結構時，結構指派的變數會保留結構的實際資料 當結構指派給新的變數時，就會複製它 新的變數和原始變數會各自包含一份相同的資料，對一個複本所做的變更不會影響另一個複本 記錄類型可以是參考型別(record class)或實值型別(record struct) 類別 是用來建立更複雜的行為模型 類別通常會儲存在建立類別物件之後要修改的資料 結構 最適合小型資料結構 結構通常會儲存在建立結構之後不打算修改的資料 記錄類型 是具有其他編譯器合成成員的資料結構 記錄通常會儲存在建立物件之後不打算修改的資料 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/note/c#-%E5%9F%BA%E7%A4%8E%E8%A4%87%E7%BF%92/csharpbasicpart1/:1:4","tags":["Basic Level","C＃"],"title":"C# 基礎複習Note(型別系統)","uri":"https://loulazynote.github.io/note/c#-%E5%9F%BA%E7%A4%8E%E8%A4%87%E7%BF%92/csharpbasicpart1/"},{"categories":["C＃","Learning"],"content":"值類型 實值型別衍生自 System.ValueType，該型別又衍生自 System.Object 實數值型別變數會直接包含其值 結構記憶體會內嵌配置於變數所宣告的任何內容中，實數值型別變數沒有個別的堆積配置或垃圾收集額外負荷 實值型別有兩種類別 實值型別為 密封, 無法從任何實值型別衍生型別 結構類型(struct) 列舉 (enum) // 內建的數數值型別是結構，而且其具有您可以存取的欄位和方法 // constant field on type byte. byte b = byte.MaxValue; // 宣告並指派值給它們，就像是簡單的非匯總類型 byte num = 0xA; int i = 5; char c = 'Z'; 使用 結構類型 來建立自訂實值型別: public struct Coords { public int x, y; public Coords(int p1, int p2) { x = p1; y = p2; } } 實值型別的另一個類別是 enum: // 列舉會定義一組具名的整數常數 public enum FileMode { CreateNew = 1, Create = 2, Open = 3, OpenOrCreate = 4, Truncate = 5, Append = 6, } ","date":"2022-06-09","objectID":"https://loulazynote.github.io/note/c#-%E5%9F%BA%E7%A4%8E%E8%A4%87%E7%BF%92/csharpbasicpart1/:1:5","tags":["Basic Level","C＃"],"title":"C# 基礎複習Note(型別系統)","uri":"https://loulazynote.github.io/note/c#-%E5%9F%BA%E7%A4%8E%E8%A4%87%E7%BF%92/csharpbasicpart1/"},{"categories":["C＃","Learning"],"content":"參考型別 其定義為 類別(class), 記錄(record), 委派(delegate), 陣列(array)或 interface(interface)的類型是參考型別 參考型別完全支援繼承 當您建立類別時，可以繼承自未定義為 密封的任何其他interface或類別 其他類別可以繼承自您的類別，並覆寫您的虛擬方法 類別的建立和指派 Example: // 建立 MyClass myClass = new MyClass(); // 指派 MyClass myClass2 = myClass; interface(interface) 無法使用new 運算子直接具現化，請建立並指派實作 interface之類別的實例 Example: // 建立 MyClass myClass = new MyClass(); // 用現值宣告及賦值 IMyInterface myInterface = myClass; // 或 建立並賦值 給`interface` IMyInterface myInterface2 = new MyClass(); 所有陣列都是參考型別，即使其元素都是實值型別 陣列會隱含衍生自System.Array 類別，可以宣告並使用 搭配 C# 提供的簡化語法 // 宣告並初始化一個數字陣列 int[] nums = { 1, 2, 3, 4, 5 }; // 訪問 System.Array 的實例屬性 int len = nums.Length; ","date":"2022-06-09","objectID":"https://loulazynote.github.io/note/c#-%E5%9F%BA%E7%A4%8E%E8%A4%87%E7%BF%92/csharpbasicpart1/:1:6","tags":["Basic Level","C＃"],"title":"C# 基礎複習Note(型別系統)","uri":"https://loulazynote.github.io/note/c#-%E5%9F%BA%E7%A4%8E%E8%A4%87%E7%BF%92/csharpbasicpart1/"},{"categories":["C＃","Learning"],"content":"泛型類型 類型可以使用一或多個 類型參數 來宣告，做為實際型別的預留位置 建立 類型的實例時，可以指定清單將包含的物件類型，例如 string： // \u003c\u003e即為泛型,此處為 包含string型別的清單 List\u003cstring\u003e stringList = new List\u003cstring\u003e(); stringList.Add(\"String example\"); // compile time error adding a type other than a string: stringList.Add(4); 使用型別參數(\u003cT\u003e)讓您能夠重複使用相同的類別來保存任何元素型別，而不需要將每個元素都轉換成 object 泛型集合類別稱為 強型別集合 ，因為編譯器知道集合元素的特定類型 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/note/c#-%E5%9F%BA%E7%A4%8E%E8%A4%87%E7%BF%92/csharpbasicpart1/:1:7","tags":["Basic Level","C＃"],"title":"C# 基礎複習Note(型別系統)","uri":"https://loulazynote.github.io/note/c#-%E5%9F%BA%E7%A4%8E%E8%A4%87%E7%BF%92/csharpbasicpart1/"},{"categories":["C＃","Learning"],"content":"隱含型別、匿名型別和可為 Null 的實值型別 隱含型別 : 可以使用 var 隱含輸入區域變數（但不能輸入類別成員），其變數還是會在編譯時期收到型別，但其是由編譯器所提供的型別 匿名型別 : 針對不想要在外部方法 儲存或傳遞的簡單相關值集合，建立具名類型可能很不方便，為此，可以建立「匿名型別」 可為 Null 的實值型別 : 一般實值型別不能有 null 的值, 在類別後附加?後，允許建立可為 Null 的實值型別，例如， int? 是一種 int 類型，也可以有 值 null 可為 Null 的實值型別是泛型結構類型的 System.Nullable\u003cT\u003e 實例。 當您將資料傳入資料庫時，可為 Null 的實值型別特別有用，其中數值可能是 null ","date":"2022-06-09","objectID":"https://loulazynote.github.io/note/c#-%E5%9F%BA%E7%A4%8E%E8%A4%87%E7%BF%92/csharpbasicpart1/:1:8","tags":["Basic Level","C＃"],"title":"C# 基礎複習Note(型別系統)","uri":"https://loulazynote.github.io/note/c#-%E5%9F%BA%E7%A4%8E%E8%A4%87%E7%BF%92/csharpbasicpart1/"},{"categories":["C＃","Learning"],"content":"編譯時間類型和執行時間類型 變數可以有不同的編譯時間和執行時間類型 編譯時間類型是原始程式碼中變數的宣告或推斷類型 執行時間類型是該變數所參考之實例的類型 這兩種類型通常相同,Example: string message = \"This is a string of characters\"; 在其他情況下，編譯時間類型不同,Example: // 編譯時間類型位於 object, 執行時間類型為 string object anotherMessage = \"This is another string of characters\"; // 編譯時間類型位於 IEnumerable\u003cchar\u003e, 執行時間類型為 string IEnumerable\u003cchar\u003e someCharacters =\"abcdefghijklmnopqrstuvwxyz\"; 變數的兩種類型不同，請務必瞭解編譯時間類型和執行時間類型套用的時間，而編譯時間類型會決定編譯器所採取的所有動作 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/note/c#-%E5%9F%BA%E7%A4%8E%E8%A4%87%E7%BF%92/csharpbasicpart1/:1:9","tags":["Basic Level","C＃"],"title":"C# 基礎複習Note(型別系統)","uri":"https://loulazynote.github.io/note/c#-%E5%9F%BA%E7%A4%8E%E8%A4%87%E7%BF%92/csharpbasicpart1/"},{"categories":["C＃","Learning"],"content":"命名空間(宣告命名空間以組織類型) C# 程式設計大量使用命名空間的原因有兩個 .NET 會使用命名空間來組織其許多類別 // System 是命名空間，而 Console 是該命名空間中的類別 System.Console.WriteLine(\"Hello World!\"); // using關鍵字可用來讓完整名稱不需要 using System; Console.WriteLine(\"Hello World!\"); 宣告您自己的命名空間，將有助於在較大型的程式設計專案中控制類別和方法名稱的範圍 // 使用 namespace 關鍵字宣告命名空間 namespace SampleNamespace { class SampleClass { public void SampleMethod() { System.Console.WriteLine( \"SampleMethod inside SampleNamespace\"); } } } 命名空間的名稱必須是有效的 C# 識別碼名稱 // 從 C# 10 開始，您可以針對該檔案中定義的所有類型宣告命名空間 namespace SampleNamespace; class AnotherSampleClass { public void AnotherSampleMethod() { System.Console.WriteLine( \"SampleMethod inside SampleNamespace\"); } } ","date":"2022-06-09","objectID":"https://loulazynote.github.io/note/c#-%E5%9F%BA%E7%A4%8E%E8%A4%87%E7%BF%92/csharpbasicpart1/:2:0","tags":["Basic Level","C＃"],"title":"C# 基礎複習Note(型別系統)","uri":"https://loulazynote.github.io/note/c#-%E5%9F%BA%E7%A4%8E%E8%A4%87%E7%BF%92/csharpbasicpart1/"},{"categories":["C＃","Learning"],"content":"命名空間概觀 命名空間具有下列屬性： 命名空間可組織大型程式碼專案 它們會使用.運算子來分隔 using 指示詞讓其不需要指定每個類別的命名空間名稱 global 命名空間是 “root” 命名空間：global::System 一律會參考 .NET System 命名空間 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/note/c#-%E5%9F%BA%E7%A4%8E%E8%A4%87%E7%BF%92/csharpbasicpart1/:2:1","tags":["Basic Level","C＃"],"title":"C# 基礎複習Note(型別系統)","uri":"https://loulazynote.github.io/note/c#-%E5%9F%BA%E7%A4%8E%E8%A4%87%E7%BF%92/csharpbasicpart1/"},{"categories":["C＃","Learning"],"content":"類別 參考型別 : 定義為類別(Class)的類型是參考型別 執行時間，當宣告參考型別的變數時，該變數會包含值 null ，直到使用 new 運算子明確建立類別的實例，或指派可能已在其他地方建立之相容型別的物件 //Declaring an object of type MyClass. MyClass mc = new MyClass(); //Declaring another object of the same type, assigning it the value of the first object. MyClass mc2 = mc; 宣告類別 : 類別是使用 class 關鍵字來宣告，後面接著唯一識別碼 // class 關鍵字的前面會加上存取層級(public) // [access modifier] - [class] - [identifier] public class Customer { // 類別上的欄位、屬性、方法和事件統稱為「類別成員」 // Fields, properties, methods and events go here... } 建立物件 : 物件是根據類別的具體實體，而且有時稱為類別的執行個體 類別會定義一種類型的物件，但不是物件本身 // 使用 new 關鍵字來建立物件 // object1 是根據 Customer 之物件的參考 Customer object1 = new Customer(); // 可以建立物件參考，而根本不需要建立物件 Customer object2; 建立物件參考，如未參考上一個物件參考，嘗試透過這類參考來存取物件將會在執行時間失敗 //可以藉由建立新的物件，或為其指派現有的物件，來參考物件 Customer object3 = new Customer(); Customer object4 = object3; 類別繼承 : 類別完全支援「繼承」，這是物件導向程式設計的基礎特性 建立類別時，可以繼承自任何其他未定義為 sealed 的類別，而其他類別可以繼承自您的類別，並覆寫類別虛擬方法，且可以執行一或多個interface 使用「衍生」可完成繼承，這表示使用從中繼承資料和行為的「基底類別」來宣告類別。 附加冒號以及接著衍生類別名稱後面的基底類別名稱，以指定基底類別 類別宣告基底類別時，會繼承基底類別的所有成員，但建構函式除外 public class Manager : Employee { // Employee fields, properties, methods and events are inherited // New Manager fields, properties, methods and events go here... } 可用abstract 宣告類別 抽象類別包含具有簽章定義但沒有實作的抽象方法， 無法具現化抽象類別 它們僅用於實作抽象方法的衍生類別 與sealed類別相反，sealed不允許從它衍生其他類別 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/note/c#-%E5%9F%BA%E7%A4%8E%E8%A4%87%E7%BF%92/csharpbasicpart1/:3:0","tags":["Basic Level","C＃"],"title":"C# 基礎複習Note(型別系統)","uri":"https://loulazynote.github.io/note/c#-%E5%9F%BA%E7%A4%8E%E8%A4%87%E7%BF%92/csharpbasicpart1/"},{"categories":["C＃","Learning"],"content":"記錄 C# 中的 記錄 是一種 類別 或 結構 ，可提供使用資料模型的特殊語法和行為 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/note/c#-%E5%9F%BA%E7%A4%8E%E8%A4%87%E7%BF%92/csharpbasicpart1/:4:0","tags":["Basic Level","C＃"],"title":"C# 基礎複習Note(型別系統)","uri":"https://loulazynote.github.io/note/c#-%E5%9F%BA%E7%A4%8E%E8%A4%87%E7%BF%92/csharpbasicpart1/"},{"categories":["C＃","Learning"],"content":"使用記錄的時機 您想要定義相依于\"值相等“的資料模型 您想要定義物件為”不可變“的類型 實值相等 對於記錄而言，值相等表示如果類型相符且所有屬性和域值相符，則記錄類型的兩個變數會相等 對於其他參考型別（例如類別），相等表示 參考相等 並非所有資料模型都能搭配值相等來運作， 例如 : Entity Framework Core 取決於參考是否相等，以確保它只針對概念為一個實體的實體類型使用一個實例 ， 基於這個理由，記錄類型不適合用來做為 Entity Framework Core 中的實體類型 不變性 不可變的型別是一種可防止在物件具現化之後，變更該物件的任何屬性或域值 需要型別必須是安全線程，或者您是根據雜湊表中剩餘的雜湊碼而定時，永久性可能很有用(JWTToken、EnycrptPassword) 記錄提供簡潔的語法來建立和使用不可變的類型 永久性並不適用于所有資料案例， 例如 : Entity Framework Core不支援使用不可變的實體類型進行更新 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/note/c#-%E5%9F%BA%E7%A4%8E%E8%A4%87%E7%BF%92/csharpbasicpart1/:4:1","tags":["Basic Level","C＃"],"title":"C# 基礎複習Note(型別系統)","uri":"https://loulazynote.github.io/note/c#-%E5%9F%BA%E7%A4%8E%E8%A4%87%E7%BF%92/csharpbasicpart1/"},{"categories":["C＃","Learning"],"content":"記錄與類別和結構有何不同 宣告和具現化類別或結構的相同語法可用於記錄 只需以關鍵字取代 class ，或使用 record struct 取代 struct record 同樣地，記錄類別也支援用來表示繼承關聯性的相同語法 記錄與類別的差異如下： 您可以使用 位置參數 ，利用不可變的屬性來建立和具現化型別 在類別中指出參考相等或不相等的相同方法和運算子 (例如 Object.Equals(Object) 和 ==) ，表示記錄中的 Object.Equals(Object) 不相等 可以用 Object.Equals(Object)檢測是否相等 您可以使用 運算式來建立不可變物件的複本，並在選取的屬性中包含新的值 記錄的 ToString方法會建立格式化的字串，以顯示物件的類型名稱以及其所有公用屬性的名稱和值 記錄可以 繼承自另一個記錄， 記錄無法繼承自類別，而且類別無法繼承自記錄 記錄結構與結構的不同之處在於 編譯器合成了相等的方法和 ToString 編譯器為位置記錄結構合成 Deconstruct 方法 Example // 定義公開記錄 public record Person(string FirstName, string LastName); public static void Main() { // 使用位置參數來宣告和具現化記錄 Person person = new(\"Nancy\", \"Davolio\"); // 列印類型名稱和屬性值 Console.WriteLine(person); // output: Person { FirstName = Nancy, LastName = Davolio } } // 定義公開記錄 public record Person(string FirstName, string LastName, string[] PhoneNumbers); public static void Main() { var phoneNumbers = new string[2]; // 使用位置參數來宣告和具現化記錄 Person person1 = new(\"Nancy\", \"Davolio\", phoneNumbers); Person person2 = new(\"Nancy\", \"Davolio\", phoneNumbers); Console.WriteLine(person1 == person2); // output: True person1.PhoneNumbers[0] = \"555-1234\"; // 位置及長度相同 Console.WriteLine(person1 == person2); // output: True // 不同的執行個體也不為 null Console.WriteLine(ReferenceEquals(person1, person2)); // output: False } // 定義公開記錄 public record Person(string FirstName, string LastName) { public string[] PhoneNumbers { get; init; } } public static void Main() { Person person1 = new(\"Nancy\", \"Davolio\") { PhoneNumbers = new string[1] }; Console.WriteLine(person1); // output: Person { FirstName = Nancy, LastName = Davolio, PhoneNumbers = System.String[] } // 使用 with 運算式來複製不可變的物件，並變更其中一個屬性 Person person2 = person1 with { FirstName = \"John\" }; Console.WriteLine(person2); // output: Person { FirstName = John, LastName = Davolio, PhoneNumbers = System.String[] } Console.WriteLine(person1 == person2); // output: False person2 = person1 with { PhoneNumbers = new string[1] }; Console.WriteLine(person2); // output: Person { FirstName = Nancy, LastName = Davolio, PhoneNumbers = System.String[] } Console.WriteLine(person1 == person2); // output: False // 因 new string[1]是一個新的object與原object不相同 person2 = person1 with { }; Console.WriteLine(person1 == person2); // output: True // 因複製了卻無改變其值 } ","date":"2022-06-09","objectID":"https://loulazynote.github.io/note/c#-%E5%9F%BA%E7%A4%8E%E8%A4%87%E7%BF%92/csharpbasicpart1/:4:2","tags":["Basic Level","C＃"],"title":"C# 基礎複習Note(型別系統)","uri":"https://loulazynote.github.io/note/c#-%E5%9F%BA%E7%A4%8E%E8%A4%87%E7%BF%92/csharpbasicpart1/"},{"categories":["C＃","Learning"],"content":"介面(定義多個類型的行為) interface包含非抽象 類別(class) 或 結構(struct) 必須實作之相關功能群組的定義 interface可以定義 靜態(static) 必須具有實作的方法 從 C# 8.0 開始，interface可能會定義成員的預設實作 可以藉由使用interface，在類別中包含多個來源的行為(這項功能在 C# 中是很重要的，因為語言不支援類別的多重繼承) 如果要模擬結構繼承，則必須使用interface，因為它們實際上無法繼承自另一個結構或類別 使用 interface 關鍵字來定義interface: interface IEquatable\u003cT\u003e { bool Equals(T obj); } // 任何實作 IEquatable\u003cT\u003e `interface`的類別或結構，必須包含 Equals 方法的定義，該方法符合`interface`指定的簽章 interface的名稱必須是有效的 C# 識別碼名稱(依慣例，interface名稱以大寫字母 I 開頭) IEquatable\u003cT\u003e的定義沒有提供 Equals的實作 類別 或 結構 可以實現多個interface，但 類別 只能繼承自 單一類別 interface可以包含實作方法、屬性、事件、索引子，或這四個成員類型的任何組合 interface可能包含靜態建構函式、欄位、常數或運算子 C# 11 開始，不是欄位的interface成員可能是 static abstract interface不能包含實例欄位、實例建構函式或完成項(interface是無法被實例化的) interface成員預設為公用，而且可以明確指定協助工具修飾詞，EX: public 、 protected 、 internal 、 private 、 protected internal Or private protected 成員 private 必須具有預設實作 若要實作interface成員，實作類別的對應成員必須是公用、非靜態，且具有與interface成員相同的名稱和簽章 ❗ 當interface宣告靜態成員時，實作該interface的類型也可能宣告具有相同簽章的靜態成員， 這些是宣告成員的型別有所區別且是唯一識別的， 在型別中宣告的靜態成員 不會覆寫 interface中所宣告的靜態成員 ❗ class/struct繼承了interface必須實作該interface的所有成員，而不需要interface提供預設實作 如果基底類別實作interface，則衍生自基底類別的任何class/struct都會繼承該實作 interface也能繼承interface(一或多個) class/struct繼承了interface,而此interface如有繼承其他interface,則該class/struct必須實作出所有繼承鏈中所有interface的成員 該class/struct可能會隱含轉換成衍生interface或其任何基底interface class/struct可能透過基底類別包含interface多次，繼承或透過其他interface繼承的interface 只有在類別將interface宣告為類別 (class ClassName : InterfaceName) 定義的一部分時，類別只能提供interface實作一次 Example // 類別的屬性與索引子可以針對`interface`中定義的屬性或索引子定義額外的存取子 public class Car : IEquatable\u003cCar\u003e { // 實作`interface`的類別可以宣告具有 get 和 set 存取子的相同屬性 public string? Make { get; set; } public string? Model { get; set; } public string? Year { get; set; } // 屬性或索引子使用明確的實作，則存取子必須相符 // Implementation of IEquatable\u003cT\u003e interface public bool Equals(Car? car) { return (this.Make, this.Model, this.Year) == (car?.Make, car?.Model, car?.Year); } } 如果類別實作兩個具有相同簽章成員的介面，則在類別上實作該成員會造成這兩個介面都使用該成員進行實作 public interface IControl { void Paint(); } public interface ISurface { void Paint(); } public class SampleClass : IControl, ISurface { // Both ISurface.Paint and IControl.Paint call this method. public void Paint() { Console.WriteLine(\"Paint method in SampleClass\"); } } SampleClass sample = new SampleClass(); IControl control = sample; ISurface surface = sample; // The following lines all call the same method. sample.Paint(); control.Paint(); surface.Paint(); // Output: // Paint method in SampleClass // Paint method in SampleClass // Paint method in SampleClass 若要根據使用中的介面來呼叫不同的執行，可以明確地執行介面成員，明確的介面實作為僅透過指定介面呼叫的類別成員: public class SampleClass : IControl, ISurface { void IControl.Paint() { System.Console.WriteLine(\"IControl.Paint\"); } void ISurface.Paint() { System.Console.WriteLine(\"ISurface.Paint\"); } } 類別成員 IControl.Paint 只能透過 IControl 介面取得，ISurface.Paint 只能透過 ISurface 取得(這兩種方法都是分開的，而且不會直接在類別上使用) SampleClass sample = new SampleClass(); IControl control = sample; ISurface surface = sample; // The following lines all call the same method. //sample.Paint(); // Compiler error. control.Paint(); // Calls IControl.Paint on SampleClass. surface.Paint(); // Calls ISurface.Paint on SampleClass. // Output: // IControl.Paint // ISurface.Paint 若要同時執行這兩個介面，類別必須使用明確的實作為屬性 P 或方法 P （或兩者），以避免編譯器錯誤 interface ILeft { int P { get;} } interface IRight { int P(); } class Middle : ILeft, IRight { public int P() { return 0; } int ILeft.P { get { return 0; } } } 從 c # 8.0開始，可以為介面中所宣告的成員定義實作為 如果類別從介面繼承方法執行，則只能透過介面類別型的參考來存取該方法，繼承的成員不會顯示為公用介面的一部分 public interface IControl { void Paint() =\u003e Console.WriteLine(\"Default Paint method\"); } public class SampleClass : IControl { // Paint() is inherited from IControl. } var sample = new SampleClass(); //sample.Paint();// \"Paint\" isn't accessible. var control = sample as IControl; control.Paint(); // 任何實介面的類別 IControl 都可以覆寫預設 Paint 方法，例如公用方法，或做為明確的介面執行 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/note/c#-%E5%9F%BA%E7%A4%8E%E8%A4%87%E7%BF%92/csharpbasicpart1/:5:0","tags":["Basic Level","C＃"],"title":"C# 基礎複習Note(型別系統)","uri":"https://loulazynote.github.io/note/c#-%E5%9F%BA%E7%A4%8E%E8%A4%87%E7%BF%92/csharpbasicpart1/"},{"categories":["C＃","Learning"],"content":"泛型 泛型會將型別參數的概念引進 .NET，讓您能夠設計類別和方法來延遲一或多個型別的規格，直到用戶端程式代碼宣告並具現化類別或方法為止 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/note/c#-%E5%9F%BA%E7%A4%8E%E8%A4%87%E7%BF%92/csharpbasicpart1/:6:0","tags":["Basic Level","C＃"],"title":"C# 基礎複習Note(型別系統)","uri":"https://loulazynote.github.io/note/c#-%E5%9F%BA%E7%A4%8E%E8%A4%87%E7%BF%92/csharpbasicpart1/"},{"categories":["C＃","Learning"],"content":"藉由使用泛型型別參數 T ，您可以撰寫可供其他用戶端程式代碼使用的單一類別，而不會產生執行時間轉換或裝箱作業的成本或風險 // Declare the generic class. public class GenericList\u003cT\u003e { public void Add(T input) { } } class TestGenericList { private class ExampleClass { } static void Main() { // Declare a list of type int. GenericList\u003cint\u003e list1 = new GenericList\u003cint\u003e(); list1.Add(1); // Declare a list of type string. GenericList\u003cstring\u003e list2 = new GenericList\u003cstring\u003e(); list2.Add(\"\"); // Declare a list of type ExampleClass. GenericList\u003cExampleClass\u003e list3 = new GenericList\u003cExampleClass\u003e(); list3.Add(new ExampleClass()); } } 泛型類別和方法結合了重複使用性、型別安全和效率 泛型最常搭配在其上操作的集合和方法使用 System.Collections.Generic命名空間包含數個以泛型為基礎的集合類別 非泛型集合（例如 ArrayList ）不建議使用 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/note/c#-%E5%9F%BA%E7%A4%8E%E8%A4%87%E7%BF%92/csharpbasicpart1/:6:1","tags":["Basic Level","C＃"],"title":"C# 基礎複習Note(型別系統)","uri":"https://loulazynote.github.io/note/c#-%E5%9F%BA%E7%A4%8E%E8%A4%87%E7%BF%92/csharpbasicpart1/"},{"categories":["C＃","Learning"],"content":"建立自訂的泛型型別和方法，簡單的泛型類別 當 GenericArray\u003cT\u003e 以具象類型具現化時 (例如具現化為 GenericArray\u003cint\u003e)，所出現的每個 T 都會以 int 取代 public class GenericArray\u003cT\u003e { private T[] array; public GenericArray(int size) { array = new T[size + 1]; } public T getItem(int index) { return array[index]; } public void setItem(int index, T value) { array[index] = value; } } 使用泛型 GenericArray 類別並輸出結果: class Tester { static void Main(string[] args) { //declaring an int array MyGenericArray\u003cint\u003e intArray = new MyGenericArray\u003cint\u003e(5); //setting values for (int c = 0; c \u003c 5; c++) { intArray.setItem(c, c*5); } //retrieving the values for (int c = 0; c \u003c 5; c++) { Console.Write(intArray.getItem(c) + \" \"); } Console.WriteLine(); //declaring a character array MyGenericArray\u003cchar\u003e charArray = new MyGenericArray\u003cchar\u003e(5); //setting values for (int c = 0; c \u003c 5; c++) { charArray.setItem(c, (char)(c+97)); } //retrieving the values for (int c = 0; c\u003c 5; c++) { Console.Write(charArray.getItem(c) + \" \"); } Console.WriteLine(); Console.ReadKey(); } } //OutPut: //0 5 10 15 20 //a b c d e 泛型方法 Example 2: class Program { static void Swap\u003cT\u003e(ref T lhs, ref T rhs) { T temp; temp = lhs; lhs = rhs; rhs = temp; } static void Main(string[] args) { int a, b; char c, d; a = 10; b = 20; c = 'I'; d = 'V'; //display values before swap: Console.WriteLine(\"Int values before calling swap:\"); Console.WriteLine(\"a = {0}, b = {1}\", a, b); Console.WriteLine(\"Char values before calling swap:\"); Console.WriteLine(\"c = {0}, d = {1}\", c, d); //call swap Swap\u003cint\u003e(ref a, ref b); Swap\u003cchar\u003e(ref c, ref d); //display values after swap: Console.WriteLine(\"Int values after calling swap:\"); Console.WriteLine(\"a = {0}, b = {1}\", a, b); Console.WriteLine(\"Char values after calling swap:\"); Console.WriteLine(\"c = {0}, d = {1}\", c, d); Console.ReadKey(); } } /// OutPut: /// Int values before calling swap: /// a = 10, b = 20 /// Char values before calling swap: /// c = I, d = V /// Int values after calling swap: /// a = 20, b = 10 /// Char values after calling swap: /// c = V, d = I ","date":"2022-06-09","objectID":"https://loulazynote.github.io/note/c#-%E5%9F%BA%E7%A4%8E%E8%A4%87%E7%BF%92/csharpbasicpart1/:6:2","tags":["Basic Level","C＃"],"title":"C# 基礎複習Note(型別系統)","uri":"https://loulazynote.github.io/note/c#-%E5%9F%BA%E7%A4%8E%E8%A4%87%E7%BF%92/csharpbasicpart1/"},{"categories":["C＃","Learning"],"content":"泛型總覽 使用泛型型別以最佳化程式碼重複使用、型別安全和效能 泛型的最常見用法是建立集合類別 .NET 類別庫包含命名空間中 System.Collections.Generic 有數個泛型集合類別，應該盡可能使用泛型集合，而不是命名空間中 System.Collections 的類別 ArrayList 可以建立自己的泛型介面、類別、方法、事件和委派 泛型類別可限制為允許存取特定資料類型上的方法 泛型資料類型中所使用的類型相關資訊，可在執行階段透過反映取得 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/note/c#-%E5%9F%BA%E7%A4%8E%E8%A4%87%E7%BF%92/csharpbasicpart1/:6:3","tags":["Basic Level","C＃"],"title":"C# 基礎複習Note(型別系統)","uri":"https://loulazynote.github.io/note/c#-%E5%9F%BA%E7%A4%8E%E8%A4%87%E7%BF%92/csharpbasicpart1/"},{"categories":["C＃","Learning"],"content":"匿名類型 匿名類型提供一個便利的方法，將一組唯讀屬性封裝成一個物件，而不需要事先明確定義類型 類型名稱會由編譯器產生，並且無法在原始程式碼層級使用 每個屬性的類型會由編譯器推斷 // 以兩個名為 Amount 和 Message 的屬性初始化的匿名類型 var v = new { Amount = 108, Message = \"Hello\" }; // Rest the mouse pointer over v.Amount and v.Message in the following // statement to verify that their inferred types are int and string. Console.WriteLine(v.Amount + v.Message); 匿名型別通常用於查詢運算式的select子句中 ，以從來源序列中的每個物件傳回屬性的子集 匿名類型包含一個或多個公用唯讀屬性 其他類型的類別成員 (例如方法或事件) 則無效 用於初始化屬性的運算式不可以是 null、匿名函式或指標類型 var productQuery = from prod in products select new { prod.Color, prod.Price }; foreach (var v in productQuery) { Console.WriteLine(\"Color={0}, Price={1}\", v.Color, v.Price); } 可以使用 var 將變數宣告為隱含型別區域變數， 由於只有編譯器可以存取匿名類型的基本名稱，因此無法在變數宣告中指定類型名稱 // 合併隱含類型區域變數和隱含類型陣列，以建立匿名類型項目的陣列 var anonArray = new[] { new { name = \"apple\", diam = 4 }, new { name = \"grape\", diam = 1 }}; 匿名型別是class衍生自object的型別，而且不能轉換成除了object以外的任何類型 如果組件中有兩個或多個匿名物件初始設定式，指定了順序相同並具有相同名稱和類型的屬性序列，編譯器會將這些物件視為相同類型的執行個體 這些物件會共用編譯器產生的相同類型資訊 匿名型別以 運算式的形式支援非破壞性變化，這可建立匿名型別的新實例，其中一或多個屬性具有新的值 var apple = new { Item = \"apples\", Price = 1.35 }; var onSale = apple with { Price = 0.79 }; Console.WriteLine(apple); Console.WriteLine(onSale); 無法將欄位、屬性、事件或方法的傳回類型，宣告為具有匿名類型 無法將方法、屬性、建構函式或索引子的型式參數宣告為具有匿名類型 若要傳遞匿名型別或包含匿名型別的集合，做為方法的引數，可以將參數宣告為類型 object ❗ 針對匿名型別使用 object 會破壞強型別的目的 ❗ 如果必須在方法界限外儲存或傳遞查詢結果，請考慮使用一般具名結構或類別來取代匿名類型 匿名類型上的 Equals 和 GetHashCode 方法會以屬性的 Equals 和 GetHashCode 方法來定義，相同匿名類型的兩個執行個體僅在其所有屬性都相等時，這兩個執行個體才相等 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/note/c#-%E5%9F%BA%E7%A4%8E%E8%A4%87%E7%BF%92/csharpbasicpart1/:7:0","tags":["Basic Level","C＃"],"title":"C# 基礎複習Note(型別系統)","uri":"https://loulazynote.github.io/note/c#-%E5%9F%BA%E7%A4%8E%E8%A4%87%E7%BF%92/csharpbasicpart1/"},{"categories":["C＃","Learning"],"content":"參考資料 MSDN - C# 文件 Gitbook - C#教學 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/note/c#-%E5%9F%BA%E7%A4%8E%E8%A4%87%E7%BF%92/csharpbasicpart1/:8:0","tags":["Basic Level","C＃"],"title":"C# 基礎複習Note(型別系統)","uri":"https://loulazynote.github.io/note/c#-%E5%9F%BA%E7%A4%8E%E8%A4%87%E7%BF%92/csharpbasicpart1/"},{"categories":["C＃","Learning"],"content":"型別系統 概觀 ❗ 是強型別語言, 每個變數和常數都有型別 ❗ 在 C# bool 中無法轉換成 int 儲存在類型中的資訊可以包含下列 型別的變數需要的儲存空間 它可以代表的最大值和最小值 它所包含的成員 (方法、欄位、事件等等) 它繼承自的基底型別 interface (實作) 允許的作業類型 編譯器會將型別資訊視為中繼資料內嵌至可執行檔 通用語言執行平台 (CLR) 會在執行階段使用該中繼資料，以在它配置和回收記憶體時，進一步保證型別安全 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/csharpbasicpart1/:1:0","tags":["Basic Level","C＃"],"title":"C# 基礎複習Note(型別系統)","uri":"https://loulazynote.github.io/posts/csharpbasicpart1/"},{"categories":["C＃","Learning"],"content":"變數宣告中指定類型 ❗ 程式中宣告變數或常數時 必須指定其類型 ❗ 也能使用var關鍵字來讓編譯器推斷類型 // Declaration only string name; int studentId; AClass aclass; // Declaration with initializers (four examples) string studentName = \"Lou\"; string [] ClassList = {\"Elaine\",\"Louis\",\"Kyber\", \"Peter\",\"Jeff\",\"Mary\"} // 型別推斷 var query = ClassList.Where(q =\u003e q == studentName).First(); ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/csharpbasicpart1/:1:1","tags":["Basic Level","C＃"],"title":"C# 基礎複習Note(型別系統)","uri":"https://loulazynote.github.io/posts/csharpbasicpart1/"},{"categories":["C＃","Learning"],"content":"內建類型 C# 提供一組標準內建類型 整數 浮點值 布林運算式 文字字元 十進位值 string object ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/csharpbasicpart1/:1:2","tags":["Basic Level","C＃"],"title":"C# 基礎複習Note(型別系統)","uri":"https://loulazynote.github.io/posts/csharpbasicpart1/"},{"categories":["C＃","Learning"],"content":"自訂類型 可以使用 結構類型(struct)、 類別(Class) 、 interface(interface)、列舉 (enum) 和 記錄(record) 建構來建立您自己的自訂類型 當明確將專案參考新增至定義這些專案的元件時，其他專案才可用 編譯器在有該組件的參考之後，您可以針對在原始程式碼的那個組件中宣告的型別宣告變數 (或常數) .NET 類別庫本身是自訂類型的集合，可以在應用程式中使用 根據預設，類別庫中最常使用的型別可用於任何 C# 程式 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/csharpbasicpart1/:1:3","tags":["Basic Level","C＃"],"title":"C# 基礎複習Note(型別系統)","uri":"https://loulazynote.github.io/posts/csharpbasicpart1/"},{"categories":["C＃","Learning"],"content":"一般型別系統(CTS) 支援繼承原則 型別可以衍生自稱為「基底型別」的其他型別, 而衍生的型別會繼承 (有部份限制) 基底型別的方法、屬性和其他成員 基底型別同樣可以衍生自一些其他型別，所衍生的型別會繼承其繼承階層架構中兩個基底型別的成員 所有類型 最終衍生自單一基底類型，即 System.Object (C# 關鍵字：object) 這種統一型別階層架構稱為一般型別系統 (CTS) 一般型別系統 (CTS)中的每個型別都會定義為「實值型別」或「參考型別」 包括 .NET 類別庫中的所有自訂類型 使用者定義型別 使用 結構類型(struct) 關鍵字定義的類型為實值型別，所有內建的數數值型別都是 結構類型(struct) 使用 類別(class) 或 記錄(record) 關鍵字定義的類型是參考型別 參考型別和實值型別有不同的編譯時期規則和不同的執行階段行為 C# 9.0 新增 記錄型別 資料和行為是類別、結構或記錄 的成員 類別、結構或記錄宣告就像是用來在執行時間建立實例或物件的藍圖 //p 為 Person 的物件或執行個體 Person p = new Person(){ Name = \"Lou\", Age = 18 }; // 可以建立多個相同 Person 型別的執行個體，且每個執行個體在其屬性與欄位中都可以有不同的值 Person p2 = new Person(){ Name = \"Elaine\", Age = 18 }; // Person 的類別、結構 public class Person{ public string Name { get; set; } public int Age { get; set; } } 類別是參考型別 建立型別的物件時，指派物件的變數只會保留該記憶體的參考 當物件參考指派至新的變數時，新的變數會參考到原始物件 透過某個變數所做的變更會反映在其他變數中，因為它們都參考相同的資料 結構是實值型別 建立結構時，結構指派的變數會保留結構的實際資料 當結構指派給新的變數時，就會複製它 新的變數和原始變數會各自包含一份相同的資料，對一個複本所做的變更不會影響另一個複本 記錄類型可以是參考型別(record class)或實值型別(record struct) 類別 是用來建立更複雜的行為模型 類別通常會儲存在建立類別物件之後要修改的資料 結構 最適合小型資料結構 結構通常會儲存在建立結構之後不打算修改的資料 記錄類型 是具有其他編譯器合成成員的資料結構 記錄通常會儲存在建立物件之後不打算修改的資料 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/csharpbasicpart1/:1:4","tags":["Basic Level","C＃"],"title":"C# 基礎複習Note(型別系統)","uri":"https://loulazynote.github.io/posts/csharpbasicpart1/"},{"categories":["C＃","Learning"],"content":"值類型 實值型別衍生自 System.ValueType，該型別又衍生自 System.Object 實數值型別變數會直接包含其值 結構記憶體會內嵌配置於變數所宣告的任何內容中，實數值型別變數沒有個別的堆積配置或垃圾收集額外負荷 實值型別有兩種類別 實值型別為 密封, 無法從任何實值型別衍生型別 結構類型(struct) 列舉 (enum) // 內建的數數值型別是結構，而且其具有您可以存取的欄位和方法 // constant field on type byte. byte b = byte.MaxValue; // 宣告並指派值給它們，就像是簡單的非匯總類型 byte num = 0xA; int i = 5; char c = 'Z'; 使用 結構類型 來建立自訂實值型別: public struct Coords { public int x, y; public Coords(int p1, int p2) { x = p1; y = p2; } } 實值型別的另一個類別是 enum: // 列舉會定義一組具名的整數常數 public enum FileMode { CreateNew = 1, Create = 2, Open = 3, OpenOrCreate = 4, Truncate = 5, Append = 6, } ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/csharpbasicpart1/:1:5","tags":["Basic Level","C＃"],"title":"C# 基礎複習Note(型別系統)","uri":"https://loulazynote.github.io/posts/csharpbasicpart1/"},{"categories":["C＃","Learning"],"content":"參考型別 其定義為 類別(class), 記錄(record), 委派(delegate), 陣列(array)或 interface(interface)的類型是參考型別 參考型別完全支援繼承 當您建立類別時，可以繼承自未定義為 密封的任何其他interface或類別 其他類別可以繼承自您的類別，並覆寫您的虛擬方法 類別的建立和指派 Example: // 建立 MyClass myClass = new MyClass(); // 指派 MyClass myClass2 = myClass; interface(interface) 無法使用new 運算子直接具現化，請建立並指派實作 interface之類別的實例 Example: // 建立 MyClass myClass = new MyClass(); // 用現值宣告及賦值 IMyInterface myInterface = myClass; // 或 建立並賦值 給`interface` IMyInterface myInterface2 = new MyClass(); 所有陣列都是參考型別，即使其元素都是實值型別 陣列會隱含衍生自System.Array 類別，可以宣告並使用 搭配 C# 提供的簡化語法 // 宣告並初始化一個數字陣列 int[] nums = { 1, 2, 3, 4, 5 }; // 訪問 System.Array 的實例屬性 int len = nums.Length; ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/csharpbasicpart1/:1:6","tags":["Basic Level","C＃"],"title":"C# 基礎複習Note(型別系統)","uri":"https://loulazynote.github.io/posts/csharpbasicpart1/"},{"categories":["C＃","Learning"],"content":"泛型類型 類型可以使用一或多個 類型參數 來宣告，做為實際型別的預留位置 建立 類型的實例時，可以指定清單將包含的物件類型，例如 string： // \u003c\u003e即為泛型,此處為 包含string型別的清單 List\u003cstring\u003e stringList = new List\u003cstring\u003e(); stringList.Add(\"String example\"); // compile time error adding a type other than a string: stringList.Add(4); 使用型別參數(\u003cT\u003e)讓您能夠重複使用相同的類別來保存任何元素型別，而不需要將每個元素都轉換成 object 泛型集合類別稱為 強型別集合 ，因為編譯器知道集合元素的特定類型 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/csharpbasicpart1/:1:7","tags":["Basic Level","C＃"],"title":"C# 基礎複習Note(型別系統)","uri":"https://loulazynote.github.io/posts/csharpbasicpart1/"},{"categories":["C＃","Learning"],"content":"隱含型別、匿名型別和可為 Null 的實值型別 隱含型別 : 可以使用 var 隱含輸入區域變數（但不能輸入類別成員），其變數還是會在編譯時期收到型別，但其是由編譯器所提供的型別 匿名型別 : 針對不想要在外部方法 儲存或傳遞的簡單相關值集合，建立具名類型可能很不方便，為此，可以建立「匿名型別」 可為 Null 的實值型別 : 一般實值型別不能有 null 的值, 在類別後附加?後，允許建立可為 Null 的實值型別，例如， int? 是一種 int 類型，也可以有 值 null 可為 Null 的實值型別是泛型結構類型的 System.Nullable\u003cT\u003e 實例。 當您將資料傳入資料庫時，可為 Null 的實值型別特別有用，其中數值可能是 null ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/csharpbasicpart1/:1:8","tags":["Basic Level","C＃"],"title":"C# 基礎複習Note(型別系統)","uri":"https://loulazynote.github.io/posts/csharpbasicpart1/"},{"categories":["C＃","Learning"],"content":"編譯時間類型和執行時間類型 變數可以有不同的編譯時間和執行時間類型 編譯時間類型是原始程式碼中變數的宣告或推斷類型 執行時間類型是該變數所參考之實例的類型 這兩種類型通常相同,Example: string message = \"This is a string of characters\"; 在其他情況下，編譯時間類型不同,Example: // 編譯時間類型位於 object, 執行時間類型為 string object anotherMessage = \"This is another string of characters\"; // 編譯時間類型位於 IEnumerable\u003cchar\u003e, 執行時間類型為 string IEnumerable\u003cchar\u003e someCharacters =\"abcdefghijklmnopqrstuvwxyz\"; 變數的兩種類型不同，請務必瞭解編譯時間類型和執行時間類型套用的時間，而編譯時間類型會決定編譯器所採取的所有動作 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/csharpbasicpart1/:1:9","tags":["Basic Level","C＃"],"title":"C# 基礎複習Note(型別系統)","uri":"https://loulazynote.github.io/posts/csharpbasicpart1/"},{"categories":["C＃","Learning"],"content":"命名空間(宣告命名空間以組織類型) C# 程式設計大量使用命名空間的原因有兩個 .NET 會使用命名空間來組織其許多類別 // System 是命名空間，而 Console 是該命名空間中的類別 System.Console.WriteLine(\"Hello World!\"); // using關鍵字可用來讓完整名稱不需要 using System; Console.WriteLine(\"Hello World!\"); 宣告您自己的命名空間，將有助於在較大型的程式設計專案中控制類別和方法名稱的範圍 // 使用 namespace 關鍵字宣告命名空間 namespace SampleNamespace { class SampleClass { public void SampleMethod() { System.Console.WriteLine( \"SampleMethod inside SampleNamespace\"); } } } 命名空間的名稱必須是有效的 C# 識別碼名稱 // 從 C# 10 開始，您可以針對該檔案中定義的所有類型宣告命名空間 namespace SampleNamespace; class AnotherSampleClass { public void AnotherSampleMethod() { System.Console.WriteLine( \"SampleMethod inside SampleNamespace\"); } } ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/csharpbasicpart1/:2:0","tags":["Basic Level","C＃"],"title":"C# 基礎複習Note(型別系統)","uri":"https://loulazynote.github.io/posts/csharpbasicpart1/"},{"categories":["C＃","Learning"],"content":"命名空間概觀 命名空間具有下列屬性： 命名空間可組織大型程式碼專案 它們會使用.運算子來分隔 using 指示詞讓其不需要指定每個類別的命名空間名稱 global 命名空間是 “root” 命名空間：global::System 一律會參考 .NET System 命名空間 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/csharpbasicpart1/:2:1","tags":["Basic Level","C＃"],"title":"C# 基礎複習Note(型別系統)","uri":"https://loulazynote.github.io/posts/csharpbasicpart1/"},{"categories":["C＃","Learning"],"content":"類別 參考型別 : 定義為類別(Class)的類型是參考型別 執行時間，當宣告參考型別的變數時，該變數會包含值 null ，直到使用 new 運算子明確建立類別的實例，或指派可能已在其他地方建立之相容型別的物件 //Declaring an object of type MyClass. MyClass mc = new MyClass(); //Declaring another object of the same type, assigning it the value of the first object. MyClass mc2 = mc; 宣告類別 : 類別是使用 class 關鍵字來宣告，後面接著唯一識別碼 // class 關鍵字的前面會加上存取層級(public) // [access modifier] - [class] - [identifier] public class Customer { // 類別上的欄位、屬性、方法和事件統稱為「類別成員」 // Fields, properties, methods and events go here... } 建立物件 : 物件是根據類別的具體實體，而且有時稱為類別的執行個體 類別會定義一種類型的物件，但不是物件本身 // 使用 new 關鍵字來建立物件 // object1 是根據 Customer 之物件的參考 Customer object1 = new Customer(); // 可以建立物件參考，而根本不需要建立物件 Customer object2; 建立物件參考，如未參考上一個物件參考，嘗試透過這類參考來存取物件將會在執行時間失敗 //可以藉由建立新的物件，或為其指派現有的物件，來參考物件 Customer object3 = new Customer(); Customer object4 = object3; 類別繼承 : 類別完全支援「繼承」，這是物件導向程式設計的基礎特性 建立類別時，可以繼承自任何其他未定義為 sealed 的類別，而其他類別可以繼承自您的類別，並覆寫類別虛擬方法，且可以執行一或多個interface 使用「衍生」可完成繼承，這表示使用從中繼承資料和行為的「基底類別」來宣告類別。 附加冒號以及接著衍生類別名稱後面的基底類別名稱，以指定基底類別 類別宣告基底類別時，會繼承基底類別的所有成員，但建構函式除外 public class Manager : Employee { // Employee fields, properties, methods and events are inherited // New Manager fields, properties, methods and events go here... } 可用abstract 宣告類別 抽象類別包含具有簽章定義但沒有實作的抽象方法， 無法具現化抽象類別 它們僅用於實作抽象方法的衍生類別 與sealed類別相反，sealed不允許從它衍生其他類別 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/csharpbasicpart1/:3:0","tags":["Basic Level","C＃"],"title":"C# 基礎複習Note(型別系統)","uri":"https://loulazynote.github.io/posts/csharpbasicpart1/"},{"categories":["C＃","Learning"],"content":"記錄 C# 中的 記錄 是一種 類別 或 結構 ，可提供使用資料模型的特殊語法和行為 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/csharpbasicpart1/:4:0","tags":["Basic Level","C＃"],"title":"C# 基礎複習Note(型別系統)","uri":"https://loulazynote.github.io/posts/csharpbasicpart1/"},{"categories":["C＃","Learning"],"content":"使用記錄的時機 您想要定義相依于\"值相等“的資料模型 您想要定義物件為”不可變“的類型 實值相等 對於記錄而言，值相等表示如果類型相符且所有屬性和域值相符，則記錄類型的兩個變數會相等 對於其他參考型別（例如類別），相等表示 參考相等 並非所有資料模型都能搭配值相等來運作， 例如 : Entity Framework Core 取決於參考是否相等，以確保它只針對概念為一個實體的實體類型使用一個實例 ， 基於這個理由，記錄類型不適合用來做為 Entity Framework Core 中的實體類型 不變性 不可變的型別是一種可防止在物件具現化之後，變更該物件的任何屬性或域值 需要型別必須是安全線程，或者您是根據雜湊表中剩餘的雜湊碼而定時，永久性可能很有用(JWTToken、EnycrptPassword) 記錄提供簡潔的語法來建立和使用不可變的類型 永久性並不適用于所有資料案例， 例如 : Entity Framework Core不支援使用不可變的實體類型進行更新 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/csharpbasicpart1/:4:1","tags":["Basic Level","C＃"],"title":"C# 基礎複習Note(型別系統)","uri":"https://loulazynote.github.io/posts/csharpbasicpart1/"},{"categories":["C＃","Learning"],"content":"記錄與類別和結構有何不同 宣告和具現化類別或結構的相同語法可用於記錄 只需以關鍵字取代 class ，或使用 record struct 取代 struct record 同樣地，記錄類別也支援用來表示繼承關聯性的相同語法 記錄與類別的差異如下： 您可以使用 位置參數 ，利用不可變的屬性來建立和具現化型別 在類別中指出參考相等或不相等的相同方法和運算子 (例如 Object.Equals(Object) 和 ==) ，表示記錄中的 Object.Equals(Object) 不相等 可以用 Object.Equals(Object)檢測是否相等 您可以使用 運算式來建立不可變物件的複本，並在選取的屬性中包含新的值 記錄的 ToString方法會建立格式化的字串，以顯示物件的類型名稱以及其所有公用屬性的名稱和值 記錄可以 繼承自另一個記錄， 記錄無法繼承自類別，而且類別無法繼承自記錄 記錄結構與結構的不同之處在於 編譯器合成了相等的方法和 ToString 編譯器為位置記錄結構合成 Deconstruct 方法 Example // 定義公開記錄 public record Person(string FirstName, string LastName); public static void Main() { // 使用位置參數來宣告和具現化記錄 Person person = new(\"Nancy\", \"Davolio\"); // 列印類型名稱和屬性值 Console.WriteLine(person); // output: Person { FirstName = Nancy, LastName = Davolio } } // 定義公開記錄 public record Person(string FirstName, string LastName, string[] PhoneNumbers); public static void Main() { var phoneNumbers = new string[2]; // 使用位置參數來宣告和具現化記錄 Person person1 = new(\"Nancy\", \"Davolio\", phoneNumbers); Person person2 = new(\"Nancy\", \"Davolio\", phoneNumbers); Console.WriteLine(person1 == person2); // output: True person1.PhoneNumbers[0] = \"555-1234\"; // 位置及長度相同 Console.WriteLine(person1 == person2); // output: True // 不同的執行個體也不為 null Console.WriteLine(ReferenceEquals(person1, person2)); // output: False } // 定義公開記錄 public record Person(string FirstName, string LastName) { public string[] PhoneNumbers { get; init; } } public static void Main() { Person person1 = new(\"Nancy\", \"Davolio\") { PhoneNumbers = new string[1] }; Console.WriteLine(person1); // output: Person { FirstName = Nancy, LastName = Davolio, PhoneNumbers = System.String[] } // 使用 with 運算式來複製不可變的物件，並變更其中一個屬性 Person person2 = person1 with { FirstName = \"John\" }; Console.WriteLine(person2); // output: Person { FirstName = John, LastName = Davolio, PhoneNumbers = System.String[] } Console.WriteLine(person1 == person2); // output: False person2 = person1 with { PhoneNumbers = new string[1] }; Console.WriteLine(person2); // output: Person { FirstName = Nancy, LastName = Davolio, PhoneNumbers = System.String[] } Console.WriteLine(person1 == person2); // output: False // 因 new string[1]是一個新的object與原object不相同 person2 = person1 with { }; Console.WriteLine(person1 == person2); // output: True // 因複製了卻無改變其值 } ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/csharpbasicpart1/:4:2","tags":["Basic Level","C＃"],"title":"C# 基礎複習Note(型別系統)","uri":"https://loulazynote.github.io/posts/csharpbasicpart1/"},{"categories":["C＃","Learning"],"content":"介面(定義多個類型的行為) interface包含非抽象 類別(class) 或 結構(struct) 必須實作之相關功能群組的定義 interface可以定義 靜態(static) 必須具有實作的方法 從 C# 8.0 開始，interface可能會定義成員的預設實作 可以藉由使用interface，在類別中包含多個來源的行為(這項功能在 C# 中是很重要的，因為語言不支援類別的多重繼承) 如果要模擬結構繼承，則必須使用interface，因為它們實際上無法繼承自另一個結構或類別 使用 interface 關鍵字來定義interface: interface IEquatable\u003cT\u003e { bool Equals(T obj); } // 任何實作 IEquatable\u003cT\u003e `interface`的類別或結構，必須包含 Equals 方法的定義，該方法符合`interface`指定的簽章 interface的名稱必須是有效的 C# 識別碼名稱(依慣例，interface名稱以大寫字母 I 開頭) IEquatable\u003cT\u003e的定義沒有提供 Equals的實作 類別 或 結構 可以實現多個interface，但 類別 只能繼承自 單一類別 interface可以包含實作方法、屬性、事件、索引子，或這四個成員類型的任何組合 interface可能包含靜態建構函式、欄位、常數或運算子 C# 11 開始，不是欄位的interface成員可能是 static abstract interface不能包含實例欄位、實例建構函式或完成項(interface是無法被實例化的) interface成員預設為公用，而且可以明確指定協助工具修飾詞，EX: public 、 protected 、 internal 、 private 、 protected internal Or private protected 成員 private 必須具有預設實作 若要實作interface成員，實作類別的對應成員必須是公用、非靜態，且具有與interface成員相同的名稱和簽章 ❗ 當interface宣告靜態成員時，實作該interface的類型也可能宣告具有相同簽章的靜態成員， 這些是宣告成員的型別有所區別且是唯一識別的， 在型別中宣告的靜態成員 不會覆寫 interface中所宣告的靜態成員 ❗ class/struct繼承了interface必須實作該interface的所有成員，而不需要interface提供預設實作 如果基底類別實作interface，則衍生自基底類別的任何class/struct都會繼承該實作 interface也能繼承interface(一或多個) class/struct繼承了interface,而此interface如有繼承其他interface,則該class/struct必須實作出所有繼承鏈中所有interface的成員 該class/struct可能會隱含轉換成衍生interface或其任何基底interface class/struct可能透過基底類別包含interface多次，繼承或透過其他interface繼承的interface 只有在類別將interface宣告為類別 (class ClassName : InterfaceName) 定義的一部分時，類別只能提供interface實作一次 Example // 類別的屬性與索引子可以針對`interface`中定義的屬性或索引子定義額外的存取子 public class Car : IEquatable\u003cCar\u003e { // 實作`interface`的類別可以宣告具有 get 和 set 存取子的相同屬性 public string? Make { get; set; } public string? Model { get; set; } public string? Year { get; set; } // 屬性或索引子使用明確的實作，則存取子必須相符 // Implementation of IEquatable\u003cT\u003e interface public bool Equals(Car? car) { return (this.Make, this.Model, this.Year) == (car?.Make, car?.Model, car?.Year); } } 如果類別實作兩個具有相同簽章成員的介面，則在類別上實作該成員會造成這兩個介面都使用該成員進行實作 public interface IControl { void Paint(); } public interface ISurface { void Paint(); } public class SampleClass : IControl, ISurface { // Both ISurface.Paint and IControl.Paint call this method. public void Paint() { Console.WriteLine(\"Paint method in SampleClass\"); } } SampleClass sample = new SampleClass(); IControl control = sample; ISurface surface = sample; // The following lines all call the same method. sample.Paint(); control.Paint(); surface.Paint(); // Output: // Paint method in SampleClass // Paint method in SampleClass // Paint method in SampleClass 若要根據使用中的介面來呼叫不同的執行，可以明確地執行介面成員，明確的介面實作為僅透過指定介面呼叫的類別成員: public class SampleClass : IControl, ISurface { void IControl.Paint() { System.Console.WriteLine(\"IControl.Paint\"); } void ISurface.Paint() { System.Console.WriteLine(\"ISurface.Paint\"); } } 類別成員 IControl.Paint 只能透過 IControl 介面取得，ISurface.Paint 只能透過 ISurface 取得(這兩種方法都是分開的，而且不會直接在類別上使用) SampleClass sample = new SampleClass(); IControl control = sample; ISurface surface = sample; // The following lines all call the same method. //sample.Paint(); // Compiler error. control.Paint(); // Calls IControl.Paint on SampleClass. surface.Paint(); // Calls ISurface.Paint on SampleClass. // Output: // IControl.Paint // ISurface.Paint 若要同時執行這兩個介面，類別必須使用明確的實作為屬性 P 或方法 P （或兩者），以避免編譯器錯誤 interface ILeft { int P { get;} } interface IRight { int P(); } class Middle : ILeft, IRight { public int P() { return 0; } int ILeft.P { get { return 0; } } } 從 c # 8.0開始，可以為介面中所宣告的成員定義實作為 如果類別從介面繼承方法執行，則只能透過介面類別型的參考來存取該方法，繼承的成員不會顯示為公用介面的一部分 public interface IControl { void Paint() =\u003e Console.WriteLine(\"Default Paint method\"); } public class SampleClass : IControl { // Paint() is inherited from IControl. } var sample = new SampleClass(); //sample.Paint();// \"Paint\" isn't accessible. var control = sample as IControl; control.Paint(); // 任何實介面的類別 IControl 都可以覆寫預設 Paint 方法，例如公用方法，或做為明確的介面執行 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/csharpbasicpart1/:5:0","tags":["Basic Level","C＃"],"title":"C# 基礎複習Note(型別系統)","uri":"https://loulazynote.github.io/posts/csharpbasicpart1/"},{"categories":["C＃","Learning"],"content":"泛型 泛型會將型別參數的概念引進 .NET，讓您能夠設計類別和方法來延遲一或多個型別的規格，直到用戶端程式代碼宣告並具現化類別或方法為止 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/csharpbasicpart1/:6:0","tags":["Basic Level","C＃"],"title":"C# 基礎複習Note(型別系統)","uri":"https://loulazynote.github.io/posts/csharpbasicpart1/"},{"categories":["C＃","Learning"],"content":"藉由使用泛型型別參數 T ，您可以撰寫可供其他用戶端程式代碼使用的單一類別，而不會產生執行時間轉換或裝箱作業的成本或風險 // Declare the generic class. public class GenericList\u003cT\u003e { public void Add(T input) { } } class TestGenericList { private class ExampleClass { } static void Main() { // Declare a list of type int. GenericList\u003cint\u003e list1 = new GenericList\u003cint\u003e(); list1.Add(1); // Declare a list of type string. GenericList\u003cstring\u003e list2 = new GenericList\u003cstring\u003e(); list2.Add(\"\"); // Declare a list of type ExampleClass. GenericList\u003cExampleClass\u003e list3 = new GenericList\u003cExampleClass\u003e(); list3.Add(new ExampleClass()); } } 泛型類別和方法結合了重複使用性、型別安全和效率 泛型最常搭配在其上操作的集合和方法使用 System.Collections.Generic命名空間包含數個以泛型為基礎的集合類別 非泛型集合（例如 ArrayList ）不建議使用 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/csharpbasicpart1/:6:1","tags":["Basic Level","C＃"],"title":"C# 基礎複習Note(型別系統)","uri":"https://loulazynote.github.io/posts/csharpbasicpart1/"},{"categories":["C＃","Learning"],"content":"建立自訂的泛型型別和方法，簡單的泛型類別 當 GenericArray\u003cT\u003e 以具象類型具現化時 (例如具現化為 GenericArray\u003cint\u003e)，所出現的每個 T 都會以 int 取代 public class GenericArray\u003cT\u003e { private T[] array; public GenericArray(int size) { array = new T[size + 1]; } public T getItem(int index) { return array[index]; } public void setItem(int index, T value) { array[index] = value; } } 使用泛型 GenericArray 類別並輸出結果: class Tester { static void Main(string[] args) { //declaring an int array MyGenericArray\u003cint\u003e intArray = new MyGenericArray\u003cint\u003e(5); //setting values for (int c = 0; c \u003c 5; c++) { intArray.setItem(c, c*5); } //retrieving the values for (int c = 0; c \u003c 5; c++) { Console.Write(intArray.getItem(c) + \" \"); } Console.WriteLine(); //declaring a character array MyGenericArray\u003cchar\u003e charArray = new MyGenericArray\u003cchar\u003e(5); //setting values for (int c = 0; c \u003c 5; c++) { charArray.setItem(c, (char)(c+97)); } //retrieving the values for (int c = 0; c\u003c 5; c++) { Console.Write(charArray.getItem(c) + \" \"); } Console.WriteLine(); Console.ReadKey(); } } //OutPut: //0 5 10 15 20 //a b c d e 泛型方法 Example 2: class Program { static void Swap\u003cT\u003e(ref T lhs, ref T rhs) { T temp; temp = lhs; lhs = rhs; rhs = temp; } static void Main(string[] args) { int a, b; char c, d; a = 10; b = 20; c = 'I'; d = 'V'; //display values before swap: Console.WriteLine(\"Int values before calling swap:\"); Console.WriteLine(\"a = {0}, b = {1}\", a, b); Console.WriteLine(\"Char values before calling swap:\"); Console.WriteLine(\"c = {0}, d = {1}\", c, d); //call swap Swap\u003cint\u003e(ref a, ref b); Swap\u003cchar\u003e(ref c, ref d); //display values after swap: Console.WriteLine(\"Int values after calling swap:\"); Console.WriteLine(\"a = {0}, b = {1}\", a, b); Console.WriteLine(\"Char values after calling swap:\"); Console.WriteLine(\"c = {0}, d = {1}\", c, d); Console.ReadKey(); } } /// OutPut: /// Int values before calling swap: /// a = 10, b = 20 /// Char values before calling swap: /// c = I, d = V /// Int values after calling swap: /// a = 20, b = 10 /// Char values after calling swap: /// c = V, d = I ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/csharpbasicpart1/:6:2","tags":["Basic Level","C＃"],"title":"C# 基礎複習Note(型別系統)","uri":"https://loulazynote.github.io/posts/csharpbasicpart1/"},{"categories":["C＃","Learning"],"content":"泛型總覽 使用泛型型別以最佳化程式碼重複使用、型別安全和效能 泛型的最常見用法是建立集合類別 .NET 類別庫包含命名空間中 System.Collections.Generic 有數個泛型集合類別，應該盡可能使用泛型集合，而不是命名空間中 System.Collections 的類別 ArrayList 可以建立自己的泛型介面、類別、方法、事件和委派 泛型類別可限制為允許存取特定資料類型上的方法 泛型資料類型中所使用的類型相關資訊，可在執行階段透過反映取得 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/csharpbasicpart1/:6:3","tags":["Basic Level","C＃"],"title":"C# 基礎複習Note(型別系統)","uri":"https://loulazynote.github.io/posts/csharpbasicpart1/"},{"categories":["C＃","Learning"],"content":"匿名類型 匿名類型提供一個便利的方法，將一組唯讀屬性封裝成一個物件，而不需要事先明確定義類型 類型名稱會由編譯器產生，並且無法在原始程式碼層級使用 每個屬性的類型會由編譯器推斷 // 以兩個名為 Amount 和 Message 的屬性初始化的匿名類型 var v = new { Amount = 108, Message = \"Hello\" }; // Rest the mouse pointer over v.Amount and v.Message in the following // statement to verify that their inferred types are int and string. Console.WriteLine(v.Amount + v.Message); 匿名型別通常用於查詢運算式的select子句中 ，以從來源序列中的每個物件傳回屬性的子集 匿名類型包含一個或多個公用唯讀屬性 其他類型的類別成員 (例如方法或事件) 則無效 用於初始化屬性的運算式不可以是 null、匿名函式或指標類型 var productQuery = from prod in products select new { prod.Color, prod.Price }; foreach (var v in productQuery) { Console.WriteLine(\"Color={0}, Price={1}\", v.Color, v.Price); } 可以使用 var 將變數宣告為隱含型別區域變數， 由於只有編譯器可以存取匿名類型的基本名稱，因此無法在變數宣告中指定類型名稱 // 合併隱含類型區域變數和隱含類型陣列，以建立匿名類型項目的陣列 var anonArray = new[] { new { name = \"apple\", diam = 4 }, new { name = \"grape\", diam = 1 }}; 匿名型別是class衍生自object的型別，而且不能轉換成除了object以外的任何類型 如果組件中有兩個或多個匿名物件初始設定式，指定了順序相同並具有相同名稱和類型的屬性序列，編譯器會將這些物件視為相同類型的執行個體 這些物件會共用編譯器產生的相同類型資訊 匿名型別以 運算式的形式支援非破壞性變化，這可建立匿名型別的新實例，其中一或多個屬性具有新的值 var apple = new { Item = \"apples\", Price = 1.35 }; var onSale = apple with { Price = 0.79 }; Console.WriteLine(apple); Console.WriteLine(onSale); 無法將欄位、屬性、事件或方法的傳回類型，宣告為具有匿名類型 無法將方法、屬性、建構函式或索引子的型式參數宣告為具有匿名類型 若要傳遞匿名型別或包含匿名型別的集合，做為方法的引數，可以將參數宣告為類型 object ❗ 針對匿名型別使用 object 會破壞強型別的目的 ❗ 如果必須在方法界限外儲存或傳遞查詢結果，請考慮使用一般具名結構或類別來取代匿名類型 匿名類型上的 Equals 和 GetHashCode 方法會以屬性的 Equals 和 GetHashCode 方法來定義，相同匿名類型的兩個執行個體僅在其所有屬性都相等時，這兩個執行個體才相等 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/csharpbasicpart1/:7:0","tags":["Basic Level","C＃"],"title":"C# 基礎複習Note(型別系統)","uri":"https://loulazynote.github.io/posts/csharpbasicpart1/"},{"categories":["C＃","Learning"],"content":"參考資料 MSDN - C# 文件 Gitbook - C#教學 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/csharpbasicpart1/:8:0","tags":["Basic Level","C＃"],"title":"C# 基礎複習Note(型別系統)","uri":"https://loulazynote.github.io/posts/csharpbasicpart1/"},{"categories":["Kerberos"],"content":"Keberos 概述 Kerberos 是一種計算機網絡認證協議 它允許某實體在非安全網絡環境下通信 向另一個實體以一種安全的方式證明自己的身份 Kerberos 伺服器本身稱為鑰匙分配中心或 KDC 一般來說，KDC 除了發放票據與金鑰之外，同時也負責身份驗證的功能 (Authentication Server, AS) Kerberos 使用 Needham-Schroeder 協議作為基礎 它使用一個由兩個獨立的邏輯部分： 認證伺服器 票據授權伺服器 組成\"可信賴的第三方\" Kerberos 工作在用於證明用戶身份的\"票據\"基礎上 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/:1:0","tags":["Kerberos"],"title":"Single Sign On with Kerberos","uri":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/"},{"categories":["Kerberos"],"content":"Needham-Schroeder Needham 與 Schroeder 於 1978 年提出一種『多重盤問與回應』的認證協定，它不但可以避免重播攻擊，也可以解決相互認證的問題。 而協議的安全主要依賴於參加者對時間的鬆散同步和短周期的叫做 Kerberos 票據的認證聲明 下面為 Kerberos 內容名詞縮寫及解釋： AS（Authentication Server）: 認證伺服器 KDC（Key Distribution Center）: 鑰匙分配中心 TGS（Ticket Granting Server）: 票據授權伺服器 TGT（Ticket Granting Ticket）: 票據授權票據，票據的票據 ST（Service Ticket）: 服務門票 SS（Service Server）: 特定服務提供端 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/:1:1","tags":["Kerberos"],"title":"Single Sign On with Kerberos","uri":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/"},{"categories":["Kerberos"],"content":"認證伺服器（Authentication Server/AS） 相當於『鑰匙分配中心』（KDC） 管理每一個使用者的主密鑰（或稱共享密鑰） 欲加入的使用者都必須向 AS 伺服器申請帳戶並取得主密鑰 網路上任何一個使用者登入系統時，都會向認證中心取得通行證（Pass Book 或 TGT 票），有了通行證便可以在網路上索取所要的資源 簡單來說就是 驗證 Client 端的身份（確定你是身份證上的本人） 驗證通過就會給一張票證授予票證（Ticket Granting Ticket/TGT）給 Client ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/:1:2","tags":["Kerberos"],"title":"Single Sign On with Kerberos","uri":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/"},{"categories":["Kerberos"],"content":"鑰匙分配中心(Key Distribution Center/KDC) KDC 是一台伺服器，它與每位註冊的使用者分享不同的的私密對稱金鑰，當使用者第一次使用註冊時，這支金鑰可以利用人工輸入到伺服器 KDC 知道每位使用者的私密金鑰，而每位使用者可以使用此金鑰與 KDC 進行安全通訊 以 Star 星狀方式配置，從中心集中管理對外分散的 Key 採用 KDC 的管理方式可以減少 Key 的數量，它將所有的 Key 集中到一個中心點因此降降低了 Key 的數目，n 個 node 只需要 n 把 Key 即可，以 5 個點的拓樸系統來看只需要 5 把 Key，因此大大的降低系統對 Key 的需求 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/:1:3","tags":["Kerberos"],"title":"Single Sign On with Kerberos","uri":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/"},{"categories":["Kerberos"],"content":"票據授權伺服器（Ticket Granting Server/TGS） TGS 管理網路上所有服務伺服器，並紀錄所有服務伺服器的秘密鑰匙 當有新的伺服器加入或退出時，都必須向 TGS 伺服器申請 而且某一秘密鑰匙也只有 TGS 伺服器和該服務伺服器兩者所擁有，因此 TGS 伺服器必須管理網路上所有伺服器的秘密鑰匙 使用者如要存取服務伺服器上資源時，必須向 TGS 提出它的身份證明，即 TGT 門票。 TGT 門票是經過 TGS 伺服器的秘密鑰匙加密，因此只有 TGS 伺服器能觀察門票的內容，別人無法仿冒 TGS 伺服器驗證完使用者的通行證後，再發給使用者有關使用者本身和所欲要求的服務伺服器的『服務門票』（Service Ticket, ST） 有了 ST 門票之後，使用者才可以到服務伺服器上存取資源，ST 門票同時包含了會議鑰匙 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/:1:4","tags":["Kerberos"],"title":"Single Sign On with Kerberos","uri":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/"},{"categories":["Kerberos"],"content":"票據授權票據，票據的票據（Ticket Granting Ticket/TGT） 此票是由 AS 伺服器發給客戶端的身分證明使用；使用者可以持此票向 TGS 伺服器申請通往某一伺服器的請求 Kerberos 協議將 TGT 的使用設計成可以避免經常向用戶詢問密碼（Kerberos 用來派生主密鑰的密碼）或將主密鑰存儲在工作站上 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/:1:5","tags":["Kerberos"],"title":"Single Sign On with Kerberos","uri":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/"},{"categories":["Kerberos"],"content":"服務門票（Service Ticket/ST） 當使用者出示 TGT 門票，向 TGS 伺服器要求前往某一伺服器 如果 TGS 伺服器同意其要求時，則發給所要求伺服器的 ST 門票給使用者，使用者持此票即可要求該伺服器提供服務 ST（Service Ticket）也有資料稱為 TGS Ticket ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/:1:6","tags":["Kerberos"],"title":"Single Sign On with Kerberos","uri":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/"},{"categories":["Kerberos"],"content":"Keberos 流程關係 消息 A：使用 Client/User 的秘密密鑰加密的 Client/TGS Session Key。 消息 B：使用 TGS 的密鑰加密的票證授予票證。 消息 C：由消息 B 的 TGT 和所請求服務的 ID 組成。 消息 D：使用 Client/TGS 會話密鑰加密的身份驗證器。 消息 E：使用服務的秘密密鑰加密的 Client 到 Server 票證。 消息 F：使用 Client/TGS Session Key 加密的 Client/Server Session Key。 消息 G：一個新的身份驗證器，其中包括 Client ID，時間戳記，並使用 Client/Server Session Key 進行了加密。 消息 H：在 Client 的身份驗證器中找到的時間戳已使用 Client/Server Session Key 進行了加密。 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/:1:7","tags":["Kerberos"],"title":"Single Sign On with Kerberos","uri":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/"},{"categories":["Kerberos"],"content":"名詞解釋 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/:2:0","tags":["Kerberos"],"title":"Single Sign On with Kerberos","uri":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/"},{"categories":["Kerberos"],"content":"Principal Kerberos principal（又稱為主體）用於在 kerberos 加密系統中標記一個唯一的身份 主體可以是用戶（如 louis）或服務（如 namenode 或 hive） 根據約定，主體名稱分為三個部分： 主名稱、實例和領域。 例如，典型的 Kerberos 主體可以是 louis/admin@EXAMPLE.COM ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/:2:1","tags":["Kerberos"],"title":"Single Sign On with Kerberos","uri":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/"},{"categories":["Kerberos"],"content":"keytab keytab 是包含 principals 和加密 principal key 的文件 \u003e keytab 用於將 SSO 帶到未加入 AD domain 的應用程序 keytab 文件對於每個 host 是唯一的，因為 key 中包含 hostname keytab 文件用於不需要人工交互和保存純文本密碼，實現到 kerberos 上驗證一個主機上的 principal 因為 Server 上可以訪問 keytab 文件即可以以 principal 的身份通過 kerberos 的認證，所以，keytab 文件應該被妥善保存，應該只有少數的用戶可以訪問 如何產生 Keytab? 使用實用程序 KTPASS.EXE 它是 RSAT 的一部分，如果啟用了 Active Directory 目錄服務工具將顯示在 RSAT 中 ktpass /out app1.keytab /princ http/app1.verenatex.com@verenatex.com /mapuser app1 /crypto AES256-SHA1 /ptype KRB5_NT_PRINCIPAL /pass Password2 /target vdc01.verenatex.com /out 指定輸出文件的名稱，如 app1.keytab /princ 指定 userPrincipalName 以及將其添加到對映帳戶的 servicePrincipalName 的值 /mapuser 是將為其生成 Keytab 的帳戶 /crypto 是用於 Keytab 的加密類型，此處為 AES256-SHA1 /ptype 通常應使用 KRB5_NT_PRINCIPAL，除非應用程序文檔另有說明 /pass 是對應帳戶的新密碼（默認情況下，它將執行密碼重置操作） /target 用於指示將查詢哪個 domain 控制器(it is optional, but can be useful if you have more than one domain in your forest) ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/:2:2","tags":["Kerberos"],"title":"Single Sign On with Kerberos","uri":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/"},{"categories":["Kerberos"],"content":"Single Sign-On (SSO) 單一登錄（SSO）協議（Kerberos，SAML，OpenID 等）允許用戶使用單個 ID 和密碼來訪問不同的應用程序。用戶登錄以獲得對連接系統的訪問權限，或者使用輕型目錄訪問協議（LDAP）和（目錄）服務器上存儲的 LDAP 數據庫來完成訪問。 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/:3:0","tags":["Kerberos"],"title":"Single Sign On with Kerberos","uri":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/"},{"categories":["Kerberos"],"content":"SPNEGO SPNEGO 代表\"簡單和受保護的 GSS_API 協商機制\"，用於擴展基於 Kerberos 的 SSO 環境以用於 Web Application，因為 SPNEGO 被設計用於 Client Server 桌面環境，通常不用於 Web Application 或簡易 Client 環境 Spnego 是一種與身份驗證器協商使用哪種安全協議的機制 例如 Kerberos，NTLM，摘要或 Basic.5t6 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/:4:0","tags":["Kerberos"],"title":"Single Sign On with Kerberos","uri":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/"},{"categories":["Kerberos"],"content":"SPN(Service Principal Names) 服務主體名稱 (SPN) 是服務實例的唯一標識符 Kerberos 身份驗證使用 SPN 將服務實例與服務登錄帳戶關聯 這允許用戶端應用程式請求服務對帳戶進行身份驗證，即使客戶端沒有帳戶名稱 如果在整個林中的電腦上安裝多個服務實例，則每個實例必須有自己的 SPN 如果用戶端可能使用多個名稱進行身份驗證，則給定的服務實例可以有多個 SPN 例如，SPN 始終包含運行服務實例的主機的名稱，因此服務實例可能會為其主機的每個名稱或別名註冊 SPN 在 Kerberos 身份驗證服務可以使用 SPN 對服務進行身份驗證之前，必須在服務實例用於登錄的帳戶物件上註冊 SPN 給定的 SPN 只能在一個帳戶上註冊 對於 Win32 服務，服務安裝程式在安裝服務實例時指定登錄帳戶 然後，安裝程式組成 SPN，並將它們作為活動目錄域服務中的帳戶物件的屬性編寫 如果服務實例的登錄帳戶發生更改，則必須在新帳戶下重新註冊 SPN 當用戶端想要連接到服務時，它會查找服務的實例，為該實例編寫 SPN，連接到該服務，並顯示用於服務的 SPN 進行身份驗證 Client 上的 Application（例如 Browser）嘗試訪問 Web Server 上的受保護頁面 Server 響應要求授權 Application 從 Kerberos KDC 請求 Service ticket 獲得 ticket 後，Application 將其包裝為 SPNEGO 格式的請求，然後通過 Browser 將其發送回 Web Application 執行已部署的 Web Application 的 web container（Tomcat、JBoss EAP 等）對請求進行解包並驗證 ticket 認證成功後，將授予訪問權限 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/:5:0","tags":["Kerberos"],"title":"Single Sign On with Kerberos","uri":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/"},{"categories":["Kerberos"],"content":"Browser 如何透過 Kerberos 進行身分驗證 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/:6:0","tags":["Kerberos"],"title":"Single Sign On with Kerberos","uri":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/"},{"categories":["Kerberos"],"content":"循序圖 User 登錄 Windows，並通過 KDC 進行了身份驗證(對於 Windows，KDC 將是主域控制器) OS 為 User 接收一個 TGT token 當 User 嘗試連接到 Tomcat 服務器(或其他 web container)時，將協商身份驗證機制(紅字原文: the authentication mechanism is negotiated) User 的 token 被傳遞給 Tomcat，然後 Tomcat 通過 KDC 對其進行驗證 驗證 User 身份後，Tomcat 隨後從 LDAP 服務器中檢索其角色（在 Windows 中為 Active Directory，這是一種專門處理諸如用戶名和密碼之類的身份信息的數據庫） 並確定他是否有權訪問（Response 200 OK）他在服務器上請求的資源。 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/:6:1","tags":["Kerberos"],"title":"Single Sign On with Kerberos","uri":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/"},{"categories":["Kerberos"],"content":"參考資料 Setting up Kerberos Authentication for a Website in IIS Single Sign On with Kerberos Kerberos Wikipedia 鳥哥的 Linux 私房菜 看完您如果還不明白 Kerberos 原理，算我輸 翻轉工作室-資訊與網路安全技術：第十四章 Kerberos 認證系統 The Secret Security Wiki Kerberos.NET Guide To Setup Kerberos Single Sign-On (SSO) 瞭解 keytab 需求 宅學習 如何使用 Spn，當您在 [網際網路資訊服務上設定 裝載的 Web 應用程式] Microsoft Developer-Service Principal Names 瞭解 keytab 需求 All you need to know about Keytab files ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/:7:0","tags":["Kerberos"],"title":"Single Sign On with Kerberos","uri":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/"},{"categories":["C＃","Maintain","Asp.Net"],"content":"Filter Filter 的作用是在 Action 執行前或執行後做一些加工處理 Authorization Filter： Authorization 是五種 Filter 中優先序最高的，通常用於驗證 Request 合不合法，不合法後面就直接跳過。 Resource Filter： Resource 是第二優先，會在 Authorization 之後，Model Binding 之前執行。通常會是需要對 Model 加工處裡才用。 Action Filter： 最容易使用的 Filter，封包進出都會經過它，使用上沒什麼需要特別注意的。跟 Resource Filter 很類似，但並不會經過 Model Binding。 Exception Filter： 異常處理的 Exception。 Result Filter： 當 Action 完成後，最終會經過的 Filter。 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/mvc5_meta/:1:0","tags":["Asp.Net MVC"],"title":"MVC 5 filter","uri":"https://loulazynote.github.io/posts/mvc5_meta/"},{"categories":["C＃","Maintain","Asp.Net"],"content":"運作方式 ASP .NET Core 的每個 Request 都會先經過已註冊的 Middleware 接著才會執行 Filter，除了會依照上述的順序外，同類型的 Filter 預設都會以先進後出的方式處裡封包。 Response 在某些 Filter 並不會做處理，會值接 Bypass。Request 及 Response 的運作流程如下圖： 黃色箭頭是正常情況流程 灰色箭頭是異常處理流程 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/mvc5_meta/:1:1","tags":["Asp.Net MVC"],"title":"MVC 5 filter","uri":"https://loulazynote.github.io/posts/mvc5_meta/"},{"categories":["C＃","Maintain","Asp.Net"],"content":"參考資料 John Wu’s [鐵人賽 Day14] ASP.NET Core 2 系列 - Filters ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/mvc5_meta/:2:0","tags":["Asp.Net MVC"],"title":"MVC 5 filter","uri":"https://loulazynote.github.io/posts/mvc5_meta/"},{"categories":["Learning"],"content":"位於索引中的檔案 : Tracked files(追蹤的檔案) 不再索引內的檔案 : Untracked files(未被追蹤的檔案) working tree 是工作目錄 只要 被索引中的檔案內容 跟 工作目錄中的檔案內容一致 就會被稱為一個 “Stage“狀態 只要 被索引中的檔案內容 跟 工作目錄中的檔案內容不一致 就會被稱為一個 “Unstage“狀態 ","date":"2022-06-08","objectID":"https://loulazynote.github.io/posts/git-learning/:0:0","tags":["Git"],"title":"Git 學習筆記","uri":"https://loulazynote.github.io/posts/git-learning/"},{"categories":["Learning"],"content":"Git 指令 Command: git -m = message init = 建立 add = 加入 GIT 索引 rm = 刪除 status = 看目前狀態 ","date":"2022-06-08","objectID":"https://loulazynote.github.io/posts/git-learning/:1:0","tags":["Git"],"title":"Git 學習筆記","uri":"https://loulazynote.github.io/posts/git-learning/"},{"categories":["Learning"],"content":"git diff 顯示差異 HEAD = 比對變更與目前最新版的變更差異 -cached = 索引裡的變更與本地儲存庫最新的變更差異 --binary = 比對二進位檔案差異 --name-only = 比對工作目錄檔案,列出檔案名稱 --name-status = 列出工作目錄及索引之間有多少檔案是被異動的 git diff 'src-commit' 'tgt-commit' commit 與 commit 比較差異 git diff 'commit' 與目標 commit 差異 ","date":"2022-06-08","objectID":"https://loulazynote.github.io/posts/git-learning/:1:1","tags":["Git"],"title":"Git 學習筆記","uri":"https://loulazynote.github.io/posts/git-learning/"},{"categories":["Learning"],"content":"git reset 重置索引 -p = 選取索引中的那些變更有哪些內容要從索引中移除 HEAD = 重置索引及分支(加 ~1 是恢復前一版本,以此類推) --mixed = 重置 HEAD 及索引(預設值) --hard = 重置 HEAD,索引及工作目錄 --hard ORIG_HEAD = 回復前版本(永遠回復 reset 之前的版本) ","date":"2022-06-08","objectID":"https://loulazynote.github.io/posts/git-learning/:1:2","tags":["Git"],"title":"Git 學習筆記","uri":"https://loulazynote.github.io/posts/git-learning/"},{"categories":["Learning"],"content":"git revert 還原歷史上的版本，做相反的 commit -h = help 列出功能 --abort = 取消 --continue = 繼續 --quit = 停止 ","date":"2022-06-08","objectID":"https://loulazynote.github.io/posts/git-learning/:1:3","tags":["Git"],"title":"Git 學習筆記","uri":"https://loulazynote.github.io/posts/git-learning/"},{"categories":["Learning"],"content":"git clone 下載遠端儲存庫 git clone --no-checkout 'URL' 'Filename' 會以 filename 為主並且不做 checkout git clone --bare 'url' 把儲存庫的本身下載下來 ","date":"2022-06-08","objectID":"https://loulazynote.github.io/posts/git-learning/:1:4","tags":["Git"],"title":"Git 學習筆記","uri":"https://loulazynote.github.io/posts/git-learning/"},{"categories":["Learning"],"content":"git log 看紀錄 --oneline = 短的 log 版本 --oneline --graph = log 版本+線圖可加 “-數字” 以顯示筆數 git log --oneline --graph --all -10 全部的歷史資料取 10 筆 ","date":"2022-06-08","objectID":"https://loulazynote.github.io/posts/git-learning/:1:5","tags":["Git"],"title":"Git 學習筆記","uri":"https://loulazynote.github.io/posts/git-learning/"},{"categories":["Learning"],"content":"git reflog 會記錄工作目錄底下做過的每一次的版控紀錄 ","date":"2022-06-08","objectID":"https://loulazynote.github.io/posts/git-learning/:1:6","tags":["Git"],"title":"Git 學習筆記","uri":"https://loulazynote.github.io/posts/git-learning/"},{"categories":["Learning"],"content":"git checkout 取出/取回 -- 'name' = 從索引裡面把 name 檔案的內容整個複製回工作目錄 --orphan = 建立全新分支且沒有 parents checkout -b \"Filename\" 可以新增分支後切換 ","date":"2022-06-08","objectID":"https://loulazynote.github.io/posts/git-learning/:1:7","tags":["Git"],"title":"Git 學習筆記","uri":"https://loulazynote.github.io/posts/git-learning/"},{"categories":["Learning"],"content":"git switch 切換分支 ","date":"2022-06-08","objectID":"https://loulazynote.github.io/posts/git-learning/:1:8","tags":["Git"],"title":"Git 學習筆記","uri":"https://loulazynote.github.io/posts/git-learning/"},{"categories":["Learning"],"content":"git clean 清除工作目錄 -f = 強制刪除 -d = 刪除整個工作目錄 -x = 執行清除任務,並忽略.gitignore 設定 -n = 看那些檔案會被清除 ","date":"2022-06-08","objectID":"https://loulazynote.github.io/posts/git-learning/:1:9","tags":["Git"],"title":"Git 學習筆記","uri":"https://loulazynote.github.io/posts/git-learning/"},{"categories":["Learning"],"content":"git stash 暫存工作目錄的變更 save 'message' = 暫存 pop = 取回暫存 ","date":"2022-06-08","objectID":"https://loulazynote.github.io/posts/git-learning/:1:10","tags":["Git"],"title":"Git 學習筆記","uri":"https://loulazynote.github.io/posts/git-learning/"},{"categories":["Learning"],"content":"git branch 查看分支/新增分支 -d = 刪除分支(只能刪除已經合併的分支) -D = 強制刪除分支 -r = 列出所有遠端追蹤分支 -a = 列出所有遠端+本地分支 git branch --merged 列出所有已合併過的分支 git branch --no-merged 列出所有未合併過的分支 git branch --merged | egrep -v \"(^\\*|master|develop)\" | xargs git branch -d 刪除所有已合併過的分支(CMD/Powershell 不可用) ","date":"2022-06-08","objectID":"https://loulazynote.github.io/posts/git-learning/:1:11","tags":["Git"],"title":"Git 學習筆記","uri":"https://loulazynote.github.io/posts/git-learning/"},{"categories":["Learning"],"content":"git merge 合併分支 --ff = 快轉合併(預設) --no-ff = 非快轉合併 --ff-only = 僅有快轉合併 --no-commit = 不提交的合併 --abort = 放棄合併 --squash = 壓縮後合併(不可以與關閉快轉機制一起使用,且不會有合併線圖出現) git merge --no-ff --no-commit 'branchName' 合併可以不 commit ","date":"2022-06-08","objectID":"https://loulazynote.github.io/posts/git-learning/:1:12","tags":["Git"],"title":"Git 學習筆記","uri":"https://loulazynote.github.io/posts/git-learning/"},{"categories":["Learning"],"content":"git rebase 'commit_id' 重訂基底合併 -i --continue = 繼續 --skip = --abort = 取消 ","date":"2022-06-08","objectID":"https://loulazynote.github.io/posts/git-learning/:1:13","tags":["Git"],"title":"Git 學習筆記","uri":"https://loulazynote.github.io/posts/git-learning/"},{"categories":["Learning"],"content":"git cherry-pick 正向挑選合併 --continue = 繼續 --quit = 停止 --abort = 取消 ","date":"2022-06-08","objectID":"https://loulazynote.github.io/posts/git-learning/:1:14","tags":["Git"],"title":"Git 學習筆記","uri":"https://loulazynote.github.io/posts/git-learning/"},{"categories":["Learning"],"content":"git push 推送至遠端 --all = 全部分支推送 git push -u origin master 將本地分支(master)與遠端分支(origin)建立連結 git push origin --delete ‘branchName’ 刪除遠端分支(要先把本地刪除) ","date":"2022-06-08","objectID":"https://loulazynote.github.io/posts/git-learning/:1:15","tags":["Git"],"title":"Git 學習筆記","uri":"https://loulazynote.github.io/posts/git-learning/"},{"categories":["Learning"],"content":"git fetch 將遠端儲存庫的變更下載回來 --prune 將遠端已刪除的分支剪除 ","date":"2022-06-08","objectID":"https://loulazynote.github.io/posts/git-learning/:1:16","tags":["Git"],"title":"Git 學習筆記","uri":"https://loulazynote.github.io/posts/git-learning/"},{"categories":["Learning"],"content":"git pull 將遠端儲存庫拉下來 pull = git fetch + git merge git pull --rebase = git fetch + git rebase ","date":"2022-06-08","objectID":"https://loulazynote.github.io/posts/git-learning/:1:17","tags":["Git"],"title":"Git 學習筆記","uri":"https://loulazynote.github.io/posts/git-learning/"},{"categories":["Learning"],"content":"git remote 遠端 -v = 列出網址 -h = remote 的 help set-url = 更改網址 git remote set-url origin 'new url' 將舊網址改成新網址 ","date":"2022-06-08","objectID":"https://loulazynote.github.io/posts/git-learning/:1:18","tags":["Git"],"title":"Git 學習筆記","uri":"https://loulazynote.github.io/posts/git-learning/"},{"categories":["Learning"],"content":"git commit 建立版本 ","date":"2022-06-08","objectID":"https://loulazynote.github.io/posts/git-learning/:1:19","tags":["Git"],"title":"Git 學習筆記","uri":"https://loulazynote.github.io/posts/git-learning/"},{"categories":["Learning"],"content":"git apply 套用版本(進版) --check = 確認檔案 --reverse = 退版(簡寫-R) ","date":"2022-06-08","objectID":"https://loulazynote.github.io/posts/git-learning/:1:20","tags":["Git"],"title":"Git 學習筆記","uri":"https://loulazynote.github.io/posts/git-learning/"},{"categories":["Learning"],"content":"git config GIT 的設定 加上 --global 可以設定 core.quotepath = 改 false 可顯示中文 core.editor = 查看目前編輯器 git 只能顯示 ASCII 的字元 git bash 以外的環境要改中文 set LC_ALL=C.UTF-8 更改環境變數 (永久儲存) setx LC_ALL C.UTF-8 MAC/Linux export LC_ALL=C.UTF-8 ","date":"2022-06-08","objectID":"https://loulazynote.github.io/posts/git-learning/:1:21","tags":["Git"],"title":"Git 學習筆記","uri":"https://loulazynote.github.io/posts/git-learning/"},{"categories":["Learning"],"content":"衝突問題 顯示訊息: content = 內容衝突 建議用手動合併 ","date":"2022-06-08","objectID":"https://loulazynote.github.io/posts/git-learning/:2:0","tags":["Git"],"title":"Git 學習筆記","uri":"https://loulazynote.github.io/posts/git-learning/"},{"categories":["Learning"],"content":"參考資料 為自己學 GIT-另一種合併方式（使用 rebase） ","date":"2022-06-08","objectID":"https://loulazynote.github.io/posts/git-learning/:3:0","tags":["Git"],"title":"Git 學習筆記","uri":"https://loulazynote.github.io/posts/git-learning/"},{"categories":["C＃","ASP.NET Core"],"content":"什麼是 Entity Framework 一個 ORM 框架 可大幅減少開發時期資料存取的程式碼 透過 LINQ 自動產生 SQL 指令碼 透過「強型別」取得與操作物件資料 支援變更追蹤、資料識別、延遲載入 讓你更專注在商業邏輯，而非繁瑣的程式碼 ","date":"2021-08-10","objectID":"https://loulazynote.github.io/note/dot-net-core%E9%96%8B%E7%99%BC%E5%AF%A6%E6%88%B0%E7%AD%86%E8%A8%98/%E8%B3%87%E6%96%99%E5%AD%98%E5%8F%96%E7%AF%87efcore6/:1:0","tags":["ASP.NET","ASP.NET Core","C＃","Entity Framework Core 6"],"title":"Asp .Net Core 5.0 筆記 - 資料存取篇(EFCore6)","uri":"https://loulazynote.github.io/note/dot-net-core%E9%96%8B%E7%99%BC%E5%AF%A6%E6%88%B0%E7%AD%86%E8%A8%98/%E8%B3%87%E6%96%99%E5%AD%98%E5%8F%96%E7%AF%87efcore6/"},{"categories":["C＃","ASP.NET Core"],"content":"如何選擇 EF6 或 EF Core 新專案，選 Entity Framework Core 你的應用程式是 .NET Core 且需要跨平台支援 EF Core 可以支援你的應用程式所需的資料存取能力 如果有缺少必要的功能，就必須思考是否採用 請參考 EF Core Roadmap 看未來是否會支援！ 新專案，選 EF6 你的應用程式是 .NET Framework 4.0+ 與 Windows 平台 EF6 可以支援你的應用程式所需的資料存取能力 舊專案 不建議立刻升級，除非有立竿見影的效果 簡單說： EF6 無法直升 EF Core，只能將程式碼逐步轉移過去！ ","date":"2021-08-10","objectID":"https://loulazynote.github.io/note/dot-net-core%E9%96%8B%E7%99%BC%E5%AF%A6%E6%88%B0%E7%AD%86%E8%A8%98/%E8%B3%87%E6%96%99%E5%AD%98%E5%8F%96%E7%AF%87efcore6/:2:0","tags":["ASP.NET","ASP.NET Core","C＃","Entity Framework Core 6"],"title":"Asp .Net Core 5.0 筆記 - 資料存取篇(EFCore6)","uri":"https://loulazynote.github.io/note/dot-net-core%E9%96%8B%E7%99%BC%E5%AF%A6%E6%88%B0%E7%AD%86%E8%A8%98/%E8%B3%87%E6%96%99%E5%AD%98%E5%8F%96%E7%AF%87efcore6/"},{"categories":["C＃","ASP.NET Core"],"content":"關於 ORM 與 DDD ORM (Object Relational Mapping) 透過「物件導向思維」來管理「關聯式資料」 將 結構化的關連資料 對映成 物件導向模型 將 物件資料 對應成 關連資料 DDD (Domain Driven Design) 介面展示層 (Presentation Layer) 負責顯示和接受輸入 應用程式層 (Application Layer) 僅包含流程控制邏輯 領域模型層 (Domain Layer) 包含整個應用的所有商業邏輯 基礎結構層 (Infrastructure Layer) 提供整個應用程式的基礎服務 ","date":"2021-08-10","objectID":"https://loulazynote.github.io/note/dot-net-core%E9%96%8B%E7%99%BC%E5%AF%A6%E6%88%B0%E7%AD%86%E8%A8%98/%E8%B3%87%E6%96%99%E5%AD%98%E5%8F%96%E7%AF%87efcore6/:3:0","tags":["ASP.NET","ASP.NET Core","C＃","Entity Framework Core 6"],"title":"Asp .Net Core 5.0 筆記 - 資料存取篇(EFCore6)","uri":"https://loulazynote.github.io/note/dot-net-core%E9%96%8B%E7%99%BC%E5%AF%A6%E6%88%B0%E7%AD%86%E8%A8%98/%E8%B3%87%E6%96%99%E5%AD%98%E5%8F%96%E7%AF%87efcore6/"},{"categories":["C＃","ASP.NET Core"],"content":"建立模型類別及資料內容類別 建立模型類別 (Todo.cs) 可使用 prop 程式碼片段 請建立兩個屬性即可 ( int Id , string Item ) 建立資料內容類別 (TodoContext.cs) 可使用 ef-dbcontext 程式碼片段 建立資料內容工廠類別 (TodoContextFactory.cs) 可使用 ef-dbcontext-factory 程式碼片段 只有 非 ASP․NET Core 專案 才需要特別建立資料內容工廠類別 請參考 Design-time DbContext Creation 文件說明 ","date":"2021-08-10","objectID":"https://loulazynote.github.io/note/dot-net-core%E9%96%8B%E7%99%BC%E5%AF%A6%E6%88%B0%E7%AD%86%E8%A8%98/%E8%B3%87%E6%96%99%E5%AD%98%E5%8F%96%E7%AF%87efcore6/:4:0","tags":["ASP.NET","ASP.NET Core","C＃","Entity Framework Core 6"],"title":"Asp .Net Core 5.0 筆記 - 資料存取篇(EFCore6)","uri":"https://loulazynote.github.io/note/dot-net-core%E9%96%8B%E7%99%BC%E5%AF%A6%E6%88%B0%E7%AD%86%E8%A8%98/%E8%B3%87%E6%96%99%E5%AD%98%E5%8F%96%E7%AF%87efcore6/"},{"categories":["C＃","ASP.NET Core"],"content":"簡介 POCO(Plan Old CLR Object) 在 ORM 領域中經常被使用 POCO 當作資料模型的定義 用最簡單且無負擔的方式表達資料模型 可當 DTO(Data Transfer Object) 或 DAO(Data Access Object) 使用 序列化 (Serialize) 反序列化 (Deserializ ","date":"2021-08-10","objectID":"https://loulazynote.github.io/note/dot-net-core%E9%96%8B%E7%99%BC%E5%AF%A6%E6%88%B0%E7%AD%86%E8%A8%98/%E8%B3%87%E6%96%99%E5%AD%98%E5%8F%96%E7%AF%87efcore6/:5:0","tags":["ASP.NET","ASP.NET Core","C＃","Entity Framework Core 6"],"title":"Asp .Net Core 5.0 筆記 - 資料存取篇(EFCore6)","uri":"https://loulazynote.github.io/note/dot-net-core%E9%96%8B%E7%99%BC%E5%AF%A6%E6%88%B0%E7%AD%86%E8%A8%98/%E8%B3%87%E6%96%99%E5%AD%98%E5%8F%96%E7%AF%87efcore6/"},{"categories":["C＃","ASP.NET Core"],"content":"認識資料庫轉移 傳統資料庫應用開發 主要採用 Database First 開發流程 資料庫版本控管不易 (較容易被忽略) 版控中的 程式碼 與 資料庫結構描述 無法有效同步 採用 EF Core 的資料庫應用開發 可選用 Database First 或 Code First 開發流程 可完全交由 EF Core 管理模型變更歷程與資料庫變更指令碼 可透過 dotnet-ef 工具自動管理資料庫移轉作業 版控中的 程式碼 與 資料模型 (資料庫結構描述) 可有效同步 ( 由程式碼來對資料庫結構進行版本控制 ) ","date":"2021-08-10","objectID":"https://loulazynote.github.io/note/dot-net-core%E9%96%8B%E7%99%BC%E5%AF%A6%E6%88%B0%E7%AD%86%E8%A8%98/%E8%B3%87%E6%96%99%E5%AD%98%E5%8F%96%E7%AF%87efcore6/:6:0","tags":["ASP.NET","ASP.NET Core","C＃","Entity Framework Core 6"],"title":"Asp .Net Core 5.0 筆記 - 資料存取篇(EFCore6)","uri":"https://loulazynote.github.io/note/dot-net-core%E9%96%8B%E7%99%BC%E5%AF%A6%E6%88%B0%E7%AD%86%E8%A8%98/%E8%B3%87%E6%96%99%E5%AD%98%E5%8F%96%E7%AF%87efcore6/"},{"categories":["C＃","ASP.NET Core"],"content":"資料庫移轉與初始化資料庫( .Net CLI) 新增資料庫移轉設定 (執行完畢請查看 Migrations 資料夾) dotnet ef migrations add init 移除資料庫移轉設定 (預設會刪除最後一個移轉設定，但會比對資料庫中的紀錄) dotnet ef migrations remove 產生資料庫移轉變更指令碼 dotnet ef migrations script \u003cFROM\u003e \u003cTO\u003e -o output.sql 其中 可以是 0 (代表從最早的版本開始產生指令碼) Asp .Net Core 3.1後需要另外加入dotnet tool install --global dotnet-ef 更新資料庫 (若資料庫不存在則會自動建立新資料庫) dotnet ef database update -v (套用變更到目前最新版本) dotnet ef database update 0 (回復所有資料庫移轉變更) dotnet ef database update \u003cTO\u003e (套用變更到特定版本) 刪除資料庫 dotnet ef database drop ","date":"2021-08-10","objectID":"https://loulazynote.github.io/note/dot-net-core%E9%96%8B%E7%99%BC%E5%AF%A6%E6%88%B0%E7%AD%86%E8%A8%98/%E8%B3%87%E6%96%99%E5%AD%98%E5%8F%96%E7%AF%87efcore6/:7:0","tags":["ASP.NET","ASP.NET Core","C＃","Entity Framework Core 6"],"title":"Asp .Net Core 5.0 筆記 - 資料存取篇(EFCore6)","uri":"https://loulazynote.github.io/note/dot-net-core%E9%96%8B%E7%99%BC%E5%AF%A6%E6%88%B0%E7%AD%86%E8%A8%98/%E8%B3%87%E6%96%99%E5%AD%98%E5%8F%96%E7%AF%87efcore6/"},{"categories":["C＃","ASP.NET Core"],"content":"1. Asp .NET Core 開發框架 跨平台、高效能、開放原始碼架構 主要用來開發現代化、雲端、網際網路連線應用程式 透過 ASP .NET Core 可以 建置網站或 Web API 使用任何你喜愛的開發工具 (Visual Studio, VSCode, Rider, …) 執行在 Windows、 macOS 或 Linux 平台 使用 .NET Core 或 .NET Framework 皆可 部署到雲端或公司內部主機 完全免費 ","date":"2021-07-10","objectID":"https://loulazynote.github.io/note/dot-net-core%E9%96%8B%E7%99%BC%E5%AF%A6%E6%88%B0%E7%AD%86%E8%A8%98/%E6%96%B0%E6%89%8B%E4%B8%8A%E8%B7%AF/:1:0","tags":["ASP.NET","ASP.NET Core","C＃"],"title":"Asp .Net Core 5.0 筆記 - 新手上路","uri":"https://loulazynote.github.io/note/dot-net-core%E9%96%8B%E7%99%BC%E5%AF%A6%E6%88%B0%E7%AD%86%E8%A8%98/%E6%96%B0%E6%89%8B%E4%B8%8A%E8%B7%AF/"},{"categories":["C＃","ASP.NET Core"],"content":"2. Asp .NET Core 明顯得改變 比較 ASP.NET MVC 5 與 ASP.NET Core 之間的專案架構差異 沒有 web.config 檔案 ( 內建 Kestrel 超高速網站伺服器 ) 如果原本掛在 IIS 下，web.config 是可以沿用得 沒有 global.asax 檔案 ( 不再綁死 IIS 網站伺服器 ) 如果掛在 IIS 下會是兩台 Web Server 在 Run 新版 ASP .NET 錯誤頁面 ( 不再有黃底紅字畫面 ) 所有的服務都改用 DI (相依性注入) 方式提供 真正的前後端分離 預設使用 wwwroot 靜態檔案資料夾分離前後端檔案 RIP (Rest in Peace) ASP .NET Web Form ASP .NET Web Services WCF Services (僅支援 WCF 用戶端函式庫 ) 在 .NET 5 可以執行 Asp .NET core 5 得 Runtime ","date":"2021-07-10","objectID":"https://loulazynote.github.io/note/dot-net-core%E9%96%8B%E7%99%BC%E5%AF%A6%E6%88%B0%E7%AD%86%E8%A8%98/%E6%96%B0%E6%89%8B%E4%B8%8A%E8%B7%AF/:2:0","tags":["ASP.NET","ASP.NET Core","C＃"],"title":"Asp .Net Core 5.0 筆記 - 新手上路","uri":"https://loulazynote.github.io/note/dot-net-core%E9%96%8B%E7%99%BC%E5%AF%A6%E6%88%B0%E7%AD%86%E8%A8%98/%E6%96%B0%E6%89%8B%E4%B8%8A%E8%B7%AF/"},{"categories":["C＃","ASP.NET Core"],"content":"Kestrel 與 IIS 差異 IIS 有 Virtual Hosting(虛擬主機) IIS 可以掛載多站臺（Kestrel 無法） 如 .NET Core 放入 IIS，則 IIS 會是一個可以放網站得地方 ","date":"2021-07-10","objectID":"https://loulazynote.github.io/note/dot-net-core%E9%96%8B%E7%99%BC%E5%AF%A6%E6%88%B0%E7%AD%86%E8%A8%98/%E6%96%B0%E6%89%8B%E4%B8%8A%E8%B7%AF/:2:1","tags":["ASP.NET","ASP.NET Core","C＃"],"title":"Asp .Net Core 5.0 筆記 - 新手上路","uri":"https://loulazynote.github.io/note/dot-net-core%E9%96%8B%E7%99%BC%E5%AF%A6%E6%88%B0%E7%AD%86%E8%A8%98/%E6%96%B0%E6%89%8B%E4%B8%8A%E8%B7%AF/"},{"categories":["C＃","ASP.NET Core"],"content":"可以裝載 Asp .NET Core 的執行環境 Kestrel 內建於 ASP.NET Core 框架之中的簡易伺服器 支援 HTTP/2、 Negotiate、 Kerberos、 NTLM on Windows IIS 網站一樣可以部署到企業現有的 IIS 網站伺服器中 透過 IIS 的 ASP.NET Core Module 模組 HTTP.sys 一套僅限於 Windows 環境的 Web Server 實作 支援 Windows 驗證、 SNI SSL、 HTTP/2 over TLS、回應快取、 … Windows Service Nginx / Apache Docker ","date":"2021-07-10","objectID":"https://loulazynote.github.io/note/dot-net-core%E9%96%8B%E7%99%BC%E5%AF%A6%E6%88%B0%E7%AD%86%E8%A8%98/%E6%96%B0%E6%89%8B%E4%B8%8A%E8%B7%AF/:3:0","tags":["ASP.NET","ASP.NET Core","C＃"],"title":"Asp .Net Core 5.0 筆記 - 新手上路","uri":"https://loulazynote.github.io/note/dot-net-core%E9%96%8B%E7%99%BC%E5%AF%A6%E6%88%B0%E7%AD%86%E8%A8%98/%E6%96%B0%E6%89%8B%E4%B8%8A%E8%B7%AF/"},{"categories":["C＃","ASP.NET Core"],"content":"Asp .NET Core 包含那些東西 Web app MVC / Tag Helpers / View components / Action Filters / Areas Razor Pages / Razor syntax / Razor class libraries (RCL) Blazor / Razor components class libraries Web API SignalR gRPC Identity Entity Framework Core Entity Framework Core 原為 Asp .NET Core 得一部分，現在不隸屬於 Asp .NET Core 框架，自己本身就是一個框架 ","date":"2021-07-10","objectID":"https://loulazynote.github.io/note/dot-net-core%E9%96%8B%E7%99%BC%E5%AF%A6%E6%88%B0%E7%AD%86%E8%A8%98/%E6%96%B0%E6%89%8B%E4%B8%8A%E8%B7%AF/:4:0","tags":["ASP.NET","ASP.NET Core","C＃"],"title":"Asp .Net Core 5.0 筆記 - 新手上路","uri":"https://loulazynote.github.io/note/dot-net-core%E9%96%8B%E7%99%BC%E5%AF%A6%E6%88%B0%E7%AD%86%E8%A8%98/%E6%96%B0%E6%89%8B%E4%B8%8A%E8%B7%AF/"},{"categories":["C＃","ASP.NET Core"],"content":"Asp .NET Core 與 .NET Core 得差異 .NET Core 這個名字代表得是在寫 Console or Service.. .NET Core 3.1 (latest) .NET 5 (next Release) 以上皆為 目標框架 Target Framework RunTime: Microsoft.NetCore.App Asp .NET Core 5.0 這個名字代表得是在寫 Web，但本身就是一個 console RunTime: Microsoft.AspNetCore.App 這兩個其實是一樣得東西 ","date":"2021-07-10","objectID":"https://loulazynote.github.io/note/dot-net-core%E9%96%8B%E7%99%BC%E5%AF%A6%E6%88%B0%E7%AD%86%E8%A8%98/%E6%96%B0%E6%89%8B%E4%B8%8A%E8%B7%AF/:5:0","tags":["ASP.NET","ASP.NET Core","C＃"],"title":"Asp .Net Core 5.0 筆記 - 新手上路","uri":"https://loulazynote.github.io/note/dot-net-core%E9%96%8B%E7%99%BC%E5%AF%A6%E6%88%B0%E7%AD%86%E8%A8%98/%E6%96%B0%E6%89%8B%E4%B8%8A%E8%B7%AF/"},{"categories":["C＃","ASP.NET Core"],"content":"使用 .NET Core CLI 建立專案範本 列出所有專案範本 dotnet new -l (列出所有) dotnet new -l --type=project -lang=C# （列出所有跟 project 有關得 C#專案範本） dotnet new -l --type=project -VBlang=VB （列出所有跟 project 有關得 VB 專案範本） dotnet new -l --type=item （列出所有項目專案範本） dotnet new -l --type=other （列出所有 Solution 專案範本） 建立不同的專案範本 (.NET Core 3.1) 自訂 dotnet new 專案範本的重要觀念與範例 ","date":"2021-07-10","objectID":"https://loulazynote.github.io/note/dot-net-core%E9%96%8B%E7%99%BC%E5%AF%A6%E6%88%B0%E7%AD%86%E8%A8%98/%E6%96%B0%E6%89%8B%E4%B8%8A%E8%B7%AF/:6:0","tags":["ASP.NET","ASP.NET Core","C＃"],"title":"Asp .Net Core 5.0 筆記 - 新手上路","uri":"https://loulazynote.github.io/note/dot-net-core%E9%96%8B%E7%99%BC%E5%AF%A6%E6%88%B0%E7%AD%86%E8%A8%98/%E6%96%B0%E6%89%8B%E4%B8%8A%E8%B7%AF/"},{"categories":["C＃","ASP.NET Core"],"content":"ASP .NET Core Web APP(Razor Pages) Pages ➡️ 所有 Razor 頁面 Pages/Shared ➡️ 所有預設共用的 Razor 頁面 Pages/_ViewStart.cshtml ➡️ 設定預設 Layout 的地方 Pages/_ViewImports.cshtml ➡️ 設定預設 View 共用設定的地方 wwwroot ➡️ 所有網站的靜態資源資料夾 Properties/launchSettings.json 透過 dotnet run 啟動時的設定檔 ","date":"2021-07-10","objectID":"https://loulazynote.github.io/note/dot-net-core%E9%96%8B%E7%99%BC%E5%AF%A6%E6%88%B0%E7%AD%86%E8%A8%98/%E6%96%B0%E6%89%8B%E4%B8%8A%E8%B7%AF/:6:1","tags":["ASP.NET","ASP.NET Core","C＃"],"title":"Asp .Net Core 5.0 筆記 - 新手上路","uri":"https://loulazynote.github.io/note/dot-net-core%E9%96%8B%E7%99%BC%E5%AF%A6%E6%88%B0%E7%AD%86%E8%A8%98/%E6%96%B0%E6%89%8B%E4%B8%8A%E8%B7%AF/"},{"categories":["C＃","ASP.NET Core"],"content":"ASP .NET Core gRPC Service 可以非常高效得處理 API，是 google 推出得一個服務 缺點： 瀏覽器打不到 API，瀏覽器無法直接發出 gRPC 得 Request，必須透過一個 proceed，先收到 Http 得封包之後協助轉發 gRPC 出去 服務跟服務之間得通訊很適合 效能比 Golang 好 Protos ➡️ Protocol Buffer Files *.proto https://grpc.io/ Introduction to gRPC on .NET Core Services ➡️ gRPC 服務的實作類別 ","date":"2021-07-10","objectID":"https://loulazynote.github.io/note/dot-net-core%E9%96%8B%E7%99%BC%E5%AF%A6%E6%88%B0%E7%AD%86%E8%A8%98/%E6%96%B0%E6%89%8B%E4%B8%8A%E8%B7%AF/:6:2","tags":["ASP.NET","ASP.NET Core","C＃"],"title":"Asp .Net Core 5.0 筆記 - 新手上路","uri":"https://loulazynote.github.io/note/dot-net-core%E9%96%8B%E7%99%BC%E5%AF%A6%E6%88%B0%E7%AD%86%E8%A8%98/%E6%96%B0%E6%89%8B%E4%B8%8A%E8%B7%AF/"},{"categories":["C＃","ASP.NET Core"],"content":"tags: `` [TOC] ","date":"2021-05-10","objectID":"https://loulazynote.github.io/note/dot-net-core%E9%96%8B%E7%99%BC%E5%AF%A6%E6%88%B0%E7%AD%86%E8%A8%98/%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%B4%B9/:0:0","tags":["ASP.NET","ASP.NET Core","C＃"],"title":"Asp .Net Core 5.0 筆記 - 基本框架","uri":"https://loulazynote.github.io/note/dot-net-core%E9%96%8B%E7%99%BC%E5%AF%A6%E6%88%B0%E7%AD%86%E8%A8%98/%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%B4%B9/"},{"categories":["C＃","ASP.NET Core"],"content":".NET Core 基礎生態 ","date":"2021-05-10","objectID":"https://loulazynote.github.io/note/dot-net-core%E9%96%8B%E7%99%BC%E5%AF%A6%E6%88%B0%E7%AD%86%E8%A8%98/%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%B4%B9/:1:0","tags":["ASP.NET","ASP.NET Core","C＃"],"title":"Asp .Net Core 5.0 筆記 - 基本框架","uri":"https://loulazynote.github.io/note/dot-net-core%E9%96%8B%E7%99%BC%E5%AF%A6%E6%88%B0%E7%AD%86%E8%A8%98/%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%B4%B9/"},{"categories":["C＃","ASP.NET Core"],"content":"EF 與 CORE 得差異 WCF Clinet 可以為 Core 所有 Core 不支援 WCF 底層得實作不同 ","date":"2021-05-10","objectID":"https://loulazynote.github.io/note/dot-net-core%E9%96%8B%E7%99%BC%E5%AF%A6%E6%88%B0%E7%AD%86%E8%A8%98/%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%B4%B9/:1:1","tags":["ASP.NET","ASP.NET Core","C＃"],"title":"Asp .Net Core 5.0 筆記 - 基本框架","uri":"https://loulazynote.github.io/note/dot-net-core%E9%96%8B%E7%99%BC%E5%AF%A6%E6%88%B0%E7%AD%86%E8%A8%98/%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%B4%B9/"},{"categories":["C＃","ASP.NET Core"],"content":".Net Standard 標準類別庫 是一個標準規格 定義所有.net 平臺需要支援得 API 有那些 所有.NET 平臺得應用程式,皆可參考 .NET Standard 標準類別庫 .Net Standard 不包含任何實作,只有定義界面合約 不同得.NET 平臺,被要求必須實作 .NET Standard 規格中定義得 APIs .NET Standard 透過 NETStandard.Library 中繼套件來載入類別庫 NETStandard.Library 中繼套件透過 netstandard.dll 組建來連結相依得組件 netstandard.dll 沒有任何 API 實作,僅提供 Runtime 知道有那些 API 可用 從 .NET 5 開始,已經沒有 .NET Standard 了! 因 .NET 5 不在支援 .NET Framework 且 .NET 5 保有 .NET Standard 得所有特性 ","date":"2021-05-10","objectID":"https://loulazynote.github.io/note/dot-net-core%E9%96%8B%E7%99%BC%E5%AF%A6%E6%88%B0%E7%AD%86%E8%A8%98/%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%B4%B9/:1:2","tags":["ASP.NET","ASP.NET Core","C＃"],"title":"Asp .Net Core 5.0 筆記 - 基本框架","uri":"https://loulazynote.github.io/note/dot-net-core%E9%96%8B%E7%99%BC%E5%AF%A6%E6%88%B0%E7%AD%86%E8%A8%98/%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%B4%B9/"},{"categories":["C＃","ASP.NET Core"],"content":"理解 .NET Standard 標準類別庫 1. 為何使用 .NET Standard 標準類別庫 可以設計出 可重複使用 得類別庫 可以用於不同得 .NET Framework 平臺 以 “套件”(NuGet)為單位進行共用 一個套件可同時設定許多目標框架(Target Framework) 徹底解決 PCL 可攜式類別庫 得缺點 PCL 可用得 API 是所支援 .NET 架構得 API 交集 PCL 不同 Profile 得類別庫就無法互相參考 它是 .NET 世界第一個針對跨平臺所訂出的 BCL 標準! 2. 可以解決那些問題 每個 .NET 架構平臺下, 皆可以參考這個類別庫組件 架構平臺 -\u003e .NET Framework, .NET Core, Xammarin,… 這個組件具有跨作業系統平臺得特性 方便管理與維護 使用 NuGet 來發佈這些套件 解決 PCL 不方便使用得問題(限制太多) 可以針對不同平臺架構撰寫平臺專屬得 API 如果你沒有多架構平臺得需求 -\u003e 就可能不需要 .NET Standard 這個解決方案 ","date":"2021-05-10","objectID":"https://loulazynote.github.io/note/dot-net-core%E9%96%8B%E7%99%BC%E5%AF%A6%E6%88%B0%E7%AD%86%E8%A8%98/%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%B4%B9/:1:3","tags":["ASP.NET","ASP.NET Core","C＃"],"title":"Asp .Net Core 5.0 筆記 - 基本框架","uri":"https://loulazynote.github.io/note/dot-net-core%E9%96%8B%E7%99%BC%E5%AF%A6%E6%88%B0%E7%AD%86%E8%A8%98/%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%B4%B9/"},{"categories":["C＃","ASP.NET Core"],"content":"建立 .NET 類別庫專案 VS2019 檔案 -\u003e 新增 -\u003e 專案 -\u003e 類別庫 VSCode dotnet new classlib -n lib1 dotnet new -l 查看目前有多少專案範本 -n 是 namespace 得意思 關於 .NET 類別庫 NuGet 套件 NuGet 套件本地快取路徑:dotnet nuget locals all -l %USERPROFILE%.nuget\\packages 清空 NuGet 套件本地快取:dotnet nuget locals all -c ","date":"2021-05-10","objectID":"https://loulazynote.github.io/note/dot-net-core%E9%96%8B%E7%99%BC%E5%AF%A6%E6%88%B0%E7%AD%86%E8%A8%98/%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%B4%B9/:1:4","tags":["ASP.NET","ASP.NET Core","C＃"],"title":"Asp .Net Core 5.0 筆記 - 基本框架","uri":"https://loulazynote.github.io/note/dot-net-core%E9%96%8B%E7%99%BC%E5%AF%A6%E6%88%B0%E7%AD%86%E8%A8%98/%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%B4%B9/"},{"categories":["C＃","ASP.NET Core"],"content":"關於 .NET Core 重要特性 跨平臺與多架構 Win、MacOS 及 Linux 都可執行,也可轉移到其他系統. 在多個架構上(包含 x64、x86 及 ARM)可使用相同得行為來執行程式碼. 命令列工具(CLI) 所有使用 .NET Core 開發的情景都可以在命令列操作 彈性部署 可以內嵌在現有應用程式內、可以並安裝、可以部署到 Docker 容器中. 平臺相容性 .NET Core 透過 .NET Standard 標準類別庫與其他平臺相容 例如 .NET Framework、Xamarin 及 Mono.. 開放原始碼 .NET Core 平臺是開放原始碼,使用 MIT 和 Apache 2 授權 受 微軟 支援 每個版本得 .NET Core 皆由 微軟 官方提供技術支援. ","date":"2021-05-10","objectID":"https://loulazynote.github.io/note/dot-net-core%E9%96%8B%E7%99%BC%E5%AF%A6%E6%88%B0%E7%AD%86%E8%A8%98/%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%B4%B9/:1:5","tags":["ASP.NET","ASP.NET Core","C＃"],"title":"Asp .Net Core 5.0 筆記 - 基本框架","uri":"https://loulazynote.github.io/note/dot-net-core%E9%96%8B%E7%99%BC%E5%AF%A6%E6%88%B0%E7%AD%86%E8%A8%98/%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%B4%B9/"},{"categories":["C＃","ASP.NET Core"],"content":"如何選擇 .NET Core 或 .NET Framework 針對使用 .NET Core 跨平臺需求 微服務架構部署 Docker 容器使用 高效能、可延展得應用系統 可以並存不同得 NET 版本(降低相依性) 針對使用 .NET Framework 目前所使用得 .NET Framework 程式沒壞(也不想改) 找不到可用得 .NET Core 第三方函式庫/套件 需要用得 .NET 技術不適用 .NET Core(ex: Web Form) 程式必須使用不支援 .NET Core 得平臺 ","date":"2021-05-10","objectID":"https://loulazynote.github.io/note/dot-net-core%E9%96%8B%E7%99%BC%E5%AF%A6%E6%88%B0%E7%AD%86%E8%A8%98/%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%B4%B9/:1:6","tags":["ASP.NET","ASP.NET Core","C＃"],"title":"Asp .Net Core 5.0 筆記 - 基本框架","uri":"https://loulazynote.github.io/note/dot-net-core%E9%96%8B%E7%99%BC%E5%AF%A6%E6%88%B0%E7%AD%86%E8%A8%98/%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%B4%B9/"},{"categories":["C＃","ASP.NET Core"],"content":"瞭解 .NET Core 得組成項目 一個 .NET 執行階段(Runtime) 提供型別系統、組建載入、GC、原生 Interop 及其他基本服務。 一組 Framework 函式庫（Framework Libraries） 提供基礎(primitive)資料型別與一些好用得應用程式類別與工具類別 一套 SDK 工具及語言編譯器 提供軟體開發過程所需的基礎工具組,並可透過 .NET Core SDK 取得. 一支 dotnet 主程式(app host) 主要用來啟動/執行 .NET Core 應用程式,過程中會自動選取正確得 Runtime,並將 Runtime 裝載到記憶體內,提供 DLL 組件得載入原則,後啟動應用程式執行. ","date":"2021-05-10","objectID":"https://loulazynote.github.io/note/dot-net-core%E9%96%8B%E7%99%BC%E5%AF%A6%E6%88%B0%E7%AD%86%E8%A8%98/%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%B4%B9/:1:7","tags":["ASP.NET","ASP.NET Core","C＃"],"title":"Asp .Net Core 5.0 筆記 - 基本框架","uri":"https://loulazynote.github.io/note/dot-net-core%E9%96%8B%E7%99%BC%E5%AF%A6%E6%88%B0%E7%AD%86%E8%A8%98/%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%B4%B9/"},{"categories":["C＃","ASP.NET Core"],"content":"透過 global.json 指定 .NET Core SDK 版本 列出所有已安裝 SDK 版本 dotnet --list-sdks 快速建立 global.json 檔案 dotnet new globaljson 列出所有已安裝得 Runtime 版本 dotnet --list-runtimes 快速建立 global.json 檔案並指定特定 SDK 版本 dotnet new globaljson --sdk-version 3.1.409 ","date":"2021-05-10","objectID":"https://loulazynote.github.io/note/dot-net-core%E9%96%8B%E7%99%BC%E5%AF%A6%E6%88%B0%E7%AD%86%E8%A8%98/%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%B4%B9/:1:8","tags":["ASP.NET","ASP.NET Core","C＃"],"title":"Asp .Net Core 5.0 筆記 - 基本框架","uri":"https://loulazynote.github.io/note/dot-net-core%E9%96%8B%E7%99%BC%E5%AF%A6%E6%88%B0%E7%AD%86%E8%A8%98/%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%B4%B9/"},{"categories":["C＃","ASP.NET Core"],"content":".NET CORE 基礎開端 ","date":"2021-05-10","objectID":"https://loulazynote.github.io/note/dot-net-core%E9%96%8B%E7%99%BC%E5%AF%A6%E6%88%B0%E7%AD%86%E8%A8%98/%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%B4%B9/:2:0","tags":["ASP.NET","ASP.NET Core","C＃"],"title":"Asp .Net Core 5.0 筆記 - 基本框架","uri":"https://loulazynote.github.io/note/dot-net-core%E9%96%8B%E7%99%BC%E5%AF%A6%E6%88%B0%E7%AD%86%E8%A8%98/%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%B4%B9/"},{"categories":["C＃","ASP.NET Core"],"content":"認識 .NET Core SDK CLI 命令列工具 dotnet help 顯示執行與 SDK 命令說明 dotnet --version 顯示目前正在使用的 SDK 版本 dotnet --list-runtimes dotnet --list-sdks dotnet --info 顯示完整得 .NET Core 版本資訊 dotnet new 初始化 C#或 F#範本專案或檔案 dotnet restore 還原所指定應用程式得相依性 dotnet build 建置 .NET Core 應用程式(會自動還原套件) dotnet clean 清除建置時所輸出得相關檔案 dotnet msbuild 執行 MSBuild 命令 dotnet run 從專案目錄直接執行應用程式(會自動建置) dotnet test 使用專案指定得測試執行器執行單元測試 ","date":"2021-05-10","objectID":"https://loulazynote.github.io/note/dot-net-core%E9%96%8B%E7%99%BC%E5%AF%A6%E6%88%B0%E7%AD%86%E8%A8%98/%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%B4%B9/:2:1","tags":["ASP.NET","ASP.NET Core","C＃"],"title":"Asp .Net Core 5.0 筆記 - 基本框架","uri":"https://loulazynote.github.io/note/dot-net-core%E9%96%8B%E7%99%BC%E5%AF%A6%E6%88%B0%E7%AD%86%E8%A8%98/%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%B4%B9/"},{"categories":["C＃","ASP.NET Core"],"content":"透過 .NET CLI 設定專案與 NuGet 參考 dotnet list reference 列出使用中得專案參考 dotnet add reference 新增專案參考 dotnet remove reference 移除專案參考 dotnet list package 列出使用中得 NuGet 套件 dotnet add package 新增 NuGet 套件 dotnet remove package 移除 NuGet 套件 dotnet nuget locals 列出或清除本機 NuGet 套件快取 dotnet nuget delete 從伺服器刪除或取消列出套件 dotnet nuget push 將套件推送至伺服器並發行 ","date":"2021-05-10","objectID":"https://loulazynote.github.io/note/dot-net-core%E9%96%8B%E7%99%BC%E5%AF%A6%E6%88%B0%E7%AD%86%E8%A8%98/%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%B4%B9/:2:2","tags":["ASP.NET","ASP.NET Core","C＃"],"title":"Asp .Net Core 5.0 筆記 - 基本框架","uri":"https://loulazynote.github.io/note/dot-net-core%E9%96%8B%E7%99%BC%E5%AF%A6%E6%88%B0%E7%AD%86%E8%A8%98/%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%B4%B9/"},{"categories":["C＃","ASP.NET Core"],"content":"透過 .NET CLI 封裝與發行 dotnet pack 替目前類別庫專案建立 NuGet 套件 dotnet publish 發行 .NET Core 應用程式 dotnet publish -c Release dotnet publish -c Release /p:UseAppHost=false dotnet publish -r win10-x64 dotnet publish -r win10-x64 --self-conttained dotnet publish -r win10-x64 --no-self-contained dotnet publish -r win10-x64 /p:PublishSingleFile=true dotnet publish -r win10-x64 /p:PublishTrimmed=true ","date":"2021-05-10","objectID":"https://loulazynote.github.io/note/dot-net-core%E9%96%8B%E7%99%BC%E5%AF%A6%E6%88%B0%E7%AD%86%E8%A8%98/%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%B4%B9/:2:3","tags":["ASP.NET","ASP.NET Core","C＃"],"title":"Asp .Net Core 5.0 筆記 - 基本框架","uri":"https://loulazynote.github.io/note/dot-net-core%E9%96%8B%E7%99%BC%E5%AF%A6%E6%88%B0%E7%AD%86%E8%A8%98/%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%B4%B9/"},{"categories":["C＃","ASP.NET Core"],"content":".NET Core 應用程式部署類型 Framework 相依部署 (FDD) (Framework-Dependent Deployments) 目標系統必須先安裝共用的 .NET Core Runtime 版本 (Downloads) Framework 相依可執行檔 (FDE) (Framework-Dependent Executables) 目標系統必須先安裝共用的 .NET Core Runtime 版本 (Downloads) 這種部署類型從 .NET Core 2.2 才開始支援 這種部署類型從 .NET Core 3.0 開始為預設值 可直接部署目標平台的可執行檔，無須透過 dotnet 公用程式即可執行 自封式部署 (SCD) (Self-Contained Deployments) 不仰賴任何存在於目標系統上的共用元件，但是部署檔案相當大 包括 .NET Core 程式庫和 .NET Core 執行階段的所有元件，都隨附於應用程式，並與其他 .NET Core 應用程式隔離 ","date":"2021-05-10","objectID":"https://loulazynote.github.io/note/dot-net-core%E9%96%8B%E7%99%BC%E5%AF%A6%E6%88%B0%E7%AD%86%E8%A8%98/%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%B4%B9/:2:4","tags":["ASP.NET","ASP.NET Core","C＃"],"title":"Asp .Net Core 5.0 筆記 - 基本框架","uri":"https://loulazynote.github.io/note/dot-net-core%E9%96%8B%E7%99%BC%E5%AF%A6%E6%88%B0%E7%AD%86%E8%A8%98/%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%B4%B9/"},{"categories":["C＃","ASP.NET Core"],"content":"認識 RID 執行階段識別項 RID (Runtime Identifier) 可透過 dotnet --info 查詢！ RID 用來識別一個 .NET Core 應用程式應該執行在哪個平台 RID 基本格式 [os].[version]-[architecture]-[additional qualifiers] 常見的 RID 範例 ( .NET Core RID Catalog ) windows: win-x64 | win10-x64 | win10-x86 Linux: linux-x64 | linux-arm | ubuntu.18.04-x64 MacOS: osx-x64 | osx.10.12-x64 | osx.10.14-x64 使用 RID 得注意事項 RID 是隱晦字串 (opaque strings)，因此必須以黑箱視之。 不要以程式設計方式建置 RID 使用已針對平台定義的 RID RID 必須是特定的，因此不要假設實際 RID 值會怎樣！ ","date":"2021-05-10","objectID":"https://loulazynote.github.io/note/dot-net-core%E9%96%8B%E7%99%BC%E5%AF%A6%E6%88%B0%E7%AD%86%E8%A8%98/%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%B4%B9/:2:5","tags":["ASP.NET","ASP.NET Core","C＃"],"title":"Asp .Net Core 5.0 筆記 - 基本框架","uri":"https://loulazynote.github.io/note/dot-net-core%E9%96%8B%E7%99%BC%E5%AF%A6%E6%88%B0%E7%AD%86%E8%A8%98/%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%B4%B9/"},{"categories":["C＃","ASP.NET Core"],"content":"參考資料 .NET 官網 如何在 ASP.NET Core 3 使用 Token-based 身分驗證與授權 (JWT) 使用 .NET CLI 快速建立 Web API 用戶端函式庫的方法 如何在 EF Core 3.1 的模型驗證方法中注入 ServiceCollection 中的服務 練習 EF Core 5 資料庫先行 (DB First) 開發流程 (Console App) (dotnet-ef) ASP.NET Core 5 開發實戰：從入門到進階 實作環境說明 練習透過 .NET CLI 開發與建置各式 .NET 5.0 專案 設定 Swagger UI 可以提供 Bearer Token 的功能 HTTP 壓測工具 保哥自製-CLI 啟用 TAB 鍵自動完成 ","date":"2021-05-10","objectID":"https://loulazynote.github.io/note/dot-net-core%E9%96%8B%E7%99%BC%E5%AF%A6%E6%88%B0%E7%AD%86%E8%A8%98/%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%B4%B9/:2:6","tags":["ASP.NET","ASP.NET Core","C＃"],"title":"Asp .Net Core 5.0 筆記 - 基本框架","uri":"https://loulazynote.github.io/note/dot-net-core%E9%96%8B%E7%99%BC%E5%AF%A6%E6%88%B0%E7%AD%86%E8%A8%98/%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%B4%B9/"},{"categories":["C＃","Azure"],"content":"問題 透過 VS2019 內的 Deploy 到 Azure App Server 出現以下問題 Application '/LM/W3SVC/812567237/ROOT' with physical root 'D:\\home\\site\\wwwroot\\' hit unexpected managed exception, exception code = '0xe0434352'. First 30KB characters of captured stdout and stderr logs: Unhandled exception. System.IO.FileNotFoundException: The configuration file 'appsettings..json' was not found and is not optional. The physical path is 'D:\\home\\site\\wwwroot\\appsettings..json'. at Microsoft.Extensions.Configuration.FileConfigurationProvider.HandleException(ExceptionDispatchInfo info) at Microsoft.Extensions.Configuration.FileConfigurationProvider.Load(Boolean reload) at Microsoft.Extensions.Configuration.FileConfigurationProvider.Load() at Microsoft.Extensions.Configuration.ConfigurationRoot..ctor(IList`1 providers) at Microsoft.Extensions.Configuration.ConfigurationBuilder.Build() at BixLionDiscountNews.Program.Main(String[] args) in E:\\Projects\\BixlionDiscount\\itri-discount-news-backend\\BixLionDiscountNews\\Program.cs:line 18 Process Id: 3512. File Version: 15.0.21133.7. Description: IIS ASP.NET Core Module V2 Request Handler. Commit: 67acc3d331454956fc06d6de2218a625e3e596f8 查詢到 Program.cs 的第 18 行有錯 ","date":"2021-05-10","objectID":"https://loulazynote.github.io/note/%E5%AF%A6%E7%89%A9%E7%B6%93%E9%A9%97/azure-app-server-publish-%E5%95%8F%E9%A1%8C/:1:0","tags":["Azure","Azure App Server","Publish"],"title":"Azure-App-Server-Publish-問題","uri":"https://loulazynote.github.io/note/%E5%AF%A6%E7%89%A9%E7%B6%93%E9%A9%97/azure-app-server-publish-%E5%95%8F%E9%A1%8C/"},{"categories":["C＃","Azure"],"content":"解決方案 查詢到 ASPNETCORE_ENVIRONMENT 為環境變數,ASP .NET Core 使用它來標識運行時環境,且 ASP .NET Core 配置系統使用它來為應用程序的不同階段加載不同的配置 而AddEnvironmentVariables()為使用系統環境變數作為參數設定檔的資料來源 在 Azure App Server 需明確指定環境才能運作 故程式碼Program.cs 的第 18 行開始需修改為 var environment = Environment.GetEnvironmentVariable(\"ASPNETCORE_ENVIRONMENT\") var configuration = new ConfigurationBuilder() .AddJsonFile(\"appsettings.json\") .AddJsonFile($\"appsettings.{environment}.json\"); 再次 Deploy 後即為正常運作 ","date":"2021-05-10","objectID":"https://loulazynote.github.io/note/%E5%AF%A6%E7%89%A9%E7%B6%93%E9%A9%97/azure-app-server-publish-%E5%95%8F%E9%A1%8C/:2:0","tags":["Azure","Azure App Server","Publish"],"title":"Azure-App-Server-Publish-問題","uri":"https://loulazynote.github.io/note/%E5%AF%A6%E7%89%A9%E7%B6%93%E9%A9%97/azure-app-server-publish-%E5%95%8F%E9%A1%8C/"},{"categories":["C＃","Azure"],"content":"補充 使用以下 Command 可以模擬相同問題 dotnet publish -c Release -o dist dotnet dist\\\\BixLionDiscountNews.dll 以上皆已在專案目錄底下 使用上述 Command 即可在本機發行，且在本機執行，不要用 dotnet run 就可以模擬出問題 ","date":"2021-05-10","objectID":"https://loulazynote.github.io/note/%E5%AF%A6%E7%89%A9%E7%B6%93%E9%A9%97/azure-app-server-publish-%E5%95%8F%E9%A1%8C/:3:0","tags":["Azure","Azure App Server","Publish"],"title":"Azure-App-Server-Publish-問題","uri":"https://loulazynote.github.io/note/%E5%AF%A6%E7%89%A9%E7%B6%93%E9%A9%97/azure-app-server-publish-%E5%95%8F%E9%A1%8C/"},{"categories":["C＃","Azure"],"content":"參考資料 ASPNETCORE_ENVIRONMENT Variable in ASP.NET Core CK’s Notepad - [.NET Core] 加入設定參數 John Wu’s Blog - ASP.NET Core 教學 - 自訂組態設定檔 Microsoft - Visual Studio 發佈設定檔 (. .pubxml) 以進行 ASP.NET Core 應用程式部署 Microsoft - 在 ASP.NET Core 中使用多個環境 Microsoft - ASP.NET Core Web 主機 ","date":"2021-05-10","objectID":"https://loulazynote.github.io/note/%E5%AF%A6%E7%89%A9%E7%B6%93%E9%A9%97/azure-app-server-publish-%E5%95%8F%E9%A1%8C/:4:0","tags":["Azure","Azure App Server","Publish"],"title":"Azure-App-Server-Publish-問題","uri":"https://loulazynote.github.io/note/%E5%AF%A6%E7%89%A9%E7%B6%93%E9%A9%97/azure-app-server-publish-%E5%95%8F%E9%A1%8C/"},{"categories":["C＃","Azure"],"content":"如何在沒有 Portal Azure 權限下部署? ","date":"2021-05-10","objectID":"https://loulazynote.github.io/note/%E5%AF%A6%E7%89%A9%E7%B6%93%E9%A9%97/how-to-deploy-website-on-azure-server-without-subscription-permission/:1:0","tags":["Azure","Azure App Server","Deploy"],"title":"How to deploy website on Azure Server without Subscription Permission","uri":"https://loulazynote.github.io/note/%E5%AF%A6%E7%89%A9%E7%B6%93%E9%A9%97/how-to-deploy-website-on-azure-server-without-subscription-permission/"},{"categories":["C＃","Azure"],"content":"ANS: 利用 Webdeploy 工具 Step 從 Azure Function App 下載 Publish Profile 在 AzureDevOps 的 Release 內建立 CD 建立 new pipeline 選取 empty job 加入 Artifacts(選取最新版本) 因為前後端分離成兩個 Repo 所以要加入兩個 Artifacts 開啟 Trigger(disable =\u003e enable) 進入 Tasks 選 vs2017 - win2016 建立 PowerShell 透過 PowerShell 建立變數 在設定部分選擇 inline 建立參數(使用 先前下載的 pulish Profile 建立) $sourcePath = '$(System.DefaultWorkingDirectory)/_itri-discount-news-Backend-Develop-CI/drop/BixLionDiscountNews' $appOffline = $sourcePath + '\\app_offline.template.htm' $publishUrl = 'bixlion.scm.azurewebsites.net:443' $deploySite = 'bixlion' $userName = '$bixlion' $userPWD = '$(MSDeployPW)' $(MSDeployPW)變數建立在 Variables $sourcePath可利用 Azure App Service Deploy 功能取得 關於app_offline.template.htm : 在同步站台檔案的時候，利用 app_Offline.htm 檔案，讓網站的應用程式集區可以暫時關閉。一定要小寫的 app_offline.htm 檔案！ 如不加此檔案暫時關閉應用程式集區,則站台中的 *.dll 檔案會被咬住鎖定,且無法成功部署,所以要建立此檔案在專案根目錄(內容不重要) 建立的方法: 必須在屬性內更改建置動作(build Action)及複製到輸出目錄(Copy to Output Directory),改為 內容(Content)及 有更新時才複製(Copy if newer),改了這些設定才會跟著部署上去 設定複製前端檔案至wwwroot(此專案的需求) 增加 Script 以便部署 同步 app_offline.htm 檔案到遠端站台 . \"C:\\Program Files (x86)\\IIS\\Microsoft Web Deploy V3\\msdeploy.exe\" -verb:sync -source:contentPath=$appOffline -dest:contentPath=`\"$deploySite/app_offline.htm`\",computerName=`\"https://$publishUrl/msdeploy.axd?site=$deploySite`\",userName=`\"$userName`\",password=`\"$userPWD`\",authtype=`\"Basic`\",includeAcls=`\"False`\" 用msdeploy 命令呼叫 Azure 會找不到路徑及命令,所以改為使用 絕對路徑 . \"C:\\Program Files (x86)\\IIS\\Microsoft Web Deploy V3\\msdeploy.exe\" 前面一定要加 .才抓得到 同步所有檔案到遠端站台 . \"C:\\Program Files (x86)\\IIS\\Microsoft Web Deploy V3\\msdeploy.exe\" -verb:sync -source:contentPath=$sourcePath -dest:contentPath=`\"$deploySite`\",computerName=`\"https://$publishUrl/msdeploy.axd?site=$deploySite`\",userName=`\"$userName`\",password=`\"$userPWD`\",authtype=`\"Basic`\",includeAcls=`\"False`\" -retryAttempts:10 -retryInterval:3000 -enableRule:DoNotDeleteRule 這裡如果沒加上 -enableRule:DoNotDeleteRule 的話，站台中的 app_offline.htm 檔案就會被刪除，這可能會導致站台中的 *.dll 檔案依然被鎖定！ 如果 Azure Function App 有設定 WEBSITE_RUN_FROM_PACKAGE 並設定為 1 的話，網站將無法正確部署！ 刪除遠端站台的 app_offline.htm 檔案 . \"C:\\Program Files (x86)\\IIS\\Microsoft Web Deploy V3\\msdeploy.exe\" -verb:delete -dest:contentPath=$deploySite/app_offline.htm,computerName=`\"https://$publishUrl/msdeploy.axd?site=$deploySite`\",userName=`\"$userName`\",password=`\"$userPWD`\",authtype=`\"Basic`\",includeAcls=`\"False`\" 完成 ","date":"2021-05-10","objectID":"https://loulazynote.github.io/note/%E5%AF%A6%E7%89%A9%E7%B6%93%E9%A9%97/how-to-deploy-website-on-azure-server-without-subscription-permission/:1:1","tags":["Azure","Azure App Server","Deploy"],"title":"How to deploy website on Azure Server without Subscription Permission","uri":"https://loulazynote.github.io/note/%E5%AF%A6%E7%89%A9%E7%B6%93%E9%A9%97/how-to-deploy-website-on-azure-server-without-subscription-permission/"},{"categories":["C＃","Azure"],"content":"參考資料 The Will Will Web - 使用 MSDeploy 部署一個在 Private Link 封閉網路環境下的 Function App 2021-10-04 保哥線上會議教學 ","date":"2021-05-10","objectID":"https://loulazynote.github.io/note/%E5%AF%A6%E7%89%A9%E7%B6%93%E9%A9%97/how-to-deploy-website-on-azure-server-without-subscription-permission/:2:0","tags":["Azure","Azure App Server","Deploy"],"title":"How to deploy website on Azure Server without Subscription Permission","uri":"https://loulazynote.github.io/note/%E5%AF%A6%E7%89%A9%E7%B6%93%E9%A9%97/how-to-deploy-website-on-azure-server-without-subscription-permission/"},{"categories":["C＃","ASP.NET Core"],"content":"Installation 用 NuGet 搜尋 Serilog.AspNetCore安裝套件 在 Program.cs 加入設定 Log.Logger = new LoggerConfiguration() .MinimumLevel.Override(\"Microsoft\", LogEventLevel.Warning) .MinimumLevel.Override(\"System\", LogEventLevel.Warning)//使用MinimumLevel 來設定 LogLevel 層級,如果來源為 Microsoft 及 系統的訊息 則LogLevel 層級為 警告 .WriteTo.Console(new RenderedCompactJsonFormatter()) .WriteTo.File(new CompactJsonFormatter().ToString())//Output templates, 輸出至Console及檔案 .Enrich.FromLogContext() .CreateLogger(); CompactJsonFormatter 將保留消息模板、屬性和格式信息，以便稍後可以創建呈現的消息。當 JSON 旨在在沒有消息模板呈現的環境中使用時，可以改用 RenderedCompactJsonFormatter。 loggerConfiguration.ReadFrom.Configuration(hostingContext.Configuration) : 讀取現在的Configuration appsetting.json 加入設定 Microsoft.Hosting.Lifetime : 應用程式生命週期事件的通知 Microsoft.EntityFrameworkCore.Database.Command : 紀錄 EF Core 自動產生的 SQL 命令 Startup.cs 設定 app.UseSerilogRequestLogging(options =\u003e { // Customize the message template options.MessageTemplate = \"Handled {RequestPath}\"; // Emit debug-level events instead of the defaults options.GetLevel = (httpContext, elapsed, ex) =\u003e LogEventLevel.Debug; // Attach additional properties to the request completion event options.EnrichDiagnosticContext = (diagnosticContext, httpContext) =\u003e { diagnosticContext.Set(\"RequestHost\", httpContext.Request.Host.Value); diagnosticContext.Set(\"RequestScheme\", httpContext.Request.Scheme); }; }); ","date":"2021-05-10","objectID":"https://loulazynote.github.io/note/%E5%AF%A6%E7%89%A9%E7%B6%93%E9%A9%97/serilog-%E8%A8%AD%E5%AE%9A%E7%AD%86%E8%A8%98/:1:0","tags":["SeriLog","ASP.NET Core","Learning"],"title":"SeriLog 設定筆記","uri":"https://loulazynote.github.io/note/%E5%AF%A6%E7%89%A9%E7%B6%93%E9%A9%97/serilog-%E8%A8%AD%E5%AE%9A%E7%AD%86%E8%A8%98/"},{"categories":["C＃","ASP.NET Core"],"content":"Usage 在需要的地方加入 log 先 using Microsoft.Extensions.Logging 加入建構式 在需要 log 的部分加入 log 記錄 可以自訂訊息等級 因在Program.cs及appsetting.json有加入設定,其餘 System 的操作及 Database 的讀取皆會被 log 下來 ","date":"2021-05-10","objectID":"https://loulazynote.github.io/note/%E5%AF%A6%E7%89%A9%E7%B6%93%E9%A9%97/serilog-%E8%A8%AD%E5%AE%9A%E7%AD%86%E8%A8%98/:2:0","tags":["SeriLog","ASP.NET Core","Learning"],"title":"SeriLog 設定筆記","uri":"https://loulazynote.github.io/note/%E5%AF%A6%E7%89%A9%E7%B6%93%E9%A9%97/serilog-%E8%A8%AD%E5%AE%9A%E7%AD%86%E8%A8%98/"},{"categories":["C＃","ASP.NET Core"],"content":"參考資料 Github - serilog-aspnetcore Github - Serilog.Formatting.Compact Microsoft - .NET Core 與 ASP.NET Core 中的記錄 WilL Blog - ASP.NET Core 如何紀錄 Entity Framework Core 5.0 自動產生的 SQL 命令 m@rcus 學習筆記 - [NETCore] 結構化日誌 Serilog - 配置設定 C# Corner - How To Implement Logging Using Serilog In ASP.NET Core 5.0 Application With Database ","date":"2021-05-10","objectID":"https://loulazynote.github.io/note/%E5%AF%A6%E7%89%A9%E7%B6%93%E9%A9%97/serilog-%E8%A8%AD%E5%AE%9A%E7%AD%86%E8%A8%98/:3:0","tags":["SeriLog","ASP.NET Core","Learning"],"title":"SeriLog 設定筆記","uri":"https://loulazynote.github.io/note/%E5%AF%A6%E7%89%A9%E7%B6%93%E9%A9%97/serilog-%E8%A8%AD%E5%AE%9A%E7%AD%86%E8%A8%98/"},{"categories":["Side Projects"],"content":"Topic : 線上點餐系統 ","date":"2021-05-10","objectID":"https://loulazynote.github.io/note/side-projects/plan/:1:0","tags":["Side Projects"],"title":"Side Project 0.0.1","uri":"https://loulazynote.github.io/note/side-projects/plan/"},{"categories":["Side Projects"],"content":"Skill List Necessary BackEnd : Asp.Net Core 6.0 AutoMapper(or Others) SignalR NoSQL (MongoDB) MicroService FrontEnd : VueJs 3 / Angular 13 TailwindCSS Optional Firebase Redis Repository Pattern Factory Pattern ","date":"2021-05-10","objectID":"https://loulazynote.github.io/note/side-projects/plan/:1:1","tags":["Side Projects"],"title":"Side Project 0.0.1","uri":"https://loulazynote.github.io/note/side-projects/plan/"},{"categories":["Side Projects"],"content":"Problems 從何開始? 架構為何? 如何架構? (Use Figma to design.) 分層架構? 使用MicroService 如何架構? WireFrame製作 (Use Figma to design.) ","date":"2021-05-10","objectID":"https://loulazynote.github.io/note/side-projects/plan/:1:2","tags":["Side Projects"],"title":"Side Project 0.0.1","uri":"https://loulazynote.github.io/note/side-projects/plan/"},{"categories":["WSL","Docker"],"content":" 從 Microsoft Container Registry 提取 SQL Server 2019 Linux 容器映像 sudo docker pull mcr.microsoft.com/mssql/server:2019-latest 以 Docker 執行容器映像 sudo docker run -e \"ACCEPT_EULA=Y\" -e \"SA_PASSWORD=\u003cYourStrong@Passw0rd\u003e\" \\ -p 1433:1433 --name DockerSQL -h DockerSQL \\ -d mcr.microsoft.com/mssql/server:2019-latest 確認 Docker 是否正常 Run 起來 使用 SSMS 連結 Docker SQLServer 將 DB bak 檔複製進 WSL 使用 docker exec 來建立備份資料夾 sudo docker exec -it DockerSQL mkdir /var/opt/mssql/backup 將備份檔案複製到容器中 示例: docker cp /hostfile (container_id):/(to_the_place_you_want_the_file_to_be) 我的路徑: sudo docker cp /mnt/e/Projects/BixlionDiscount/DBBak/bixlion.bak 17f4c2f08956:/var/opt/mssql/backup SSMS 還原 DB 無法產生Database Diagrams解決方法,設定 DB 使用者權限 use [YourDatabaseName] EXEC sp_changedbowner 'sa' ","date":"2021-05-10","objectID":"https://loulazynote.github.io/note/%E5%AF%A6%E7%89%A9%E7%B6%93%E9%A9%97/sqlserver-use-docker-image-with-wsl/:0:0","tags":["SQLServer","Docker","WSL"],"title":"SQLServer use Docker image with WSL","uri":"https://loulazynote.github.io/note/%E5%AF%A6%E7%89%A9%E7%B6%93%E9%A9%97/sqlserver-use-docker-image-with-wsl/"},{"categories":["WSL","Docker"],"content":"參考資料 快速入門：使用 Docker 執行 SQL Server 容器映像 在 Linux Docker 容器中還原 SQL Server 資料庫 ","date":"2021-05-10","objectID":"https://loulazynote.github.io/note/%E5%AF%A6%E7%89%A9%E7%B6%93%E9%A9%97/sqlserver-use-docker-image-with-wsl/:0:1","tags":["SQLServer","Docker","WSL"],"title":"SQLServer use Docker image with WSL","uri":"https://loulazynote.github.io/note/%E5%AF%A6%E7%89%A9%E7%B6%93%E9%A9%97/sqlserver-use-docker-image-with-wsl/"},{"categories":["C＃","ASP.NET Core"],"content":"基本用法 一般對應 var mapper = Mapper.Map\u003cTargetType\u003e(customer); or var mapper = Mapper.Map\u003cFromType, TargetType\u003e(customer); 客製化對應 Mapper.AddMap\u003cFromType, TargetType\u003e(src =\u003e { var res = new TargetType(); res.InjectFrom(src); // 對應相同名字及型別的屬性 res.FullName = src.FirstName + \" \" + src.LastName; return res; }); InjectFrom 的用法 InjectFrom\u003cTInjection\u003e(source)用於使用約定映射，當未指定 TInjection 時，它將對應具有完全相同名稱和類型的屬性 target.InjectFrom(source); target.InjectFrom\u003cInjection\u003e(source); target.InjectFrom(new Injection(parameters), source); target.InjectFrom\u003cInjection\u003e(); ","date":"2021-05-10","objectID":"https://loulazynote.github.io/note/%E5%AF%A6%E7%89%A9%E7%B6%93%E9%A9%97/valueinjecterver-3.2.0%E7%B0%A1%E5%96%AE%E7%94%A8%E6%B3%95/:1:0","tags":["C＃","ValueInjecter","ASP.NET Core","Tools"],"title":"ValueInjecter@3.2.0 簡單用法","uri":"https://loulazynote.github.io/note/%E5%AF%A6%E7%89%A9%E7%B6%93%E9%A9%97/valueinjecterver-3.2.0%E7%B0%A1%E5%96%AE%E7%94%A8%E6%B3%95/"},{"categories":["C＃","ASP.NET Core"],"content":"專案上使用遇到的問題 當 List 需要轉換對應時 問題: public async Task\u003cList\u003cCommentReportDto\u003e\u003e GetAllCommentReportAsync(CancellationToken token) { var query = await _context.ReportCommentListView.OrderByDescending(v =\u003e v.ReportOn).ToListAsync(token); var data = Mapper.map\u003cList\u003cCommentReportDto\u003e\u003e(query);//此方式是無法對應任何屬性的 return data; } 解法: public async Task\u003cList\u003cCommentReportDto\u003e\u003e GetAllCommentReportAsync(CancellationToken token) { var query = await _context.ReportCommentListView.OrderByDescending(v =\u003e v.ReportOn).ToListAsync(token); var data = query.Select(q =\u003e new CommentReportDto().InjectFrom(q)).Cast\u003cCommentReportDto\u003e().ToList();//改用此方式即可,需使用Cast\u003cT\u003e才會是正確的屬性 return data; } 如沒使用Cast\u003cT\u003e則會變成 Object 屬性: ","date":"2021-05-10","objectID":"https://loulazynote.github.io/note/%E5%AF%A6%E7%89%A9%E7%B6%93%E9%A9%97/valueinjecterver-3.2.0%E7%B0%A1%E5%96%AE%E7%94%A8%E6%B3%95/:2:0","tags":["C＃","ValueInjecter","ASP.NET Core","Tools"],"title":"ValueInjecter@3.2.0 簡單用法","uri":"https://loulazynote.github.io/note/%E5%AF%A6%E7%89%A9%E7%B6%93%E9%A9%97/valueinjecterver-3.2.0%E7%B0%A1%E5%96%AE%E7%94%A8%E6%B3%95/"},{"categories":["C＃","ASP.NET Core"],"content":"參考資料 GitHub - ValueInjecter StackOverFlow ","date":"2021-05-10","objectID":"https://loulazynote.github.io/note/%E5%AF%A6%E7%89%A9%E7%B6%93%E9%A9%97/valueinjecterver-3.2.0%E7%B0%A1%E5%96%AE%E7%94%A8%E6%B3%95/:3:0","tags":["C＃","ValueInjecter","ASP.NET Core","Tools"],"title":"ValueInjecter@3.2.0 簡單用法","uri":"https://loulazynote.github.io/note/%E5%AF%A6%E7%89%A9%E7%B6%93%E9%A9%97/valueinjecterver-3.2.0%E7%B0%A1%E5%96%AE%E7%94%A8%E6%B3%95/"}]