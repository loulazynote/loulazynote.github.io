[{"categories":["Kerberos"],"content":"Single Sign On with Kerberos ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/:0:0","tags":["Kerberos"],"title":"Single Sign on With Kerberos","uri":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/"},{"categories":["Kerberos"],"content":"Keberos 概述 Kerberos 是一種計算機網絡認證協議 它允許某實體在非安全網絡環境下通信 向另一個實體以一種安全的方式證明自己的身份 Kerberos 伺服器本身稱為鑰匙分配中心或 KDC 一般來說，KDC 除了發放票據與金鑰之外，同時也負責身份驗證的功能 (Authentication Server, AS) Kerberos 使用 Needham-Schroeder 協議作為基礎 它使用一個由兩個獨立的邏輯部分： 認證伺服器 票據授權伺服器 組成\"可信賴的第三方\" Kerberos 工作在用於證明用戶身份的\"票據\"基礎上 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/:1:0","tags":["Kerberos"],"title":"Single Sign on With Kerberos","uri":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/"},{"categories":["Kerberos"],"content":"Needham-Schroeder Needham 與 Schroeder 於 1978 年提出一種『多重盤問與回應』的認證協定，它不但可以避免重播攻擊，也可以解決相互認證的問題。 而協議的安全主要依賴於參加者對時間的鬆散同步和短周期的叫做 Kerberos 票據的認證聲明 下面為 Kerberos 內容名詞縮寫及解釋： AS（Authentication Server）: 認證伺服器 KDC（Key Distribution Center）: 鑰匙分配中心 TGS（Ticket Granting Server）: 票據授權伺服器 TGT（Ticket Granting Ticket）: 票據授權票據，票據的票據 ST（Service Ticket）: 服務門票 SS（Service Server）: 特定服務提供端 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/:1:1","tags":["Kerberos"],"title":"Single Sign on With Kerberos","uri":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/"},{"categories":["Kerberos"],"content":"認證伺服器（Authentication Server/AS） 相當於『鑰匙分配中心』（KDC） 管理每一個使用者的主密鑰（或稱共享密鑰） 欲加入的使用者都必須向 AS 伺服器申請帳戶並取得主密鑰 網路上任何一個使用者登入系統時，都會向認證中心取得通行證（Pass Book 或 TGT 票），有了通行證便可以在網路上索取所要的資源 簡單來說就是 驗證 Client 端的身份（確定你是身份證上的本人） 驗證通過就會給一張票證授予票證（Ticket Granting Ticket/TGT）給 Client ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/:1:2","tags":["Kerberos"],"title":"Single Sign on With Kerberos","uri":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/"},{"categories":["Kerberos"],"content":"鑰匙分配中心(Key Distribution Center/KDC) KDC 是一台伺服器，它與每位註冊的使用者分享不同的的私密對稱金鑰，當使用者第一次使用註冊時，這支金鑰可以利用人工輸入到伺服器 KDC 知道每位使用者的私密金鑰，而每位使用者可以使用此金鑰與 KDC 進行安全通訊 以 Star 星狀方式配置，從中心集中管理對外分散的 Key 採用 KDC 的管理方式可以減少 Key 的數量，它將所有的 Key 集中到一個中心點因此降降低了 Key 的數目，n 個 node 只需要 n 把 Key 即可，以 5 個點的拓樸系統來看只需要 5 把 Key，因此大大的降低系統對 Key 的需求 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/:1:3","tags":["Kerberos"],"title":"Single Sign on With Kerberos","uri":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/"},{"categories":["Kerberos"],"content":"票據授權伺服器（Ticket Granting Server/TGS） TGS 管理網路上所有服務伺服器，並紀錄所有服務伺服器的秘密鑰匙 當有新的伺服器加入或退出時，都必須向 TGS 伺服器申請 而且某一秘密鑰匙也只有 TGS 伺服器和該服務伺服器兩者所擁有，因此 TGS 伺服器必須管理網路上所有伺服器的秘密鑰匙 使用者如要存取服務伺服器上資源時，必須向 TGS 提出它的身份證明，即 TGT 門票。 TGT 門票是經過 TGS 伺服器的秘密鑰匙加密，因此只有 TGS 伺服器能觀察門票的內容，別人無法仿冒 TGS 伺服器驗證完使用者的通行證後，再發給使用者有關使用者本身和所欲要求的服務伺服器的『服務門票』（Service Ticket, ST） 有了 ST 門票之後，使用者才可以到服務伺服器上存取資源，ST 門票同時包含了會議鑰匙 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/:1:4","tags":["Kerberos"],"title":"Single Sign on With Kerberos","uri":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/"},{"categories":["Kerberos"],"content":"票據授權票據，票據的票據（Ticket Granting Ticket/TGT） 此票是由 AS 伺服器發給客戶端的身分證明使用；使用者可以持此票向 TGS 伺服器申請通往某一伺服器的請求 Kerberos 協議將 TGT 的使用設計成可以避免經常向用戶詢問密碼（Kerberos 用來派生主密鑰的密碼）或將主密鑰存儲在工作站上 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/:1:5","tags":["Kerberos"],"title":"Single Sign on With Kerberos","uri":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/"},{"categories":["Kerberos"],"content":"服務門票（Service Ticket/ST） 當使用者出示 TGT 門票，向 TGS 伺服器要求前往某一伺服器 如果 TGS 伺服器同意其要求時，則發給所要求伺服器的 ST 門票給使用者，使用者持此票即可要求該伺服器提供服務 ST（Service Ticket）也有資料稱為 TGS Ticket ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/:1:6","tags":["Kerberos"],"title":"Single Sign on With Kerberos","uri":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/"},{"categories":["Kerberos"],"content":"Keberos 流程關係 消息 A：使用 Client/User 的秘密密鑰加密的 Client/TGS Session Key。 消息 B：使用 TGS 的密鑰加密的票證授予票證。 消息 C：由消息 B 的 TGT 和所請求服務的 ID 組成。 消息 D：使用 Client/TGS 會話密鑰加密的身份驗證器。 消息 E：使用服務的秘密密鑰加密的 Client 到 Server 票證。 消息 F：使用 Client/TGS Session Key 加密的 Client/Server Session Key。 消息 G：一個新的身份驗證器，其中包括 Client ID，時間戳記，並使用 Client/Server Session Key 進行了加密。 消息 H：在 Client 的身份驗證器中找到的時間戳已使用 Client/Server Session Key 進行了加密。 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/:1:7","tags":["Kerberos"],"title":"Single Sign on With Kerberos","uri":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/"},{"categories":["Kerberos"],"content":"名詞解釋 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/:2:0","tags":["Kerberos"],"title":"Single Sign on With Kerberos","uri":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/"},{"categories":["Kerberos"],"content":"Principal Kerberos principal（又稱為主體）用於在 kerberos 加密系統中標記一個唯一的身份 主體可以是用戶（如 louis）或服務（如 namenode 或 hive） 根據約定，主體名稱分為三個部分： 主名稱、實例和領域。 例如，典型的 Kerberos 主體可以是 louis/admin@EXAMPLE.COM ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/:2:1","tags":["Kerberos"],"title":"Single Sign on With Kerberos","uri":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/"},{"categories":["Kerberos"],"content":"keytab keytab 是包含 principals 和加密 principal key 的文件 \u003e keytab 用於將 SSO 帶到未加入 AD domain 的應用程序 keytab 文件對於每個 host 是唯一的，因為 key 中包含 hostname keytab 文件用於不需要人工交互和保存純文本密碼，實現到 kerberos 上驗證一個主機上的 principal 因為 Server 上可以訪問 keytab 文件即可以以 principal 的身份通過 kerberos 的認證，所以，keytab 文件應該被妥善保存，應該只有少數的用戶可以訪問 如何產生 Keytab? 使用實用程序 KTPASS.EXE 它是 RSAT 的一部分，如果啟用了 Active Directory 目錄服務工具將顯示在 RSAT 中 ktpass /out app1.keytab /princ http/app1.verenatex.com@verenatex.com /mapuser app1 /crypto AES256-SHA1 /ptype KRB5_NT_PRINCIPAL /pass Password2 /target vdc01.verenatex.com /out 指定輸出文件的名稱，如 app1.keytab /princ 指定 userPrincipalName 以及將其添加到對映帳戶的 servicePrincipalName 的值 /mapuser 是將為其生成 Keytab 的帳戶 /crypto 是用於 Keytab 的加密類型，此處為 AES256-SHA1 /ptype 通常應使用 KRB5_NT_PRINCIPAL，除非應用程序文檔另有說明 /pass 是對應帳戶的新密碼（默認情況下，它將執行密碼重置操作） /target 用於指示將查詢哪個 domain 控制器(it is optional, but can be useful if you have more than one domain in your forest) ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/:2:2","tags":["Kerberos"],"title":"Single Sign on With Kerberos","uri":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/"},{"categories":["Kerberos"],"content":"Single Sign-On (SSO) 單一登錄（SSO）協議（Kerberos，SAML，OpenID 等）允許用戶使用單個 ID 和密碼來訪問不同的應用程序。用戶登錄以獲得對連接系統的訪問權限，或者使用輕型目錄訪問協議（LDAP）和（目錄）服務器上存儲的 LDAP 數據庫來完成訪問。 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/:3:0","tags":["Kerberos"],"title":"Single Sign on With Kerberos","uri":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/"},{"categories":["Kerberos"],"content":"SPNEGO SPNEGO 代表\"簡單和受保護的 GSS_API 協商機制\"，用於擴展基於 Kerberos 的 SSO 環境以用於 Web Application，因為 SPNEGO 被設計用於 Client Server 桌面環境，通常不用於 Web Application 或簡易 Client 環境 Spnego 是一種與身份驗證器協商使用哪種安全協議的機制 例如 Kerberos，NTLM，摘要或 Basic.5t6 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/:4:0","tags":["Kerberos"],"title":"Single Sign on With Kerberos","uri":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/"},{"categories":["Kerberos"],"content":"SPN(Service Principal Names) 服務主體名稱 (SPN) 是服務實例的唯一標識符 Kerberos 身份驗證使用 SPN 將服務實例與服務登錄帳戶關聯 這允許用戶端應用程式請求服務對帳戶進行身份驗證，即使客戶端沒有帳戶名稱 如果在整個林中的電腦上安裝多個服務實例，則每個實例必須有自己的 SPN 如果用戶端可能使用多個名稱進行身份驗證，則給定的服務實例可以有多個 SPN 例如，SPN 始終包含運行服務實例的主機的名稱，因此服務實例可能會為其主機的每個名稱或別名註冊 SPN 在 Kerberos 身份驗證服務可以使用 SPN 對服務進行身份驗證之前，必須在服務實例用於登錄的帳戶物件上註冊 SPN 給定的 SPN 只能在一個帳戶上註冊 對於 Win32 服務，服務安裝程式在安裝服務實例時指定登錄帳戶 然後，安裝程式組成 SPN，並將它們作為活動目錄域服務中的帳戶物件的屬性編寫 如果服務實例的登錄帳戶發生更改，則必須在新帳戶下重新註冊 SPN 當用戶端想要連接到服務時，它會查找服務的實例，為該實例編寫 SPN，連接到該服務，並顯示用於服務的 SPN 進行身份驗證 Client 上的 Application（例如 Browser）嘗試訪問 Web Server 上的受保護頁面 Server 響應要求授權 Application 從 Kerberos KDC 請求 Service ticket 獲得 ticket 後，Application 將其包裝為 SPNEGO 格式的請求，然後通過 Browser 將其發送回 Web Application 執行已部署的 Web Application 的 web container（Tomcat、JBoss EAP 等）對請求進行解包並驗證 ticket 認證成功後，將授予訪問權限 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/:5:0","tags":["Kerberos"],"title":"Single Sign on With Kerberos","uri":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/"},{"categories":["Kerberos"],"content":"Browser 如何透過 Kerberos 進行身分驗證 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/:6:0","tags":["Kerberos"],"title":"Single Sign on With Kerberos","uri":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/"},{"categories":["Kerberos"],"content":"循序圖 User 登錄 Windows，並通過 KDC 進行了身份驗證(對於 Windows，KDC 將是主域控制器) OS 為 User 接收一個 TGT token 當 User 嘗試連接到 Tomcat 服務器(或其他 web container)時，將協商身份驗證機制(紅字原文: the authentication mechanism is negotiated) User 的 token 被傳遞給 Tomcat，然後 Tomcat 通過 KDC 對其進行驗證 驗證 User 身份後，Tomcat 隨後從 LDAP 服務器中檢索其角色（在 Windows 中為 Active Directory，這是一種專門處理諸如用戶名和密碼之類的身份信息的數據庫） 並確定他是否有權訪問（Response 200 OK）他在服務器上請求的資源。 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/:6:1","tags":["Kerberos"],"title":"Single Sign on With Kerberos","uri":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/"},{"categories":["Kerberos"],"content":"參考資料 Setting up Kerberos Authentication for a Website in IIS Single Sign On with Kerberos Kerberos Wikipedia 鳥哥的 Linux 私房菜 看完您如果還不明白 Kerberos 原理，算我輸 翻轉工作室-資訊與網路安全技術：第十四章 Kerberos 認證系統 The Secret Security Wiki Kerberos.NET Guide To Setup Kerberos Single Sign-On (SSO) 瞭解 keytab 需求 宅學習 如何使用 Spn，當您在 [網際網路資訊服務上設定 裝載的 Web 應用程式] Microsoft Developer-Service Principal Names 瞭解 keytab 需求 All you need to know about Keytab files ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/:7:0","tags":["Kerberos"],"title":"Single Sign on With Kerberos","uri":"https://loulazynote.github.io/posts/single-sign-on-with-kerberos/"},{"categories":["C＃","Maintain","Asp.Net"],"content":"MVC 5 filter ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/mvc5_meta/:0:0","tags":["Asp.Net MVC"],"title":"MVC 5 filter","uri":"https://loulazynote.github.io/posts/mvc5_meta/"},{"categories":["C＃","Maintain","Asp.Net"],"content":"Filter Filter 的作用是在 Action 執行前或執行後做一些加工處理 Authorization Filter： Authorization 是五種 Filter 中優先序最高的，通常用於驗證 Request 合不合法，不合法後面就直接跳過。 Resource Filter： Resource 是第二優先，會在 Authorization 之後，Model Binding 之前執行。通常會是需要對 Model 加工處裡才用。 Action Filter： 最容易使用的 Filter，封包進出都會經過它，使用上沒什麼需要特別注意的。跟 Resource Filter 很類似，但並不會經過 Model Binding。 Exception Filter： 異常處理的 Exception。 Result Filter： 當 Action 完成後，最終會經過的 Filter。 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/mvc5_meta/:1:0","tags":["Asp.Net MVC"],"title":"MVC 5 filter","uri":"https://loulazynote.github.io/posts/mvc5_meta/"},{"categories":["C＃","Maintain","Asp.Net"],"content":"運作方式 ASP .NET Core 的每個 Request 都會先經過已註冊的 Middleware 接著才會執行 Filter，除了會依照上述的順序外，同類型的 Filter 預設都會以先進後出的方式處裡封包。 Response 在某些 Filter 並不會做處理，會值接 Bypass。Request 及 Response 的運作流程如下圖： 黃色箭頭是正常情況流程 灰色箭頭是異常處理流程 ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/mvc5_meta/:1:1","tags":["Asp.Net MVC"],"title":"MVC 5 filter","uri":"https://loulazynote.github.io/posts/mvc5_meta/"},{"categories":["C＃","Maintain","Asp.Net"],"content":"參考資料 John Wu’s [鐵人賽 Day14] ASP.NET Core 2 系列 - Filters ","date":"2022-06-09","objectID":"https://loulazynote.github.io/posts/mvc5_meta/:2:0","tags":["Asp.Net MVC"],"title":"MVC 5 filter","uri":"https://loulazynote.github.io/posts/mvc5_meta/"},{"categories":["Learning"],"content":"Git 學習筆記 位於索引中的檔案 : Tracked files(追蹤的檔案) 不再索引內的檔案 : Untracked files(未被追蹤的檔案) working tree 是工作目錄 只要 被索引中的檔案內容 跟 工作目錄中的檔案內容一致 就會被稱為一個 “Stage“狀態 只要 被索引中的檔案內容 跟 工作目錄中的檔案內容不一致 就會被稱為一個 “Unstage“狀態 ","date":"2022-06-08","objectID":"https://loulazynote.github.io/posts/git-learning/:0:0","tags":["Git"],"title":"Git 學習筆記","uri":"https://loulazynote.github.io/posts/git-learning/"},{"categories":["Learning"],"content":"Git 指令 Command: git -m = message init = 建立 add = 加入 GIT 索引 rm = 刪除 status = 看目前狀態 ","date":"2022-06-08","objectID":"https://loulazynote.github.io/posts/git-learning/:1:0","tags":["Git"],"title":"Git 學習筆記","uri":"https://loulazynote.github.io/posts/git-learning/"},{"categories":["Learning"],"content":"git diff 顯示差異 HEAD = 比對變更與目前最新版的變更差異 -cached = 索引裡的變更與本地儲存庫最新的變更差異 --binary = 比對二進位檔案差異 --name-only = 比對工作目錄檔案,列出檔案名稱 --name-status = 列出工作目錄及索引之間有多少檔案是被異動的 git diff 'src-commit' 'tgt-commit' commit 與 commit 比較差異 git diff 'commit' 與目標 commit 差異 ","date":"2022-06-08","objectID":"https://loulazynote.github.io/posts/git-learning/:1:1","tags":["Git"],"title":"Git 學習筆記","uri":"https://loulazynote.github.io/posts/git-learning/"},{"categories":["Learning"],"content":"git reset 重置索引 -p = 選取索引中的那些變更有哪些內容要從索引中移除 HEAD = 重置索引及分支(加 ~1 是恢復前一版本,以此類推) --mixed = 重置 HEAD 及索引(預設值) --hard = 重置 HEAD,索引及工作目錄 --hard ORIG_HEAD = 回復前版本(永遠回復 reset 之前的版本) ","date":"2022-06-08","objectID":"https://loulazynote.github.io/posts/git-learning/:1:2","tags":["Git"],"title":"Git 學習筆記","uri":"https://loulazynote.github.io/posts/git-learning/"},{"categories":["Learning"],"content":"git revert 還原歷史上的版本，做相反的 commit -h = help 列出功能 --abort = 取消 --continue = 繼續 --quit = 停止 ","date":"2022-06-08","objectID":"https://loulazynote.github.io/posts/git-learning/:1:3","tags":["Git"],"title":"Git 學習筆記","uri":"https://loulazynote.github.io/posts/git-learning/"},{"categories":["Learning"],"content":"git clone 下載遠端儲存庫 git clone --no-checkout 'URL' 'Filename' 會以 filename 為主並且不做 checkout git clone --bare 'url' 把儲存庫的本身下載下來 ","date":"2022-06-08","objectID":"https://loulazynote.github.io/posts/git-learning/:1:4","tags":["Git"],"title":"Git 學習筆記","uri":"https://loulazynote.github.io/posts/git-learning/"},{"categories":["Learning"],"content":"git log 看紀錄 --oneline = 短的 log 版本 --oneline --graph = log 版本+線圖可加 “-數字” 以顯示筆數 git log --oneline --graph --all -10 全部的歷史資料取 10 筆 ","date":"2022-06-08","objectID":"https://loulazynote.github.io/posts/git-learning/:1:5","tags":["Git"],"title":"Git 學習筆記","uri":"https://loulazynote.github.io/posts/git-learning/"},{"categories":["Learning"],"content":"git reflog 會記錄工作目錄底下做過的每一次的版控紀錄 ","date":"2022-06-08","objectID":"https://loulazynote.github.io/posts/git-learning/:1:6","tags":["Git"],"title":"Git 學習筆記","uri":"https://loulazynote.github.io/posts/git-learning/"},{"categories":["Learning"],"content":"git checkout 取出/取回 -- 'name' = 從索引裡面把 name 檔案的內容整個複製回工作目錄 --orphan = 建立全新分支且沒有 parents checkout -b \"Filename\" 可以新增分支後切換 ","date":"2022-06-08","objectID":"https://loulazynote.github.io/posts/git-learning/:1:7","tags":["Git"],"title":"Git 學習筆記","uri":"https://loulazynote.github.io/posts/git-learning/"},{"categories":["Learning"],"content":"git switch 切換分支 ","date":"2022-06-08","objectID":"https://loulazynote.github.io/posts/git-learning/:1:8","tags":["Git"],"title":"Git 學習筆記","uri":"https://loulazynote.github.io/posts/git-learning/"},{"categories":["Learning"],"content":"git clean 清除工作目錄 -f = 強制刪除 -d = 刪除整個工作目錄 -x = 執行清除任務,並忽略.gitignore 設定 -n = 看那些檔案會被清除 ","date":"2022-06-08","objectID":"https://loulazynote.github.io/posts/git-learning/:1:9","tags":["Git"],"title":"Git 學習筆記","uri":"https://loulazynote.github.io/posts/git-learning/"},{"categories":["Learning"],"content":"git stash 暫存工作目錄的變更 save 'message' = 暫存 pop = 取回暫存 ","date":"2022-06-08","objectID":"https://loulazynote.github.io/posts/git-learning/:1:10","tags":["Git"],"title":"Git 學習筆記","uri":"https://loulazynote.github.io/posts/git-learning/"},{"categories":["Learning"],"content":"git branch 查看分支/新增分支 -d = 刪除分支(只能刪除已經合併的分支) -D = 強制刪除分支 -r = 列出所有遠端追蹤分支 -a = 列出所有遠端+本地分支 git branch --merged 列出所有已合併過的分支 git branch --no-merged 列出所有未合併過的分支 git branch --merged | egrep -v \"(^\\*|master|develop)\" | xargs git branch -d 刪除所有已合併過的分支(CMD/Powershell 不可用) ","date":"2022-06-08","objectID":"https://loulazynote.github.io/posts/git-learning/:1:11","tags":["Git"],"title":"Git 學習筆記","uri":"https://loulazynote.github.io/posts/git-learning/"},{"categories":["Learning"],"content":"git merge 合併分支 --ff = 快轉合併(預設) --no-ff = 非快轉合併 --ff-only = 僅有快轉合併 --no-commit = 不提交的合併 --abort = 放棄合併 --squash = 壓縮後合併(不可以與關閉快轉機制一起使用,且不會有合併線圖出現) git merge --no-ff --no-commit 'branchName' 合併可以不 commit ","date":"2022-06-08","objectID":"https://loulazynote.github.io/posts/git-learning/:1:12","tags":["Git"],"title":"Git 學習筆記","uri":"https://loulazynote.github.io/posts/git-learning/"},{"categories":["Learning"],"content":"git rebase 'commit_id' 重訂基底合併 -i --continue = 繼續 --skip = --abort = 取消 ","date":"2022-06-08","objectID":"https://loulazynote.github.io/posts/git-learning/:1:13","tags":["Git"],"title":"Git 學習筆記","uri":"https://loulazynote.github.io/posts/git-learning/"},{"categories":["Learning"],"content":"git cherry-pick 正向挑選合併 --continue = 繼續 --quit = 停止 --abort = 取消 ","date":"2022-06-08","objectID":"https://loulazynote.github.io/posts/git-learning/:1:14","tags":["Git"],"title":"Git 學習筆記","uri":"https://loulazynote.github.io/posts/git-learning/"},{"categories":["Learning"],"content":"git push 推送至遠端 --all = 全部分支推送 git push -u origin master 將本地分支(master)與遠端分支(origin)建立連結 git push origin --delete ‘branchName’ 刪除遠端分支(要先把本地刪除) ","date":"2022-06-08","objectID":"https://loulazynote.github.io/posts/git-learning/:1:15","tags":["Git"],"title":"Git 學習筆記","uri":"https://loulazynote.github.io/posts/git-learning/"},{"categories":["Learning"],"content":"git fetch 將遠端儲存庫的變更下載回來 --prune 將遠端已刪除的分支剪除 ","date":"2022-06-08","objectID":"https://loulazynote.github.io/posts/git-learning/:1:16","tags":["Git"],"title":"Git 學習筆記","uri":"https://loulazynote.github.io/posts/git-learning/"},{"categories":["Learning"],"content":"git pull 將遠端儲存庫拉下來 pull = git fetch + git merge git pull --rebase = git fetch + git rebase ","date":"2022-06-08","objectID":"https://loulazynote.github.io/posts/git-learning/:1:17","tags":["Git"],"title":"Git 學習筆記","uri":"https://loulazynote.github.io/posts/git-learning/"},{"categories":["Learning"],"content":"git remote 遠端 -v = 列出網址 -h = remote 的 help set-url = 更改網址 git remote set-url origin 'new url' 將舊網址改成新網址 ","date":"2022-06-08","objectID":"https://loulazynote.github.io/posts/git-learning/:1:18","tags":["Git"],"title":"Git 學習筆記","uri":"https://loulazynote.github.io/posts/git-learning/"},{"categories":["Learning"],"content":"git commit 建立版本 ","date":"2022-06-08","objectID":"https://loulazynote.github.io/posts/git-learning/:1:19","tags":["Git"],"title":"Git 學習筆記","uri":"https://loulazynote.github.io/posts/git-learning/"},{"categories":["Learning"],"content":"git apply 套用版本(進版) --check = 確認檔案 --reverse = 退版(簡寫-R) ","date":"2022-06-08","objectID":"https://loulazynote.github.io/posts/git-learning/:1:20","tags":["Git"],"title":"Git 學習筆記","uri":"https://loulazynote.github.io/posts/git-learning/"},{"categories":["Learning"],"content":"git config GIT 的設定 加上 --global 可以設定 core.quotepath = 改 false 可顯示中文 core.editor = 查看目前編輯器 git 只能顯示 ASCII 的字元 git bash 以外的環境要改中文 set LC_ALL=C.UTF-8 更改環境變數 (永久儲存) setx LC_ALL C.UTF-8 MAC/Linux export LC_ALL=C.UTF-8 ","date":"2022-06-08","objectID":"https://loulazynote.github.io/posts/git-learning/:1:21","tags":["Git"],"title":"Git 學習筆記","uri":"https://loulazynote.github.io/posts/git-learning/"},{"categories":["Learning"],"content":"衝突問題 顯示訊息: content = 內容衝突 建議用手動合併 ","date":"2022-06-08","objectID":"https://loulazynote.github.io/posts/git-learning/:2:0","tags":["Git"],"title":"Git 學習筆記","uri":"https://loulazynote.github.io/posts/git-learning/"},{"categories":["Learning"],"content":"參考資料 為自己學 GIT-另一種合併方式（使用 rebase） ","date":"2022-06-08","objectID":"https://loulazynote.github.io/posts/git-learning/:3:0","tags":["Git"],"title":"Git 學習筆記","uri":"https://loulazynote.github.io/posts/git-learning/"}]